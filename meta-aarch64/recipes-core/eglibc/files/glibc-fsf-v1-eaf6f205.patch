diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/Implies glibc/ports/sysdeps/aarch64/Implies
--- glibc.orig/ports/sysdeps/aarch64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/Implies	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,6 @@
+wordsize-64
+ieee754/ldbl-128
+ieee754/dbl-64/wordsize-64
+ieee754/dbl-64
+ieee754/flt-32
+aarch64/soft-fp
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/Makefile glibc/ports/sysdeps/aarch64/Makefile
--- glibc.orig/ports/sysdeps/aarch64/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/Makefile	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,21 @@
+long-double-fcts = yes
+
+ifeq ($(subdir),debug)
+CFLAGS-backtrace.c += -funwind-tables
+CFLAGS-tst-backtrace2.c += -funwind-tables
+CFLAGS-tst-backtrace3.c += -funwind-tables
+CFLAGS-tst-backtrace4.c += -funwind-tables
+CFLAGS-tst-backtrace5.c += -funwind-tables
+CFLAGS-tst-backtrace6.c += -funwind-tables
+endif
+
+ifeq ($(subdir),elf)
+sysdep-dl-routines += tlsdesc dl-tlsdesc
+sysdep_routines += tlsdesc dl-tlsdesc
+sysdep-rtld-routines += tlsdesc dl-tlsdesc
+gen-as-const-headers += dl-link.sym
+endif
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tlsdesc.sym
+endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/__longjmp.S glibc/ports/sysdeps/aarch64/__longjmp.S
--- glibc.orig/ports/sysdeps/aarch64/__longjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/__longjmp.S	2012-09-24 13:01:47.000000000 +0100
@@ -0,0 +1,102 @@
+/* Copyright (C) 1997, 1998, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <jmpbuf-offsets.h>
+
+/* __longjmp(jmpbuf, val) */
+
+ENTRY (__longjmp)
+#ifdef CHECK_SP
+	ldr	x5, [x0, #JB_SP<<3]
+	CHECK_SP (x5)
+#endif
+	cfi_def_cfa(x0, 0)
+	cfi_offset(x19, JB_X19<<3)
+	cfi_offset(x20, JB_X20<<3)
+	cfi_offset(x21, JB_X21<<3)
+	cfi_offset(x22, JB_X22<<3)
+	cfi_offset(x23, JB_X23<<3)
+	cfi_offset(x24, JB_X24<<3)
+	cfi_offset(x25, JB_X25<<3)
+	cfi_offset(x26, JB_X26<<3)
+	cfi_offset(x27, JB_X27<<3)
+	cfi_offset(x28, JB_X28<<3)
+	cfi_offset(x29, JB_X29<<3)
+	cfi_offset(x30, JB_LR<<3)
+
+	cfi_offset( d8, JB_D8<<3)
+	cfi_offset( d9, JB_D9<<3)
+	cfi_offset(d10, JB_D10<<3)
+	cfi_offset(d11, JB_D11<<3)
+	cfi_offset(d12, JB_D12<<3)
+	cfi_offset(d13, JB_D13<<3)
+	cfi_offset(d14, JB_D14<<3)
+	cfi_offset(d15, JB_D15<<3)
+
+	ldp	x19, x20, [x0, #JB_X19<<3]
+	ldp	x21, x22, [x0, #JB_X21<<3]
+	ldp	x23, x24, [x0, #JB_X23<<3]
+	ldp	x25, x26, [x0, #JB_X25<<3]
+	ldp	x27, x28, [x0, #JB_X27<<3]
+	ldp	x29, x30, [x0, #JB_X29<<3]
+
+	ldp	 d8,  d9, [x0, #JB_D8<<3]
+	ldp	d10, d11, [x0, #JB_D10<<3]
+	ldp	d12, d13, [x0, #JB_D12<<3]
+	ldp	d14, d15, [x0, #JB_D14<<3]
+
+        /* Originally this was implemented with a series of
+	   .cfi_restore() directives.
+
+           The theory was that cfi_restore should revert to previous
+           frame value is the same as the current value.  In practice
+           this doesn't work, even after cfi_restore() gdb continues
+           to try to recover a previous frame value offset from x0,
+           which gets stuffed after a few more instructions.  The
+           cfi_same_value() mechanism appears to work fine.  */
+
+	cfi_same_value(x19)
+	cfi_same_value(x20)
+	cfi_same_value(x21)
+	cfi_same_value(x22)
+	cfi_same_value(x23)
+	cfi_same_value(x24)
+	cfi_same_value(x25)
+	cfi_same_value(x26)
+	cfi_same_value(x27)
+	cfi_same_value(x28)
+	cfi_same_value(x29)
+	cfi_same_value(x30)
+	cfi_same_value(d8)
+	cfi_same_value(d9)
+	cfi_same_value(d10)
+	cfi_same_value(d11)
+	cfi_same_value(d12)
+	cfi_same_value(d13)
+	cfi_same_value(d14)
+	cfi_same_value(d15)
+
+	ldr	x5,  [x0, #JB_SP<<3]
+	mov	sp, x5
+	cmp	x1, #0
+	mov	x0, #1
+	csel	x0, x1, x0, ne
+	/* Use br instead of ret because ret is guaranteed to mispredict */
+	br	x30
+END (__longjmp)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/backtrace.c glibc/ports/sysdeps/aarch64/backtrace.c
--- glibc.orig/ports/sysdeps/aarch64/backtrace.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/backtrace.c	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/x86_64/backtrace.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/atomic.h glibc/ports/sysdeps/aarch64/bits/atomic.h
--- glibc.orig/ports/sysdeps/aarch64/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/atomic.h	2012-09-24 13:02:01.000000000 +0100
@@ -0,0 +1,109 @@
+/* Copyright (C) 2003, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _AARCH64_BITS_ATOMIC_H
+#define _AARCH64_BITS_ATOMIC_H	1
+
+#include <stdint.h>
+
+typedef int8_t  atomic8_t;
+typedef int16_t atomic16_t;
+typedef int32_t atomic32_t;
+typedef int64_t atomic64_t;
+
+typedef uint8_t  uatomic8_t;
+typedef uint16_t uatomic16_t;
+typedef uint32_t uatomic32_t;
+typedef uint64_t uatomic64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#define __arch_compare_and_exchange_bool_8_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (oldval), (newval)))
+
+#define __arch_compare_and_exchange_bool_16_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (oldval), (newval)))
+
+#define __arch_compare_and_exchange_bool_32_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (oldval), (newval)))
+
+#define __arch_compare_and_exchange_bool_64_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (oldval), (newval)))
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (oldval), (newval))
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (oldval), (newval))
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (oldval), (newval))
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (oldval), (newval))
+
+/* Atomically store newval and return the old value.  */
+#define atomic_exchange_acq(mem, value) \
+  __sync_lock_test_and_set (mem, value)
+
+#define atomic_exchange_rel(mem, value) \
+  (__sync_synchronize (), __sync_lock_test_and_set (mem, value))
+
+#define atomic_exchange_and_add(mem, value) \
+  ({ __typeof (*mem) __result;						      \
+     __result = __sync_fetch_and_add ((mem), (int) (value));		      \
+     __result; })
+
+#define atomic_decrement_if_positive(mem) \
+  ({ __typeof (*mem) __oldval, __val;					      \
+     __typeof (mem) __memp = (mem);					      \
+									      \
+     __val = (*__memp);							      \
+     do									      \
+       {								      \
+	 __oldval = __val;						      \
+	 if (__builtin_expect (__val <= 0, 0))				      \
+	   break;							      \
+	 __val = atomic_compare_and_exchange_val_acq (__memp,	__oldval - 1, \
+						      __oldval);	      \
+       }								      \
+     while (__builtin_expect (__val != __oldval, 0));			      \
+     __oldval; })
+
+#define atomic_bit_test_set(mem, bit) \
+  ({ __typeof (*mem) __oldval, __val;					      \
+     __typeof (mem) __memp = (mem);					      \
+     __typeof (*mem) __mask = ((__typeof (*mem)) 1 << (bit));		      \
+									      \
+     __val = (*__memp);							      \
+     do									      \
+       {								      \
+	 __oldval = __val;						      \
+	 __val = atomic_compare_and_exchange_val_acq (__memp,		      \
+						      __oldval | __mask,      \
+						      __oldval);	      \
+       }								      \
+     while (__builtin_expect (__val != __oldval, 0));			      \
+     __oldval & __mask; })
+
+#define atomic_full_barrier() __sync_synchronize ()
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/endian.h glibc/ports/sysdeps/aarch64/bits/endian.h
--- glibc.orig/ports/sysdeps/aarch64/bits/endian.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/endian.h	2012-09-24 13:02:10.000000000 +0100
@@ -0,0 +1,30 @@
+/* Copyright (C) 1997, 1998, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+/* AArch64 can be either big or little endian.  */
+#ifdef __AARCH64EB__
+#define __BYTE_ORDER __BIG_ENDIAN
+#else
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
+
+#define __FLOAT_WORD_ORDER __BYTE_ORDER
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/fenv.h glibc/ports/sysdeps/aarch64/bits/fenv.h
--- glibc.orig/ports/sysdeps/aarch64/bits/fenv.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/fenv.h	2012-09-24 13:02:18.000000000 +0100
@@ -0,0 +1,61 @@
+/* Copyright (C) 2004, 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+/* Define bits representing exceptions in the FPSR status word.  */
+#define FE_INVALID     1
+#define FE_DIVBYZERO   2
+#define FE_OVERFLOW    4
+#define FE_UNDERFLOW   8
+#define FE_INEXACT    16
+
+/* Amount to shift by to convert an exception bit in FPSR to a an
+   exception bit mask in FPCR.  */
+#define FE_EXCEPT_SHIFT	8
+
+/* All supported exceptions.  */
+#define FE_ALL_EXCEPT	\
+	(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW | FE_INEXACT)
+
+/* Define bits representing rounding modes in the FPCR Rmode field.  */
+#define FE_TONEAREST  0x000000
+#define FE_UPWARD     0x400000
+#define FE_DOWNWARD   0x800000
+#define FE_TOWARDZERO 0xc00000
+
+/* Type representing exception flags. */
+typedef unsigned int fexcept_t;
+
+/* Type representing floating-point environment.  */
+typedef struct
+  {
+    unsigned int fpcr;
+    unsigned int fpsr;
+  }
+fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((fenv_t *) -1l)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exceptions are masked.  */
+# define FE_NOMASK_ENV  ((__const fenv_t *) -2)
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/link.h glibc/ports/sysdeps/aarch64/bits/link.h
--- glibc.orig/ports/sysdeps/aarch64/bits/link.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/link.h	2012-09-24 13:02:25.000000000 +0100
@@ -0,0 +1,60 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+/* Registers for entry into PLT on AArch64.  */
+typedef struct La_aarch64_regs
+{
+  uint64_t lr_xreg[8];
+  uint64_t lr_dreg[8];
+  uint64_t lr_sp;
+  uint64_t lr_lr;
+} La_aarch64_regs;
+
+/* Return values for calls from PLT on AArch64.  */
+typedef struct La_aarch64_retval
+{
+  /* Up to two integer registers can be used for a return value.  */
+  uint64_t lrv_xreg[2];
+  /* Up to four D registers can be used for a return value.  */
+  uint64_t lrv_dreg[4];
+
+} La_aarch64_retval;
+__BEGIN_DECLS
+
+extern Elf64_Addr
+la_aarch64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+			 uintptr_t *__refcook,
+			 uintptr_t *__defcook,
+			 La_aarch64_regs *__regs,
+			 unsigned int *__flags,
+			 const char *__symname,
+			 long int *__framesizep);
+
+extern unsigned int
+la_aarch64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+			uintptr_t *__refcook,
+			uintptr_t *__defcook,
+			const La_aarch64_regs *__inregs,
+			La_aarch64_retval *__outregs,
+			const char *__symname);
+
+__END_DECLS
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/linkmap.h glibc/ports/sysdeps/aarch64/bits/linkmap.h
--- glibc.orig/ports/sysdeps/aarch64/bits/linkmap.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/linkmap.h	2012-09-24 13:02:41.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+struct link_map_machine
+{
+  ElfW(Addr) plt;	  /* Address of .plt */
+  void *tlsdesc_table;	  /* Address of TLS descriptor hash table.  */
+};
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/mathdef.h glibc/ports/sysdeps/aarch64/bits/mathdef.h
--- glibc.orig/ports/sysdeps/aarch64/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/mathdef.h	2012-09-24 13:02:49.000000000 +0100
@@ -0,0 +1,51 @@
+/* Copyright (C) 1999, 2000, 2004, 2006, 2007, 2010-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* GCC does not promote `float' values to `double'.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	(2147483647)
+
+/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
+   builtins are supported.  */
+# if __FP_FAST_FMA
+#  define FP_FAST_FMA 1
+# endif
+
+# if __FP_FAST_FMAF
+#  define FP_FAST_FMAF 1
+# endif
+
+# if __FP_FAST_FMAL
+#  define FP_FAST_FMAL 1
+# endif
+
+#endif	/* ISO C99 */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bits/setjmp.h glibc/ports/sysdeps/aarch64/bits/setjmp.h
--- glibc.orig/ports/sysdeps/aarch64/bits/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bits/setjmp.h	2012-09-24 13:03:03.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (C) 1997, 1998, 2005, 2006, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H 1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+/* Jump buffer contains:
+   x19-x28, x29(fp), x30(lr), (x31)sp, d8-d15.  Other registers are not
+   saved.  */
+typedef unsigned long long __jmp_buf [22];
+
+#endif
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bsd-_setjmp.S glibc/ports/sysdeps/aarch64/bsd-_setjmp.S
--- glibc.orig/ports/sysdeps/aarch64/bsd-_setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bsd-_setjmp.S	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1 @@
+/* _setjmp is in setjmp.S  */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/bsd-setjmp.S glibc/ports/sysdeps/aarch64/bsd-setjmp.S
--- glibc.orig/ports/sysdeps/aarch64/bsd-setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/bsd-setjmp.S	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1 @@
+/* setjmp is in setjmp.S  */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/crti.S glibc/ports/sysdeps/aarch64/crti.S
--- glibc.orig/ports/sysdeps/aarch64/crti.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/crti.S	2012-09-24 13:03:14.000000000 +0100
@@ -0,0 +1,90 @@
+/* Special .init and .fini section support for AArch64.
+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* crti.S puts a function prologue at the beginning of the .init and
+   .fini sections and defines global symbols for those addresses, so
+   they can be called as functions.  The symbols _init and _fini are
+   magic and cause the linker to emit DT_INIT and DT_FINI.  */
+
+#include <libc-symbols.h>
+
+#ifndef PREINIT_FUNCTION
+# define PREINIT_FUNCTION __gmon_start__
+#endif
+
+#ifndef PREINIT_FUNCTION_WEAK
+# define PREINIT_FUNCTION_WEAK 1
+#endif
+
+#if PREINIT_FUNCTION_WEAK
+	weak_extern (PREINIT_FUNCTION)
+#else
+	.hidden PREINIT_FUNCTION
+#endif
+
+#if PREINIT_FUNCTION_WEAK
+	.align	2
+	.type	call_weak_fn, %function
+call_weak_fn:
+	adrp	x0, :got:PREINIT_FUNCTION
+	ldr	x0, [x0, #:got_lo12:PREINIT_FUNCTION]
+	cbz	x0, 1f
+	b	PREINIT_FUNCTION
+1:
+	RET
+	.size	call_weak_fn, .-call_weak_fn
+#endif
+
+	.section .init,"ax",%progbits
+	.align	2
+	.global	_init
+	.type	_init, %function
+_init:
+	stp	x29, x30, [sp, -16]!
+	mov	x29, sp
+#if PREINIT_FUNCTION_WEAK
+	bl	call_weak_fn
+#else
+	bl	PREINIT_FUNCTION
+#endif
+
+	.section	.fini,"ax",%progbits
+	.align	2
+	.global	_fini
+	.type	_fini, %function
+_fini:
+	stp	x29, x30, [sp, -16]!
+	mov	x29, sp
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/crtn.S glibc/ports/sysdeps/aarch64/crtn.S
--- glibc.orig/ports/sysdeps/aarch64/crtn.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/crtn.S	2012-09-24 13:03:18.000000000 +0100
@@ -0,0 +1,46 @@
+/* Special .init and .fini section support for AArch64.
+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* crtn.S puts function epilogues in the .init and .fini sections
+   corresponding to the prologues in crti.S. */
+
+	.section .init,"ax",%progbits
+	ldp	x29, x30, [sp], 16
+	RET
+
+	.section .fini,"ax",%progbits
+	ldp	x29, x30, [sp], 16
+	RET
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-irel.h glibc/ports/sysdeps/aarch64/dl-irel.h
--- glibc.orig/ports/sysdeps/aarch64/dl-irel.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-irel.h	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,36 @@
+/* Machine-dependent ELF indirect relocation inline functions.
+   AArch64 version.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _DL_IREL_H
+#define _DL_IREL_H
+
+#include <stdio.h>
+#include <unistd.h>
+
+/* AArch64 does not yet implement IFUNC support.  However since
+   2011-06-20 provision of a elf_ifunc_invoke has been mandatory.  */
+
+static inline ElfW(Addr)
+__attribute ((always_inline))
+elf_ifunc_invoke (ElfW(Addr) addr)
+{
+  return ((ElfW(Addr) (*) (void)) (addr)) ();
+}
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-link.sym glibc/ports/sysdeps/aarch64/dl-link.sym
--- glibc.orig/ports/sysdeps/aarch64/dl-link.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-link.sym	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,15 @@
+#include <stddef.h>
+#include <sysdep.h>
+#include <link.h>
+#include <dl-tlsdesc.h>
+
+DL_SIZEOF_RG		sizeof(struct La_aarch64_regs)
+DL_SIZEOF_RV		sizeof(struct La_aarch64_retval)
+
+DL_OFFSET_RG_X0		offsetof(struct La_aarch64_regs, lr_xreg)
+DL_OFFSET_RG_D0		offsetof(struct La_aarch64_regs, lr_dreg)
+DL_OFFSET_RG_SP		offsetof(struct La_aarch64_regs, lr_sp)
+DL_OFFSET_RG_LR		offsetof(struct La_aarch64_regs, lr_lr)
+
+DL_OFFSET_RV_X0		offsetof(struct La_aarch64_retval, lrv_xreg)
+DL_OFFSET_RV_D0		offsetof(struct La_aarch64_retval, lrv_dreg)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-machine.h glibc/ports/sysdeps/aarch64/dl-machine.h
--- glibc.orig/ports/sysdeps/aarch64/dl-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-machine.h	2012-09-24 13:04:02.000000000 +0100
@@ -0,0 +1,388 @@
+/* Copyright (C) 1995-2006, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "aarch64"
+
+#include <tls.h>
+#include <dl-tlsdesc.h>
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute__ ((unused))
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  return ehdr->e_machine == EM_AARCH64;
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT. */
+static inline ElfW(Addr) __attribute__ ((unused))
+elf_machine_dynamic (void)
+{
+  ElfW(Addr) addr = (ElfW(Addr)) &_DYNAMIC;
+  return addr;
+}
+
+/* Return the run-time load address of the shared object.  */
+
+static inline ElfW(Addr) __attribute__ ((unused))
+elf_machine_load_address (void)
+{
+  /* To figure out the load address we use the definition that for any symbol:
+     dynamic_addr(symbol) = static_addr(symbol) + load_addr
+
+     The choice of symbol is arbitrary. The static address we obtain
+     by constructing a non GOT reference to the symbol, the dynamic
+     address of the symbol we compute using adrp/add to compute the
+     symbol's address relative to the PC. */
+
+  ElfW(Addr) static_addr;
+  ElfW(Addr) dynamic_addr;
+
+  asm ("					\n\
+	adrp	%1, _dl_start;			\n\
+        add	%1, %1, #:lo12:_dl_start        \n\
+        ldr	%w0, 1f				\n\
+	b	2f				\n\
+1:	.word	_dl_start			\n\
+2:						\n\
+       " : "=r" (static_addr),  "=r" (dynamic_addr));
+  return dynamic_addr - static_addr;
+}
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int __attribute__ ((unused))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      ElfW(Addr) *got;
+      extern void _dl_runtime_resolve (ElfW(Word));
+      extern void _dl_runtime_profile (ElfW(Word));
+
+      got = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+      if (got[1])
+	{
+	  l->l_mach.plt = got[1] + l->l_addr;
+	}
+      got[1] = (ElfW(Addr)) l;
+
+      /* The got[2] entry contains the address of a function which gets
+	 called to get the address of a so far unresolved function and
+	 jump to it.  The profiling extension of the dynamic linker allows
+	 to intercept the calls to collect information.  In this case we
+	 don't store the address in the GOT so that all future calls also
+	 end in this function.  */
+      if ( profile)
+	{
+	   got[2] = (ElfW(Addr)) &_dl_runtime_profile;
+
+	  if (GLRO(dl_profile) != NULL
+	      && _dl_name_match_p (GLRO(dl_profile), l))
+	    /* Say that we really want profiling and the timers are
+	       started.  */
+	    GL(dl_profile_map) = l;
+	}
+      else
+	{
+	  /* This function will get called to fix up the GOT entry
+	     indicated by the offset on the stack, and then jump to
+	     the resolved address.  */
+	  got[2] = (ElfW(Addr)) &_dl_runtime_resolve;
+	}
+    }
+
+  if (l->l_info[ADDRIDX (DT_TLSDESC_GOT)] && lazy)
+    *(Elf64_Addr*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
+      = (Elf64_Addr) &_dl_tlsdesc_resolve_rela;
+
+  return lazy;
+}
+
+/* Initial entry point for the dynamic linker. The C function
+   _dl_start is the real entry point, its return value is the user
+   program's entry point */
+
+#define RTLD_START asm ("\
+.text								\n\
+.globl _start							\n\
+.type _start, %function						\n\
+.globl _dl_start_user						\n\
+.type _dl_start_user, %function					\n\
+_start:								\n\
+	mov	x0,	sp					\n\
+	bl	_dl_start					\n\
+	// returns user entry point in x0			\n\
+	mov	x21, x0						\n\
+_dl_start_user:							\n\
+	// get the original arg count				\n\
+	ldr	x1, [sp]					\n\
+	// get the argv address					\n\
+	add	x2, sp, #8					\n\
+	// get _dl_skip_args to see if we were			\n\
+	// invoked as an executable				\n\
+	adrp	x4, _dl_skip_args				\n\
+        ldr	w4, [x4, #:lo12:_dl_skip_args]			\n\
+	// do we need to adjust argc/argv			\n\
+        cmp	w4, 0						\n\
+	beq	.L_done_stack_adjust				\n\
+	// subtract _dl_skip_args from original arg count	\n\
+	sub	x1, x1, x4					\n\
+	// store adjusted argc back to stack			\n\
+	str	x1, [sp]					\n\
+	// find the first unskipped argument			\n\
+	mov	x3, x2						\n\
+	add	x4, x2, x4, lsl #3				\n\
+	// shuffle argv down					\n\
+1:	ldr	x5, [x4], #8					\n\
+	str	x5, [x3], #8					\n\
+	cmp	x5, #0						\n\
+	bne	1b						\n\
+	// shuffle envp down					\n\
+1:	ldr	x5, [x4], #8					\n\
+	str	x5, [x3], #8					\n\
+	cmp	x5, #0						\n\
+	bne	1b						\n\
+	// shuffle auxv down					\n\
+1:	ldp	x0, x5, [x4, #16]!				\n\
+	stp	x0, x5, [x3], #16				\n\
+	cmp	x0, #0						\n\
+	bne	1b						\n\
+	// Update _dl_argv					\n\
+	adrp	x3, _dl_argv					\n\
+	str	x2, [x3, #:lo12:_dl_argv]			\n\
+.L_done_stack_adjust:						\n\
+	// compute envp						\n\
+	add	x3, x2, x1, lsl #3				\n\
+	add	x3, x3, #8					\n\
+	adrp	x16, _rtld_local				\n\
+        add	x16, x16, #:lo12:_rtld_local			\n\
+        ldr	x0, [x16]					\n\
+	bl	_dl_init_internal				\n\
+	// load the finalizer function				\n\
+	adrp	x0, _dl_fini					\n\
+	add	x0, x0, #:lo12:_dl_fini				\n\
+	// jump to the user_s entry point			\n\
+	br      x21						\n\
+");
+
+#define elf_machine_type_class(type)					\
+  ((((type) == R_AARCH64_JUMP_SLOT ||					\
+     (type) == R_AARCH64_TLS_DTPMOD64 ||				\
+     (type) == R_AARCH64_TLS_DTPREL64 ||				\
+     (type) == R_AARCH64_TLS_TPREL64 ||					\
+     (type) == R_AARCH64_TLSDESC) * ELF_RTYPE_CLASS_PLT)		\
+   | (((type) == R_AARCH64_COPY) * ELF_RTYPE_CLASS_COPY))
+
+#define ELF_MACHINE_JMP_SLOT	R_AARCH64_JUMP_SLOT
+
+/* AArch64 uses RELA not REL */
+#define ELF_MACHINE_NO_REL 1
+
+static inline ElfW(Addr)
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const ElfW(Rela) *reloc,
+		       ElfW(Addr) *reloc_addr,
+		       ElfW(Addr) value)
+{
+  return *reloc_addr = value;
+}
+
+/* Return the final value of a plt relocation.  */
+static inline ElfW(Addr)
+elf_machine_plt_value (struct link_map *map,
+		       const ElfW(Rela) *reloc,
+		       ElfW(Addr) value)
+{
+  return value;
+}
+
+#endif
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER aarch64_gnu_pltenter
+#define ARCH_LA_PLTEXIT  aarch64_gnu_pltexit
+
+#ifdef RESOLVE_MAP
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
+		  void *const reloc_addr_arg, int skip_ifunc)
+{
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+  const unsigned int r_type = ELF64_R_TYPE (reloc->r_info);
+
+  if (__builtin_expect (r_type == R_AARCH64_RELATIVE, 0))
+      *reloc_addr = map->l_addr + reloc->r_addend;
+  else if (__builtin_expect (r_type == R_AARCH64_NONE, 0))
+      return;
+  else
+    {
+      const ElfW(Sym) *const refsym = sym;
+      struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+      ElfW(Addr) value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+      switch (r_type)
+	{
+	case R_AARCH64_COPY:
+	  if (sym == NULL)
+	      break;
+
+	  if (sym->st_size > refsym->st_size
+	      || (GLRO(dl_verbose) && sym->st_size < refsym->st_size))
+	    {
+	      const char *strtab;
+
+	      strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	      _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	    }
+	  memcpy (reloc_addr_arg, (void *) value,
+		  MIN (sym->st_size, refsym->st_size));
+	  break;
+
+	case R_AARCH64_RELATIVE:
+	case R_AARCH64_GLOB_DAT:
+	case R_AARCH64_JUMP_SLOT:
+	case R_AARCH64_ABS32:
+	case R_AARCH64_ABS64:
+	  *reloc_addr = value + reloc->r_addend;
+	  break;
+
+	case R_AARCH64_TLSDESC:
+	  {
+	    struct tlsdesc volatile *td =
+	      (struct tlsdesc volatile *)reloc_addr;
+#   ifndef RTLD_BOOTSTRAP
+	    if (! sym)
+	      {
+		td->arg = (void*)reloc->r_addend;
+		td->entry = _dl_tlsdesc_undefweak;
+	      }
+	    else
+#endif
+	      {
+#ifndef RTLD_BOOTSTRAP
+#ifndef SHARED
+		CHECK_STATIC_TLS (map, sym_map);
+#else
+		if (!TRY_STATIC_TLS (map, sym_map))
+		  {
+		    td->arg = _dl_make_tlsdesc_dynamic
+		      (sym_map, sym->st_value + reloc->r_addend);
+		    td->entry = _dl_tlsdesc_dynamic;
+		  }
+		else
+#endif
+#endif
+		  {
+		    td->arg = (void*)(sym->st_value + sym_map->l_tls_offset
+				      + reloc->r_addend);
+		    td->entry = _dl_tlsdesc_return;
+		  }
+	      }
+	    break;
+	  }
+
+	case R_AARCH64_TLS_DTPMOD64:
+#ifdef RTLD_BOOTSTRAP
+	  *reloc_addr = 1;
+#else
+	  if (sym_map != NULL)
+	    {
+	      *reloc_addr = sym_map->l_tls_modid;
+	    }
+#endif
+	  break;
+
+	case R_AARCH64_TLS_DTPREL64:
+	  if (sym)
+	    {
+	      const char *strtab;
+	      strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	      *reloc_addr = sym->st_value + reloc->r_addend;
+	    }
+	  break;
+
+	case R_AARCH64_TLS_TPREL64:
+	  if (sym)
+	    {
+	      const char *strtab;
+	      strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	      CHECK_STATIC_TLS (map, sym_map);
+	      *reloc_addr =
+		sym->st_value + reloc->r_addend + sym_map->l_tls_offset;
+	    }
+	  break;
+
+	default:
+	  _dl_reloc_bad_type (map, r_type, 0);
+	  break;
+	}
+    }
+}
+
+inline void
+__attribute__ ((always_inline))
+elf_machine_rela_relative (ElfW(Addr) l_addr,
+			   const ElfW(Rela) *reloc,
+			   void *const reloc_addr_arg)
+{
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+  *reloc_addr = l_addr + reloc->r_addend;
+}
+
+inline void
+__attribute__ ((always_inline))
+elf_machine_lazy_rel (struct link_map *map,
+		      ElfW(Addr) l_addr,
+		      const ElfW(Rela) *reloc,
+		      int skip_ifunc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELF64_R_TYPE (reloc->r_info);
+  /* Check for unexpected PLT reloc type.  */
+  if (__builtin_expect (r_type == R_AARCH64_JUMP_SLOT, 1))
+    {
+      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+	*reloc_addr += l_addr;
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else if (__builtin_expect (r_type == R_AARCH64_TLSDESC, 1))
+    {
+      struct tlsdesc volatile *td =
+	(struct tlsdesc volatile *)reloc_addr;
+
+      td->arg = (void*)reloc;
+      td->entry = (void*)(D_PTR (map, l_info[ADDRIDX (DT_TLSDESC_PLT)])
+			  + map->l_addr);
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-sysdep.h glibc/ports/sysdeps/aarch64/dl-sysdep.h
--- glibc.orig/ports/sysdeps/aarch64/dl-sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-sysdep.h	2012-09-24 13:04:19.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2002-2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include_next <dl-sysdep.h>
+
+/* _dl_argv cannot be attribute_relro, because _dl_start_user
+   might write into it after _dl_start returns.  */
+#define DL_ARGV_NOT_RELRO 1
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-tls.h glibc/ports/sysdeps/aarch64/dl-tls.h
--- glibc.orig/ports/sysdeps/aarch64/dl-tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-tls.h	2012-09-24 13:04:28.000000000 +0100
@@ -0,0 +1,30 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED ((void *) -1l)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-tlsdesc.S glibc/ports/sysdeps/aarch64/dl-tlsdesc.S
--- glibc.orig/ports/sysdeps/aarch64/dl-tlsdesc.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-tlsdesc.S	2012-09-24 13:04:40.000000000 +0100
@@ -0,0 +1,329 @@
+/* Thread-local storage handling in the ELF dynamic linker.
+   AArch64 version.
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include "tlsdesc.h"
+
+#define NSAVEDQREGPAIRS	16
+#define SAVE_Q_REGISTERS				\
+	stp	q0, q1,	[sp, #-32*NSAVEDQREGPAIRS]!;	\
+	cfi_adjust_cfa_offset (32*NSAVEDQREGPAIRS);	\
+	stp	 q2,  q3, [sp, #32*1];			\
+	stp	 q4,  q5, [sp, #32*2];			\
+	stp	 q6,  q7, [sp, #32*3];			\
+	stp	 q8,  q9, [sp, #32*4];			\
+	stp	q10, q11, [sp, #32*5];			\
+	stp	q12, q13, [sp, #32*6];			\
+	stp	q14, q15, [sp, #32*7];			\
+	stp	q16, q17, [sp, #32*8];			\
+	stp	q18, q19, [sp, #32*9];			\
+	stp	q20, q21, [sp, #32*10];			\
+	stp	q22, q23, [sp, #32*11];			\
+	stp	q24, q25, [sp, #32*12];			\
+	stp	q26, q27, [sp, #32*13];			\
+	stp	q28, q29, [sp, #32*14];			\
+	stp	q30, q31, [sp, #32*15];
+
+#define RESTORE_Q_REGISTERS				\
+	ldp	 q2,  q3, [sp, #32*1];			\
+	ldp	 q4,  q5, [sp, #32*2];			\
+	ldp	 q6,  q7, [sp, #32*3];			\
+	ldp	 q8,  q9, [sp, #32*4];			\
+	ldp	q10, q11, [sp, #32*5];			\
+	ldp	q12, q13, [sp, #32*6];			\
+	ldp	q14, q15, [sp, #32*7];			\
+	ldp	q16, q17, [sp, #32*8];			\
+	ldp	q18, q19, [sp, #32*9];			\
+	ldp	q20, q21, [sp, #32*10];			\
+	ldp	q22, q23, [sp, #32*11];			\
+	ldp	q24, q25, [sp, #32*12];			\
+	ldp	q26, q27, [sp, #32*13];			\
+	ldp	q28, q29, [sp, #32*14];			\
+	ldp	q30, q31, [sp, #32*15];			\
+	ldp	 q0,  q1, [sp], #32*NSAVEDQREGPAIRS;	\
+	cfi_adjust_cfa_offset (-32*NSAVEDQREGPAIRS);
+
+	.text
+
+	/* Compute the thread pointer offset for symbols in the static
+	   TLS block. The offset is the same for all threads.
+	   Prototype:
+	   _dl_tlsdesc_return (tlsdesc *) ;
+	 */
+	.hidden _dl_tlsdesc_return
+	.global	_dl_tlsdesc_return
+	.type	_dl_tlsdesc_return,%function
+	cfi_startproc
+	.align 2
+_dl_tlsdesc_return:
+	ldr	x0, [x0, #8]
+	RET
+	cfi_endproc
+	.size	_dl_tlsdesc_return, .-_dl_tlsdesc_return
+
+	/* Handler for undefined weak TLS symbols.
+	   Prototype:
+	   _dl_tlsdesc_undefweak (tlsdesc *);
+
+	   The second word of the descriptor contains the addend.
+	   Return the addend minus the thread pointer. This ensures
+	   that when the caller adds on the thread pointer it gets back
+	   the addend.  */
+
+	.hidden _dl_tlsdesc_undefweak
+	.global	_dl_tlsdesc_undefweak
+	.type	_dl_tlsdesc_undefweak,%function
+	cfi_startproc
+	.align  2
+_dl_tlsdesc_undefweak:
+	str	x1, [sp, #-16]!
+	cfi_adjust_cfa_offset(16)
+	ldr	x0, [x0, #8]
+	mrs	x1, tpidr_el0
+	sub	x0, x0, x1
+	ldr	x1, [sp], #16
+	cfi_adjust_cfa_offset(16)
+	RET
+	cfi_endproc
+	.size	_dl_tlsdesc_undefweak, .-_dl_tlsdesc_undefweak
+
+#ifdef SHARED
+	/* Handler for dynamic TLS symbols.
+	   Prototype:
+	   _dl_tlsdesc_dynamic (tlsdesc *) ;
+
+	   The second word of the descriptor points to a
+	   tlsdesc_dynamic_arg structure.
+
+	   Returns the offset between the thread pointer and the
+	   object referenced by the argument.
+
+	   ptrdiff_t
+	   __attribute__ ((__regparm__ (1)))
+	   _dl_tlsdesc_dynamic (struct tlsdesc *tdp)
+	   {
+	     struct tlsdesc_dynamic_arg *td = tdp->arg;
+	     dtv_t *dtv = *(dtv_t **)((char *)__thread_pointer + DTV_OFFSET);
+	     if (__builtin_expect (td->gen_count <= dtv[0].counter
+		&& (dtv[td->tlsinfo.ti_module].pointer.val
+		    != TLS_DTV_UNALLOCATED),
+		1))
+	       return dtv[td->tlsinfo.ti_module].pointer.val
+		+ td->tlsinfo.ti_offset
+		- __thread_pointer;
+
+	     return ___tls_get_addr (&td->tlsinfo) - __thread_pointer;
+	   }
+	 */
+
+	.hidden _dl_tlsdesc_dynamic
+	.global	_dl_tlsdesc_dynamic
+	.type	_dl_tlsdesc_dynamic,%function
+	cfi_startproc
+	.align 2
+_dl_tlsdesc_dynamic:
+#define NSAVEXREGPAIRS 2
+	stp	x29, x30, [sp,#-(32+16*NSAVEXREGPAIRS)]!
+	cfi_adjust_cfa_offset (32+16*NSAVEXREGPAIRS)
+	mov	x29, sp
+
+	/* Save just enough registers to support fast path, if we fall
+	   into slow path we will save additional registers.  */
+
+	stp	x1,  x2, [sp, #32+16*0]
+	stp	x3,  x4, [sp, #32+16*1]
+
+	mrs	x4, tpidr_el0
+	ldr	x1, [x0,#8]
+	ldr	x0, [x4]
+	ldr	x3, [x1,#16]
+	ldr	x2, [x0]
+	cmp	x3, x2
+	b.hi	2f
+	ldr	x2, [x1]
+	add	x0, x0, x2, lsl #4
+	ldr	x0, [x0]
+	cmn	x0, #0x1
+	b.eq	2f
+	ldr	x1, [x1,#8]
+	add	x0, x0, x1
+	sub	x0, x0, x4
+1:
+	ldp	 x1,  x2, [sp, #32+16*0]
+	ldp	 x3,  x4, [sp, #32+16*1]
+
+	ldp	x29, x30, [sp], #(32+16*NSAVEXREGPAIRS)
+	cfi_adjust_cfa_offset (32+16*NSAVEXREGPAIRS)
+#undef NSAVEXREGPAIRS
+	RET
+2:
+	/* This is the slow path. We need to call __tls_get_addr() which
+	   means we need to save and restore all the register that the
+	   callee will trash.  */
+
+	/* Save the remaining registers that we must treat as caller save.  */
+#define NSAVEXREGPAIRS 7
+	stp	 x5,  x6, [sp, #-16*NSAVEXREGPAIRS]!
+	cfi_adjust_cfa_offset (16*NSAVEXREGPAIRS)
+	stp	 x7,  x8, [sp, #16*1]
+	stp	 x9, x10, [sp, #16*2]
+	stp	x11, x12, [sp, #16*3]
+	stp	x13, x14, [sp, #16*4]
+	stp	x15, x16, [sp, #16*5]
+	stp	x17, x18, [sp, #16*6]
+
+	SAVE_Q_REGISTERS
+
+	mov	x0, x1
+	bl	__tls_get_addr
+
+	mrs	x1, tpidr_el0
+	sub	x0, x0, x1
+
+	RESTORE_Q_REGISTERS
+
+	ldp	 x7,  x8, [sp, #16*1]
+	ldp	 x9, x10, [sp, #16*2]
+	ldp	x11, x12, [sp, #16*3]
+	ldp	x13, x14, [sp, #16*4]
+	ldp	x15, x16, [sp, #16*5]
+	ldp	x17, x18, [sp, #16*6]
+	ldp	 x5,  x6, [sp], #16*NSAVEXREGPAIRS
+	cfi_adjust_cfa_offset (-16*NSAVEXREGPAIRS)
+	b	1b
+	cfi_endproc
+	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+#undef NSAVEXREGPAIRS
+#endif
+
+	/* This function is a wrapper for a lazy resolver for TLS_DESC
+	   RELA relocations.
+	   When the actual resolver returns, it will have adjusted the
+	   TLS descriptor such that we can tail-call it for it to return
+	   the TP offset of the symbol.  */
+
+	.hidden _dl_tlsdesc_resolve_rela
+	.global	_dl_tlsdesc_resolve_rela
+	.type	_dl_tlsdesc_resolve_rela,%function
+	cfi_startproc
+	.align 2
+_dl_tlsdesc_resolve_rela:
+#define	NSAVEXREGPAIRS 9
+	stp	x29, x30, [sp, #-(32+16*NSAVEXREGPAIRS)]!
+	cfi_adjust_cfa_offset (32+16*NSAVEXREGPAIRS)
+	mov	x29, sp
+	stp	 x1,  x4, [sp, #32+16*0]
+	stp	 x5,  x6, [sp, #32+16*1]
+	stp	 x7,  x8, [sp, #32+16*2]
+	stp	 x9, x10, [sp, #32+16*3]
+	stp	x11, x12, [sp, #32+16*4]
+	stp	x13, x14, [sp, #32+16*5]
+	stp	x15, x16, [sp, #32+16*6]
+	stp	x17, x18, [sp, #32+16*7]
+	str	x0,       [sp, #32+16*8]
+
+	SAVE_Q_REGISTERS
+
+	ldr	x1, [x3, #8]
+	bl	_dl_tlsdesc_resolve_rela_fixup
+
+	RESTORE_Q_REGISTERS
+
+	ldr	x0, [sp, #32+16*8]
+	ldr	x1, [x0]
+	blr	x1
+
+	ldp	 x1,  x4, [sp, #32+16*0]
+	ldp	 x5,  x6, [sp, #32+16*1]
+	ldp	 x7,  x8, [sp, #32+16*2]
+	ldp	 x9, x10, [sp, #32+16*3]
+	ldp	x11, x12, [sp, #32+16*4]
+	ldp	x13, x14, [sp, #32+16*5]
+	ldp	x15, x16, [sp, #32+16*6]
+	ldp	x17, x18, [sp, #32+16*7]
+	ldp	x29, x30, [sp], #(32+16*NSAVEXREGPAIRS)
+	cfi_adjust_cfa_offset (-32+16*NSAVEXREGPAIRS)
+	ldp	x2, x3, [sp], #16
+	cfi_adjust_cfa_offset (-16)
+	RET
+#undef NSAVEXREGPAIRS
+	cfi_endproc
+	.size	_dl_tlsdesc_resolve_rela, .-_dl_tlsdesc_resolve_rela
+
+	/* This function is a placeholder for lazy resolving of TLS
+	relocations.  Once some thread starts resolving a TLS
+	relocation, it sets up the TLS descriptor to use this
+	resolver, such that other threads that would attempt to
+	resolve it concurrently may skip the call to the original lazy
+	resolver and go straight to a condition wait.
+
+	When the actual resolver returns, it will have adjusted the
+	TLS descriptor such that we can tail-call it for it to return
+	the TP offset of the symbol.  */
+
+	.hidden _dl_tlsdesc_resolve_hold
+	.global	_dl_tlsdesc_resolve_hold
+	.type	_dl_tlsdesc_resolve_hold,%function
+	cfi_startproc
+	.align 2
+_dl_tlsdesc_resolve_hold:
+#define	NSAVEXREGPAIRS 10
+1:
+	stp	x29, x30, [sp, #-(32+16*NSAVEXREGPAIRS)]!
+	cfi_adjust_cfa_offset (32+16*NSAVEXREGPAIRS)
+	mov	x29, sp
+	stp	 x1,  x2, [sp, #32+16*0]
+	stp	 x3,  x4, [sp, #32+16*1]
+	stp	 x5,  x6, [sp, #32+16*2]
+	stp	 x7,  x8, [sp, #32+16*3]
+	stp	 x9, x10, [sp, #32+16*4]
+	stp	x11, x12, [sp, #32+16*5]
+	stp	x13, x14, [sp, #32+16*6]
+	stp	x15, x16, [sp, #32+16*7]
+	stp	x17, x18, [sp, #32+16*8]
+	str	x0,       [sp, #32+16*9]
+
+	SAVE_Q_REGISTERS
+
+	adr	x1, 1b
+	bl	_dl_tlsdesc_resolve_hold_fixup
+
+	RESTORE_Q_REGISTERS
+
+	ldr	x0, [sp, #32+16*9]
+	ldr	x1, [x0]
+	blr	x1
+
+	ldp	 x1,  x2, [sp, #32+16*0]
+	ldp	 x3,  x4, [sp, #32+16*1]
+	ldp	 x5,  x6, [sp, #32+16*2]
+	ldp	 x7,  x8, [sp, #32+16*3]
+	ldp	 x9, x10, [sp, #32+16*4]
+	ldp	x11, x12, [sp, #32+16*5]
+	ldp	x13, x14, [sp, #32+16*6]
+	ldp	x15, x16, [sp, #32+16*7]
+	ldp	x17, x18, [sp, #32+16*8]
+	ldp	x29, x30, [sp], #(32+16*NSAVEXREGPAIRS)
+	cfi_adjust_cfa_offset (-32+16*NSAVEXREGPAIRS)
+	RET
+	cfi_endproc
+	.size	_dl_tlsdesc_resolve_hold, .-_dl_tlsdesc_resolve_hold
+#undef NSAVEXREGPAIRS
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-tlsdesc.h glibc/ports/sysdeps/aarch64/dl-tlsdesc.h
--- glibc.orig/ports/sysdeps/aarch64/dl-tlsdesc.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-tlsdesc.h	2012-09-24 13:04:47.000000000 +0100
@@ -0,0 +1,71 @@
+/* Thread-local storage descriptor handling in the ELF dynamic linker.
+   AArch64 version.
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _AARCH64_DL_TLSDESC_H
+#define _AARCH64_DL_TLSDESC_H 1
+
+/* Use this to access DT_TLSDESC_PLT and DT_TLSDESC_GOT.  */
+#ifndef ADDRIDX
+#define ADDRIDX(tag) (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM \
+		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRTAGIDX (tag))
+#endif
+
+/* Type used to represent a TLS descriptor in the GOT.  */
+struct tlsdesc
+{
+  ptrdiff_t (*entry) (struct tlsdesc *);
+  void *arg;
+};
+
+typedef struct dl_tls_index
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* Type used as the argument in a TLS descriptor for a symbol that
+   needs dynamic TLS offsets.  */
+struct tlsdesc_dynamic_arg
+{
+  tls_index tlsinfo;
+  size_t gen_count;
+};
+
+extern ptrdiff_t attribute_hidden
+_dl_tlsdesc_return (struct tlsdesc *);
+
+extern ptrdiff_t attribute_hidden
+_dl_tlsdesc_undefweak (struct tlsdesc *);
+
+extern ptrdiff_t attribute_hidden
+_dl_tlsdesc_resolve_rela (struct tlsdesc *);
+
+extern ptrdiff_t attribute_hidden
+_dl_tlsdesc_resolve_hold (struct tlsdesc *);
+
+# ifdef SHARED
+extern void *internal_function _dl_make_tlsdesc_dynamic (struct link_map *,
+							 size_t);
+
+extern ptrdiff_t attribute_hidden
+_dl_tlsdesc_dynamic (struct tlsdesc *);
+#endif
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/dl-trampoline.S glibc/ports/sysdeps/aarch64/dl-trampoline.S
--- glibc.orig/ports/sysdeps/aarch64/dl-trampoline.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/dl-trampoline.S	2012-09-24 13:05:02.000000000 +0100
@@ -0,0 +1,276 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libc-symbols.h>
+
+#include "dl-link.h"
+
+#define ip0 x16
+#define ip1 x17
+#define lr  x30
+
+	.text
+	.globl _dl_runtime_resolve
+	.type _dl_runtime_resolve, #function
+	cfi_startproc
+	.align 2
+_dl_runtime_resolve:
+	/* AArch64 we get called with:
+	   ip0		&PLTGOT[2]
+	   ip1		temp(dl resolver entry point)
+	   [sp, #8]	lr
+	   [sp, #0]	&PLTGOT[n]
+	 */
+
+	cfi_rel_offset (lr, 8)
+
+	/* Save arguments.  */
+	stp	x8, x9, [sp, #-80]!
+	cfi_adjust_cfa_offset (80)
+	cfi_rel_offset (x8, 0)
+	cfi_rel_offset (x9, 8)
+
+	stp	x6, x7, [sp,  #16]
+	cfi_rel_offset (x6, 16)
+	cfi_rel_offset (x7, 24)
+
+	stp	x4, x5, [sp,  #32]
+	cfi_rel_offset (x4, 32)
+	cfi_rel_offset (x5, 40)
+
+	stp	x2, x3, [sp,  #48]
+	cfi_rel_offset (x2, 48)
+	cfi_rel_offset (x3, 56)
+
+	stp	x0, x1, [sp,  #64]
+	cfi_rel_offset (x0, 64)
+	cfi_rel_offset (x1, 72)
+
+	/* Get pointer to linker struct.  */
+	ldr	x0, [ip0, #-8]
+
+	/* Prepare to call _dl_fixup().  */
+	ldr	x1, [sp, 80]	/* Recover &PLTGOT[n] */
+
+	sub     x1, x1, ip0
+	add     x1, x1, x1, lsl #1
+	lsl     x1, x1, #3
+	sub     x1, x1, #192
+	lsr     x1, x1, #3
+
+	/* Call fixup routine.  */
+	bl	_dl_fixup
+
+	/* Save the return.  */
+	mov	ip0, x0
+
+	/* Get arguments and return address back.  */
+	ldp	x0, x1, [sp, #64]
+	ldp	x2, x3, [sp, #48]
+	ldp	x4, x5, [sp, #32]
+	ldp	x6, x7, [sp, #16]
+	ldp	x8, x9, [sp], #80
+	cfi_adjust_cfa_offset (-80)
+
+	ldp	ip1, lr, [sp], #16
+	cfi_adjust_cfa_offset (-16)
+
+	/* Jump to the newly found address.  */
+	br	ip0
+
+	cfi_endproc
+	.size _dl_runtime_resolve, .-_dl_runtime_resolve
+#ifndef PROF
+	.globl _dl_runtime_profile
+	.type _dl_runtime_profile, #function
+	cfi_startproc
+	.align 2
+_dl_runtime_profile:
+	/* AArch64 we get called with:
+	   ip0		&PLTGOT[2]
+	   ip1		temp(dl resolver entry point)
+	   [sp, #8]	lr
+	   [sp, #0]	&PLTGOT[n]
+
+	   Stack frame layout:
+	   [sp,   #...] lr
+	   [sp,   #...] &PLTGOT[n]
+	   [sp,    #96] La_aarch64_regs
+	   [sp,    #48] La_aarch64_retval
+	   [sp,    #40] frame size return from pltenter
+	   [sp,    #32] dl_profile_call saved x1
+	   [sp,    #24] dl_profile_call saved x0
+	   [sp,    #16] t1
+	   [sp,     #0] x29, lr   <- x29
+	 */
+
+#define OFFSET_T1		16
+#define OFFSET_SAVED_CALL_X0	OFFSET_T1 + 8
+#define OFFSET_FS		OFFSET_SAVED_CALL_X0 + 16
+#define OFFSET_RV		OFFSET_FS + 8
+#define OFFSET_RG		OFFSET_RV + DL_SIZEOF_RV
+
+#define SF_SIZE			OFFSET_RG + DL_SIZEOF_RG
+
+#define OFFSET_PLTGOTN		SF_SIZE
+#define OFFSET_LR		OFFSET_PLTGOTN + 8
+
+	/* Save arguments.  */
+	sub	sp, sp, #SF_SIZE
+	cfi_adjust_cfa_offset (SF_SIZE)
+	stp	x29, x30, [SP, #0]
+	mov	x29, sp
+	cfi_def_cfa_register (x29)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (lr, 8)
+
+	stp	x0, x1, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*0]
+	cfi_rel_offset (x0, OFFSET_RG + DL_OFFSET_RG_X0 + 16*0 + 0)
+	cfi_rel_offset (x1, OFFSET_RG + DL_OFFSET_RG_X0 + 16*0 + 8)
+	stp	x2, x3, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*1]
+	cfi_rel_offset (x2, OFFSET_RG + DL_OFFSET_RG_X0 + 16*1 + 0)
+	cfi_rel_offset (x3, OFFSET_RG + DL_OFFSET_RG_X0 + 16*1 + 8)
+	stp	x4, x5, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*2]
+	cfi_rel_offset (x4, OFFSET_RG + DL_OFFSET_RG_X0 + 16*2 + 0)
+	cfi_rel_offset (x5, OFFSET_RG + DL_OFFSET_RG_X0 + 16*2 + 8)
+	stp	x6, x7, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*3]
+	cfi_rel_offset (x6, OFFSET_RG + DL_OFFSET_RG_X0 + 16*3 + 0)
+	cfi_rel_offset (x7, OFFSET_RG + DL_OFFSET_RG_X0 + 16*3 + 8)
+
+	stp	d0, d1, [X29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*0]
+	cfi_rel_offset (d0, OFFSET_RG + DL_OFFSET_RG_D0 + 16*0)
+	cfi_rel_offset (d1, OFFSET_RG + DL_OFFSET_RG_D0 + 16*0 + 8)
+	stp	d2, d3, [X29, #OFFSET_RG+ DL_OFFSET_RG_D0 + 16*1]
+	cfi_rel_offset (d2, OFFSET_RG + DL_OFFSET_RG_D0 + 16*1 + 0)
+	cfi_rel_offset (d3, OFFSET_RG + DL_OFFSET_RG_D0 + 16*1 + 8)
+	stp	d4, d5, [X29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*2]
+	cfi_rel_offset (d4, OFFSET_RG + DL_OFFSET_RG_D0 + 16*2 + 0)
+	cfi_rel_offset (d5, OFFSET_RG + DL_OFFSET_RG_D0 + 16*2 + 8)
+	stp	d6, d7, [X29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*3]
+	cfi_rel_offset (d6, OFFSET_RG + DL_OFFSET_RG_D0 + 16*3 + 0)
+	cfi_rel_offset (d7, OFFSET_RG + DL_OFFSET_RG_D0 + 16*3 + 8)
+
+	add     x0, x29, #SF_SIZE + 16
+	ldr	x1, [x29, #OFFSET_LR]
+	stp	x0, x1, [x29, #OFFSET_RG + DL_OFFSET_RG_SP]
+
+	/* Get pointer to linker struct.  */
+	ldr	x0, [ip0, #-8]
+
+	/* Prepare to call _dl_profile_fixup().  */
+	ldr	x1, [x29, OFFSET_PLTGOTN]	/* Recover &PLTGOT[n] */
+
+	sub     x1, x1, ip0
+	add     x1, x1, x1, lsl #1
+	lsl     x1, x1, #3
+	sub     x1, x1, #192
+	lsr     x1, x1, #3
+
+	stp	x0, x1, [x29, #OFFSET_SAVED_CALL_X0]
+
+	/* Set up extra args for _dl_profile_fixup */
+	ldr	x2, [x29, #OFFSET_LR]		/* load saved LR */
+	add	x3, x29, #OFFSET_RG		/* address of La_aarch64_reg */
+	add	x4, x29, #OFFSET_FS		/* address of framesize */
+	bl	_dl_profile_fixup
+
+	ldr	ip0, [x29, #OFFSET_FS]		/* framesize == 0 */
+	cmp	ip0, #0
+	bge	1f
+	cfi_remember_state
+
+	/* Save the return.  */
+	mov	ip0, x0
+
+	/* Get arguments and return address back.  */
+	ldp	x0, x1, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*0]
+	ldp	x2, x3, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*1]
+	ldp	x4, x5, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*2]
+	ldp	x6, x7, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*3]
+	ldp	d0, d1, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*0]
+	ldp	d2, d3, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*1]
+	ldp	d4, d5, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*2]
+	ldp	d6, d7, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*3]
+
+	cfi_def_cfa_register (sp)
+	ldp	x29, x30, [x29, #0]
+	cfi_restore(x29)
+	cfi_restore(x30)
+
+	add	sp, sp, SF_SIZE + 16
+	cfi_adjust_cfa_offset (- SF_SIZE - 16)
+
+	/* Jump to the newly found address.  */
+	br	ip0
+
+	cfi_restore_state
+1:
+	/* The new frame size is in ip0.  */
+
+	sub	x1, x29, ip0
+	and	sp, x1, #0xfffffffffffffff0
+
+	str	x0, [x29, #OFFSET_T1]
+
+	mov	x0, sp
+	add	x1, x29, #SF_SIZE + 16
+	mov	x2, ip0
+	bl	memcpy
+
+	ldr	ip0, [x29, #OFFSET_T1]
+
+	/* Call the function.  */
+	ldp	x0, x1, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*0]
+	ldp	x2, x3, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*1]
+	ldp	x4, x5, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*2]
+	ldp	x6, x7, [x29, #OFFSET_RG + DL_OFFSET_RG_X0 + 16*3]
+	ldp	d0, d1, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*0]
+	ldp	d2, d3, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*1]
+	ldp	d4, d5, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*2]
+	ldp	d6, d7, [x29, #OFFSET_RG + DL_OFFSET_RG_D0 + 16*3]
+	blr	ip0
+	stp	x0, x1, [x29, #OFFSET_RV + DL_OFFSET_RV_X0]
+	stp	d0, d1, [x29, #OFFSET_RV + DL_OFFSET_RV_D0 + 16*0]
+	stp	d2, d3, [x29, #OFFSET_RV + DL_OFFSET_RV_D0 + 16*1]
+
+	/* Setup call to pltexit  */
+	ldp	x0, x1, [x29, #OFFSET_SAVED_CALL_X0]
+	add	x2, x29, #OFFSET_RG
+	add	x3, x29, #OFFSET_RV
+	bl	_dl_call_pltexit
+
+	ldp	x0, x1, [x29, #OFFSET_RV + DL_OFFSET_RV_X0]
+	ldp	d0, d1, [x29, #OFFSET_RV + DL_OFFSET_RV_D0 + 16*0]
+	ldp	d2, d3, [x29, #OFFSET_RV + DL_OFFSET_RV_D0 + 16*1]
+	/* LR from within La_aarch64_reg */
+	ldr	lr, [x29, #OFFSET_RG + DL_OFFSET_RG_LR]
+	cfi_restore(lr)
+	mov	sp, x29
+	cfi_def_cfa_register (sp)
+	ldr	x29, [x29, #0]
+	cfi_restore(x29)
+	add	sp, sp, SF_SIZE + 16
+	cfi_adjust_cfa_offset (- SF_SIZE - 16)
+
+	br	lr
+
+	cfi_endproc
+	.size _dl_runtime_profile, .-_dl_runtime_profile
+#endif
+	.previous
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fclrexcpt.c glibc/ports/sysdeps/aarch64/fclrexcpt.c
--- glibc.orig/ports/sysdeps/aarch64/fclrexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fclrexcpt.c	2012-09-24 13:05:16.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 1997-2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+feclearexcept (int excepts)
+{
+  fpu_fpsr_t fpsr;
+
+  excepts &= FE_ALL_EXCEPT;
+
+  _FPU_GETFPSR (fpsr);
+  fpsr = (fpsr & ~FE_ALL_EXCEPT) | (fpsr & FE_ALL_EXCEPT & ~excepts);
+
+  _FPU_SETFPSR (fpsr);
+
+  return 0;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fedisblxcpt.c glibc/ports/sysdeps/aarch64/fedisblxcpt.c
--- glibc.orig/ports/sysdeps/aarch64/fedisblxcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fedisblxcpt.c	2012-09-24 13:05:24.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fedisableexcept (int excepts)
+{
+  fpu_fpcr_t fpcr;
+  int original_excepts;
+
+  _FPU_GETFPCR(fpcr);
+
+  original_excepts = (fpcr >> FE_EXCEPT_SHIFT) & FE_ALL_EXCEPT;
+
+  excepts &= FE_ALL_EXCEPT;
+
+  fpcr &= ~(excepts << FE_EXCEPT_SHIFT);
+
+  _FPU_SETFPCR(fpcr);
+  _ISB ();
+
+  return original_excepts;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/feenablxcpt.c glibc/ports/sysdeps/aarch64/feenablxcpt.c
--- glibc.orig/ports/sysdeps/aarch64/feenablxcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/feenablxcpt.c	2012-09-24 13:05:35.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+feenableexcept (int excepts)
+{
+  fpu_fpcr_t fpcr;
+  int original_excepts;
+
+  _FPU_GETFPCR(fpcr);
+
+  original_excepts = (fpcr >> FE_EXCEPT_SHIFT) & FE_ALL_EXCEPT;
+
+  excepts &= FE_ALL_EXCEPT;
+
+  fpcr |= (excepts << FE_EXCEPT_SHIFT);
+
+  _FPU_SETFPCR(fpcr);
+  _ISB ();
+
+  return original_excepts;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fegetenv.c glibc/ports/sysdeps/aarch64/fegetenv.c
--- glibc.orig/ports/sysdeps/aarch64/fegetenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fegetenv.c	2012-09-24 13:05:53.000000000 +0100
@@ -0,0 +1,33 @@
+/* Copyright (C) 1997-2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fegetenv (fenv_t *envp)
+{
+  fpu_fpcr_t fpcr;
+  fpu_fpsr_t fpsr;
+  _FPU_GETFPCR (fpcr);
+  _FPU_GETFPSR (fpsr);
+  envp->fpcr = fpcr;
+  envp->fpsr = fpsr;
+  return 0;
+}
+libm_hidden_def (fegetenv)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fegetexcept.c glibc/ports/sysdeps/aarch64/fegetexcept.c
--- glibc.orig/ports/sysdeps/aarch64/fegetexcept.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fegetexcept.c	2012-09-24 13:06:02.000000000 +0100
@@ -0,0 +1,28 @@
+/* Copyright (C) 2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fegetexcept (void)
+{
+  fpu_fpcr_t fpcr;
+  _FPU_GETFPCR (fpcr);
+  return (fpcr >> FE_EXCEPT_SHIFT) & FE_ALL_EXCEPT;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fegetround.c glibc/ports/sysdeps/aarch64/fegetround.c
--- glibc.orig/ports/sysdeps/aarch64/fegetround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fegetround.c	2012-09-24 13:06:11.000000000 +0100
@@ -0,0 +1,28 @@
+/* Copyright (C) 1997, 1998, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fegetround (void)
+{
+  fpu_fpcr_t fpcr;
+  _FPU_GETFPCR (fpcr);
+  return fpcr & FE_TOWARDZERO;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/feholdexcpt.c glibc/ports/sysdeps/aarch64/feholdexcpt.c
--- glibc.orig/ports/sysdeps/aarch64/feholdexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/feholdexcpt.c	2012-09-24 15:07:31.000000000 +0100
@@ -0,0 +1,48 @@
+/* Copyright (C) 1997-1999, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+feholdexcept (fenv_t *envp)
+{
+  fpu_fpsr_t fpsr;
+  fpu_fpcr_t fpcr;
+
+  _FPU_GETFPCR (fpcr);
+  envp->fpcr = fpcr;
+
+  _FPU_GETFPSR (fpsr);
+  envp->fpsr = fpsr;
+
+  /* Now set all exceptions to non-stop.  */
+  fpcr &= ~(FE_ALL_EXCEPT << FE_EXCEPT_SHIFT);
+
+  /* And clear all exception flags.  */
+  fpsr &= ~FE_ALL_EXCEPT;
+
+  _FPU_SETFPSR(fpsr);
+
+  _FPU_SETFPCR(fpcr);
+  _ISB ();
+
+  return 0;
+}
+
+libm_hidden_def (feholdexcept)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fesetenv.c glibc/ports/sysdeps/aarch64/fesetenv.c
--- glibc.orig/ports/sysdeps/aarch64/fesetenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fesetenv.c	2012-09-24 13:06:37.000000000 +0100
@@ -0,0 +1,61 @@
+/* Copyright (C) 1997-2002, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fesetenv (const fenv_t *envp)
+{
+  fpu_fpcr_t fpcr;
+  fpu_fpsr_t fpsr;
+
+  _FPU_GETFPCR (fpcr);
+  _FPU_GETFPSR (fpsr);
+
+  fpcr &= _FPU_FPCR_RESERVED;
+  fpsr &= _FPU_FPSR_RESERVED;
+
+  if (envp == FE_DFL_ENV)
+    {
+      fpcr |= _FPU_FPCR_DEFAULT;
+      fpsr |= _FPU_FPSR_DEFAULT;
+    }
+  else if (envp == FE_NOMASK_ENV)
+    {
+      fpcr |= _FPU_FPCR_IEEE;
+      fpsr |= _FPU_FPSR_IEEE;
+    }
+  else
+    {
+      fpcr |= envp->fpcr & ~_FPU_FPCR_RESERVED;
+      fpsr |= envp->fpsr & ~_FPU_FPSR_RESERVED;
+    }
+
+  _FPU_SETFPSR (fpsr);
+
+  _FPU_SETFPCR (fpcr);
+
+  /* The instruction stream must be syncrnonized after any write to
+     FPCR */
+  _ISB ();
+
+  return 0;
+}
+
+libm_hidden_def (fesetenv)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fesetround.c glibc/ports/sysdeps/aarch64/fesetround.c
--- glibc.orig/ports/sysdeps/aarch64/fesetround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fesetround.c	2012-09-24 13:06:46.000000000 +0100
@@ -0,0 +1,47 @@
+/* Copyright (C) 1997, 1998, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fesetround (int round)
+{
+  fpu_fpcr_t fpcr;
+
+  switch (round)
+    {
+    case FE_TONEAREST:
+    case FE_UPWARD:
+    case FE_DOWNWARD:
+    case FE_TOWARDZERO:
+      _FPU_GETFPCR (fpcr);
+      fpcr = (fpcr & ~FE_TOWARDZERO) | round;
+
+      _FPU_SETFPCR (fpcr);
+      _ISB ();
+      return 0;
+
+    default:
+      return 1;
+    }
+
+  return 1;
+}
+
+libm_hidden_def (fesetround)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/feupdateenv.c glibc/ports/sysdeps/aarch64/feupdateenv.c
--- glibc.orig/ports/sysdeps/aarch64/feupdateenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/feupdateenv.c	2012-09-24 13:07:01.000000000 +0100
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+feupdateenv (const fenv_t *envp)
+{
+  fpu_fpsr_t fpsr;
+
+  /* Get the current exception state.  */
+  _FPU_GETFPSR (fpsr);
+
+  /* Install new environment.  */
+  fesetenv (envp);
+
+  /* Raise the saved exceptions.  */
+  feraiseexcept (fpsr & FE_ALL_EXCEPT);
+
+  return 0;
+}
+libm_hidden_def (feupdateenv)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fgetexcptflg.c glibc/ports/sysdeps/aarch64/fgetexcptflg.c
--- glibc.orig/ports/sysdeps/aarch64/fgetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fgetexcptflg.c	2012-09-24 13:07:10.000000000 +0100
@@ -0,0 +1,33 @@
+/* Copyright (C) 2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  fpu_fpsr_t fpsr;
+
+  /* Get the current exceptions.  */
+  _FPU_GETFPSR (fpsr);
+
+  *flagp = fpsr & excepts & FE_ALL_EXCEPT;
+
+  return 0;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_ceil.c glibc/ports/sysdeps/aarch64/fpu/s_ceil.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_ceil.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_ceil.c	2012-09-24 13:08:06.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define	FUNC ceil
+#define INSN "frintp"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_ceilf.c glibc/ports/sysdeps/aarch64/fpu/s_ceilf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_ceilf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_ceilf.c	2012-09-24 13:08:17.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define	FUNC ceilf
+#define INSN "frintp"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_floor.c glibc/ports/sysdeps/aarch64/fpu/s_floor.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_floor.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_floor.c	2012-09-24 13:08:20.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC floor
+#define INSN "frintm"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_floorf.c glibc/ports/sysdeps/aarch64/fpu/s_floorf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_floorf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_floorf.c	2012-09-24 13:08:23.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC floorf
+#define INSN "frintm"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fma.c glibc/ports/sysdeps/aarch64/fpu/s_fma.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fma.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fma.c	2012-09-24 13:08:33.000000000 +0100
@@ -0,0 +1,54 @@
+/* Copyright (C) 1996, 1997, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+
+#ifndef FUNC
+#define FUNC fma
+#endif
+
+#ifndef TYPE
+#define TYPE double
+#define REGS "d"
+#else
+#ifndef REGS
+#error REGS not defined
+#endif
+#endif
+
+#define __CONCATX(a,b) __CONCAT(a,b)
+
+TYPE
+__CONCATX(__,FUNC) (x, y, z)
+     TYPE x;
+     TYPE y;
+     TYPE z;
+{
+  TYPE result;
+  asm ( "fmadd" "\t%" REGS "0, %" REGS "1, %" REGS "2, %" REGS "3"
+        : "=w" (result) : "w" (x), "w" (y), "w" (z) );
+  return result;
+}
+
+#define weak_aliasx(a,b) weak_alias(a,b)
+weak_aliasx (__CONCATX(__,FUNC), FUNC)
+#define strong_aliasx(a,b) strong_alias(a,b)
+#ifdef NO_LONG_DOUBLE
+strong_aliasx (__CONCATX(__,FUNC),  __CONCATX(__,__CONCATX(FUNC,l)))
+weak_aliasx (__CONCATX(__,FUNC), __CONCATX(FUNC,l))
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fmaf.c glibc/ports/sysdeps/aarch64/fpu/s_fmaf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fmaf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fmaf.c	2012-09-24 13:08:39.000000000 +0100
@@ -0,0 +1,22 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC fmaf
+#define TYPE float
+#define REGS "s"
+#include <s_fma.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fmax.c glibc/ports/sysdeps/aarch64/fpu/s_fmax.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fmax.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fmax.c	2012-09-24 13:08:43.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC fmax
+#define INSN "fmaxnm"
+#include <s_fmin.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fmaxf.c glibc/ports/sysdeps/aarch64/fpu/s_fmaxf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fmaxf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fmaxf.c	2012-09-24 13:08:48.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC fmaxf
+#define INSN "fmaxnm"
+#define TYPE float
+#define REGS "s"
+#include <s_fmin.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fmin.c glibc/ports/sysdeps/aarch64/fpu/s_fmin.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fmin.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fmin.c	2012-09-24 13:08:56.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (C) 1996, 1997, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+
+#ifndef FUNC
+#define FUNC fmin
+#endif
+
+#ifndef INSN
+#define INSN "fminnm"
+#endif
+
+#ifndef TYPE
+#define TYPE double
+#define REGS "d"
+#else
+#ifndef REGS
+#error REGS not defined
+#endif
+#endif
+
+#define __CONCATX(a,b) __CONCAT(a,b)
+
+TYPE
+__CONCATX(__,FUNC) (x, y)
+     TYPE x;
+     TYPE y;
+{
+  TYPE result;
+  asm ( INSN "\t%" REGS "0, %" REGS "1, %" REGS "2"
+        : "=w" (result) : "w" (x), "w" (y) );
+  return result;
+}
+
+#define weak_aliasx(a,b) weak_alias(a,b)
+weak_aliasx (__CONCATX(__,FUNC), FUNC)
+#define strong_aliasx(a,b) strong_alias(a,b)
+#ifdef NO_LONG_DOUBLE
+strong_aliasx (__CONCATX(__,FUNC),  __CONCATX(__,__CONCATX(FUNC,l)))
+weak_aliasx (__CONCATX(__,FUNC), __CONCATX(FUNC,l))
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_fminf.c glibc/ports/sysdeps/aarch64/fpu/s_fminf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_fminf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_fminf.c	2012-09-24 13:09:02.000000000 +0100
@@ -0,0 +1,22 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC fminf
+#define TYPE float
+#define REGS "s"
+#include <s_fmin.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_frint.x glibc/ports/sysdeps/aarch64/fpu/s_frint.x
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_frint.x	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_frint.x	2012-09-24 13:09:09.000000000 +0100
@@ -0,0 +1,56 @@
+/* Copyright (C) 1996, 1997, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+
+#ifndef FUNC
+#error FUNC not defined
+#endif
+
+#ifndef TYPE
+#define TYPE double
+#define REGS "d"
+#else
+#ifndef REGS
+#error REGS not defined
+#endif
+#endif
+
+#ifndef INSN
+#error INSN not defined
+#endif
+
+#define __CONCATX(a,b) __CONCAT(a,b)
+
+TYPE
+__CONCATX(__,FUNC) (x)
+     TYPE x;
+{
+  TYPE result;
+  asm ( INSN "\t%" REGS "0, %" REGS "1" :
+	"=w" (result) : "w" (x) );
+  return result;
+}
+
+#define weak_aliasx(a,b) weak_alias(a,b)
+weak_aliasx (__CONCATX(__,FUNC), FUNC)
+#define strong_aliasx(a,b) strong_alias(a,b)
+#ifdef NO_LONG_DOUBLE
+strong_aliasx (__CONCATX(__,FUNC),  __CONCATX(__,__CONCATX(FUNC,l)))
+weak_aliasx (__CONCATX(__,FUNC), __CONCATX(FUNC,l))
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_frintf.x glibc/ports/sysdeps/aarch64/fpu/s_frintf.x
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_frintf.x	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_frintf.x	2012-09-24 13:09:15.000000000 +0100
@@ -0,0 +1,24 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef FUNC
+#error FUNC not defined
+#endif
+#define TYPE float
+#define REGS "s"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_llrint.c glibc/ports/sysdeps/aarch64/fpu/s_llrint.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_llrint.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_llrint.c	2012-09-24 13:09:19.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC llrint
+#define OTYPE long long int
+#include <s_lrint.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_llrintf.c glibc/ports/sysdeps/aarch64/fpu/s_llrintf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_llrintf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_llrintf.c	2012-09-24 13:09:23.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC llrintf
+#define ITYPE float
+#define IREGS "s"
+#define OTYPE long long int
+#include <s_lrint.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_llround.c glibc/ports/sysdeps/aarch64/fpu/s_llround.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_llround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_llround.c	2012-09-24 13:09:26.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC llround
+#define OTYPE long long int
+#include <s_lround.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_llroundf.c glibc/ports/sysdeps/aarch64/fpu/s_llroundf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_llroundf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_llroundf.c	2012-09-24 13:09:29.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC llroundf
+#define ITYPE float
+#define IREGS "s"
+#define OTYPE long long int
+#include <s_lround.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_lrint.c glibc/ports/sysdeps/aarch64/fpu/s_lrint.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_lrint.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_lrint.c	2012-09-24 13:09:37.000000000 +0100
@@ -0,0 +1,60 @@
+/* Copyright (C) 1996, 1997, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+
+#ifndef FUNC
+#define FUNC lrint
+#endif
+
+#ifndef ITYPE
+#define ITYPE double
+#define IREGS "d"
+#else
+#ifndef IREGS
+#error IREGS not defined
+#endif
+#endif
+
+#ifndef OTYPE
+#define OTYPE long int
+#endif
+
+#define OREGS "x"
+
+#define __CONCATX(a,b) __CONCAT(a,b)
+
+OTYPE
+__CONCATX(__,FUNC) (x)
+     ITYPE x;
+{
+  OTYPE result;
+  ITYPE temp;
+  asm ( "frintx" "\t%" IREGS "1, %" IREGS "2\n\t"
+        "fcvtzs" "\t%" OREGS "0, %" IREGS "1"
+        : "=r" (result), "=w" (temp) : "w" (x) );
+  return result;
+}
+
+#define weak_aliasx(a,b) weak_alias(a,b)
+weak_aliasx (__CONCATX(__,FUNC), FUNC)
+#define strong_aliasx(a,b) strong_alias(a,b)
+#ifdef NO_LONG_DOUBLE
+strong_aliasx (__CONCATX(__,FUNC),  __CONCATX(__,__CONCATX(FUNC,l)))
+weak_aliasx (__CONCATX(__,FUNC), __CONCATX(FUNC,l))
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_lrintf.c glibc/ports/sysdeps/aarch64/fpu/s_lrintf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_lrintf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_lrintf.c	2012-09-24 13:09:43.000000000 +0100
@@ -0,0 +1,22 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC lrintf
+#define ITYPE float
+#define IREGS "s"
+#include <s_lrint.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_lround.c glibc/ports/sysdeps/aarch64/fpu/s_lround.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_lround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_lround.c	2012-09-24 13:09:50.000000000 +0100
@@ -0,0 +1,58 @@
+/* Copyright (C) 1996, 1997, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+
+#ifndef FUNC
+#define FUNC lround
+#endif
+
+#ifndef ITYPE
+#define ITYPE double
+#define IREGS "d"
+#else
+#ifndef IREGS
+#error IREGS not defined
+#endif
+#endif
+
+#ifndef OTYPE
+#define OTYPE long int
+#endif
+
+#define OREGS "x"
+
+#define __CONCATX(a,b) __CONCAT(a,b)
+
+OTYPE
+__CONCATX(__,FUNC) (x)
+     ITYPE x;
+{
+  OTYPE result;
+  asm ( "fcvtas" "\t%" OREGS "0, %" IREGS "1"
+        : "=r" (result) : "w" (x) );
+  return result;
+}
+
+#define weak_aliasx(a,b) weak_alias(a,b)
+weak_aliasx (__CONCATX(__,FUNC), FUNC)
+#define strong_aliasx(a,b) strong_alias(a,b)
+#ifdef NO_LONG_DOUBLE
+strong_aliasx (__CONCATX(__,FUNC),  __CONCATX(__,__CONCATX(FUNC,l)))
+weak_aliasx (__CONCATX(__,FUNC), __CONCATX(FUNC,l))
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_lroundf.c glibc/ports/sysdeps/aarch64/fpu/s_lroundf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_lroundf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_lroundf.c	2012-09-24 13:09:56.000000000 +0100
@@ -0,0 +1,22 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC lroundf
+#define ITYPE float
+#define IREGS "s"
+#include <s_lround.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_nearbyint.c glibc/ports/sysdeps/aarch64/fpu/s_nearbyint.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_nearbyint.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_nearbyint.c	2012-09-24 13:09:59.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define	FUNC nearbyint
+#define INSN "frinti"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_nearbyintf.c glibc/ports/sysdeps/aarch64/fpu/s_nearbyintf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_nearbyintf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_nearbyintf.c	2012-09-24 13:10:01.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC nearbyintf
+#define INSN "frinti"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_rint.c glibc/ports/sysdeps/aarch64/fpu/s_rint.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_rint.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_rint.c	2012-09-24 13:10:04.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC	rint
+#define INSN "frintx"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_rintf.c glibc/ports/sysdeps/aarch64/fpu/s_rintf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_rintf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_rintf.c	2012-09-24 13:10:07.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC rintf
+#define INSN "frintx"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_round.c glibc/ports/sysdeps/aarch64/fpu/s_round.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_round.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_round.c	2012-09-24 13:10:11.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC round
+#define INSN "frinta"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_roundf.c glibc/ports/sysdeps/aarch64/fpu/s_roundf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_roundf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_roundf.c	2012-09-24 13:10:14.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC roundf
+#define INSN "frinta"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_trunc.c glibc/ports/sysdeps/aarch64/fpu/s_trunc.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_trunc.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_trunc.c	2012-09-24 13:10:17.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC trunc
+#define INSN "frintz"
+#include <s_frint.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu/s_truncf.c glibc/ports/sysdeps/aarch64/fpu/s_truncf.c
--- glibc.orig/ports/sysdeps/aarch64/fpu/s_truncf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu/s_truncf.c	2012-09-24 13:10:20.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define FUNC truncf
+#define INSN "frintz"
+#include <s_frintf.x>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fpu-control.h glibc/ports/sysdeps/aarch64/fpu-control.h
--- glibc.orig/ports/sysdeps/aarch64/fpu-control.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fpu-control.h	2012-09-24 13:10:39.000000000 +0100
@@ -0,0 +1,78 @@
+/* Copyright (C) 1996-1998, 2000, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* Macros for accessing the FPCR and FPSR.  */
+
+#define _FPU_GETFPCR(fpcr) \
+  __asm__ __volatile__ ("mrs	%0, fpcr" : "=r" (fpcr))
+
+#define _FPU_SETFPCR(fpcr) \
+  __asm__ __volatile__ ("msr	fpcr, %0" : : "r" (fpcr))
+
+#define _FPU_GETFPSR(fpsr) \
+  __asm__ __volatile__ ("mrs	%0, fpsr" : "=r" (fpsr))
+
+#define _FPU_SETFPSR(fpsr) \
+  __asm__ __volatile__ ("msr	fpsr, %0" : : "r" (fpsr))
+
+#define _ISB() \
+  __asm__ __volatile__ ("isb")
+
+/* Reserved bits should be preserved when modifying register
+   contents. These two masks indicate which bits in each of FPCR and
+   FPSR should not be changed.  */
+
+#define _FPU_FPCR_RESERVED   0xfe0fe0ff
+#define _FPU_FPSR_RESERVED   0x0fffffe0
+
+#define _FPU_FPCR_DEFAULT    0x00000000
+#define _FPU_FPSR_DEFAULT    0x00000000
+
+/* Layout of FPCR and FPSR:
+
+   |       |       |       |       |       |       |       |
+   0 0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 1 1 1 0 0 0 0 0 1 1 1 0 0 0 0 0
+   s s s s s                                       s     s s s s s
+             c c c c c c c               c c c c c
+   N Z C V Q A D F R R S S S L L L I U U I U O D I I U U I U O D I
+           C H N Z M M T T B E E E D N N X F F Z O D N N X F F Z O
+             P     O O R R Z N N N E K K E E E E E C K K C C C C C
+                   D D I I P
+                   E E D D
+                       E E
+ */
+#define _FPU_FPCR_MASK_IXE 0x1000
+#define _FPU_FPCR_MASK_UFE 0x0800
+#define _FPU_FPCR_MASK_OFE 0x0400
+#define _FPU_FPCR_MASK_DZE 0x0200
+#define _FPU_FPCR_MASK_IOE 0x0100
+
+#define _FPU_FPCR_IEEE                       \
+  (_FPU_FPCR_DEFAULT  | _FPU_FPCR_MASK_IXE | \
+   _FPU_FPCR_MASK_UFE | _FPU_FPCR_MASK_OFE | \
+   _FPU_FPCR_MASK_DZE | _FPU_FPCR_MASK_IOE)
+
+#define _FPU_FPSR_IEEE 0
+
+typedef unsigned int fpu_fpcr_t;
+typedef unsigned int fpu_fpsr_t;
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fraiseexcpt.c glibc/ports/sysdeps/aarch64/fraiseexcpt.c
--- glibc.orig/ports/sysdeps/aarch64/fraiseexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fraiseexcpt.c	2012-09-24 13:10:52.000000000 +0100
@@ -0,0 +1,92 @@
+/* Copyright (C) 1997-2002, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+#include <float.h>
+
+int
+feraiseexcept (int excepts)
+{
+  int fpsr;
+  const float fp_zero = 0.0;
+  const float fp_one = 1.0;
+  const float fp_max = FLT_MAX;
+  const float fp_min = FLT_MIN;
+  const float fp_1e32 = 1.0e32f;
+  const float fp_two = 2.0;
+  const float fp_three = 3.0;
+
+  /* Raise exceptions represented by EXCEPTS.  But we must raise only
+     one signal at a time.  It is important that if the OVERFLOW or
+     UNDERFLOW exception and the inexact exception are given at the
+     same time, the OVERFLOW or UNDERFLOW exception precedes the
+     INEXACT exception.
+
+     After each exception we read from the FPSR, to force the
+     exception to be raised immediately.  */
+
+  if (FE_INVALID & excepts)
+    __asm__ __volatile__ (
+			  "ldr	s0, %1\n\t"
+			  "fdiv	s0, s0, s0\n\t"
+			  "mrs	%0, fpsr" : "=r" (fpsr)
+			  : "m" (fp_zero)
+			  : "d0");
+
+  if (FE_DIVBYZERO & excepts)
+    __asm__ __volatile__ (
+			  "ldr	s0, %1\n\t"
+			  "ldr	s1, %2\n\t"
+			  "fdiv	s0, s0, s1\n\t"
+			  "mrs	%0, fpsr" : "=r" (fpsr)
+			  : "m" (fp_one), "m" (fp_zero)
+			  : "d0", "d1");
+
+  if (FE_OVERFLOW & excepts)
+    /* There's no way to raise overflow without also raising inexact.  */
+    __asm__ __volatile__ (
+			  "ldr	s0, %1\n\t"
+			  "ldr	s1, %2\n\t"
+			  "fadd s0, s0, s1\n\t"
+			  "mrs	%0, fpsr" : "=r" (fpsr)
+			  : "m" (fp_max), "m" (fp_1e32)
+			  : "d0", "d1");
+
+  if (FE_UNDERFLOW & excepts)
+    __asm__ __volatile__ (
+			  "ldr	s0, %1\n\t"
+			  "ldr	s1, %2\n\t"
+			  "fdiv s0, s0, s1\n\t"
+			  "mrs	%0, fpsr" : "=r" (fpsr)
+			  : "m" (fp_min), "m" (fp_three)
+			  : "d0", "d1");
+
+  if (FE_INEXACT & excepts)
+    __asm__ __volatile__ (
+			  "ldr	s0, %1\n\t"
+			  "ldr	s1, %2\n\t"
+			  "fdiv s0, s0, s1\n\t"
+			  "mrs	%0, fpsr" : "=r" (fpsr)
+			  : "m" (fp_two), "m" (fp_three)
+			  : "d0", "d1");
+
+  return 0;
+}
+
+libm_hidden_def (feraiseexcept)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/fsetexcptflg.c glibc/ports/sysdeps/aarch64/fsetexcptflg.c
--- glibc.orig/ports/sysdeps/aarch64/fsetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/fsetexcptflg.c	2012-09-24 13:11:07.000000000 +0100
@@ -0,0 +1,39 @@
+/* Copyright (C) 1997-2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <math.h>
+#include <fpu-control.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fpu_fpsr_t fpsr;
+
+  /* Get the current environment.  */
+  _FPU_GETFPSR (fpsr);
+
+  /* Set the desired exception mask.  */
+  fpsr &= ~(excepts & FE_ALL_EXCEPT);
+  fpsr |= (*flagp & excepts & FE_ALL_EXCEPT);
+
+  /* Save state back to the FPU.  */
+  _FPU_SETFPSR (fpsr);
+
+  return 0;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/ftestexcept.c glibc/ports/sysdeps/aarch64/ftestexcept.c
--- glibc.orig/ports/sysdeps/aarch64/ftestexcept.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/ftestexcept.c	2012-09-24 13:11:16.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 1997, 1998, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <fpu-control.h>
+
+int
+fetestexcept (int excepts)
+{
+  fpu_fpsr_t fpsr;
+
+  /* Get current exceptions.  */
+  _FPU_GETFPSR(fpsr);
+
+  return fpsr & excepts & FE_ALL_EXCEPT;
+}
+libm_hidden_def (fetestexcept)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/jmpbuf-offsets.h glibc/ports/sysdeps/aarch64/jmpbuf-offsets.h
--- glibc.orig/ports/sysdeps/aarch64/jmpbuf-offsets.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/jmpbuf-offsets.h	2012-09-24 13:11:26.000000000 +0100
@@ -0,0 +1,44 @@
+/* Copyright (C) 2006, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define JB_X19            0
+#define JB_X20            1
+#define JB_X21            2
+#define JB_X22            3
+#define JB_X23            4
+#define JB_X24            5
+#define JB_X25            6
+#define JB_X26            7
+#define JB_X27            8
+#define JB_X28            9
+#define JB_X29           10
+#define JB_LR            11
+#define JB_SP		 13
+
+#define JB_D8		 14
+#define JB_D9		 15
+#define JB_D10		 16
+#define JB_D11		 17
+#define JB_D12		 18
+#define JB_D13		 19
+#define JB_D14		 20
+#define JB_D15		 21
+
+/* Helper for generic ____longjmp_chk(). */
+#define JB_FRAME_ADDRESS(buf) \
+  ((void *) (unsigned long) (buf[JB_SP]))
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/jmpbuf-unwind.h glibc/ports/sysdeps/aarch64/jmpbuf-unwind.h
--- glibc.orig/ports/sysdeps/aarch64/jmpbuf-unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/jmpbuf-unwind.h	2012-09-24 13:11:36.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (C) 2005, 2006, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <jmpbuf-offsets.h>
+#include <stdint.h>
+#include <unwind.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
+  ((void *) (address) < (void *) demangle (jmpbuf[JB_SP]))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(jmpbuf, context, adj) \
+  _JMPBUF_UNWINDS_ADJ (jmpbuf, (void *) _Unwind_GetCFA (context), adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf jmpbuf)
+{
+  uintptr_t sp = jmpbuf[JB_SP];
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/ldsodefs.h glibc/ports/sysdeps/aarch64/ldsodefs.h
--- glibc.orig/ports/sysdeps/aarch64/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/ldsodefs.h	2012-09-24 13:11:46.000000000 +0100
@@ -0,0 +1,48 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _AARCH64_LDSODEFS_H
+#define _AARCH64_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_aarch64_regs;
+struct La_aarch64_retval;
+
+#define ARCH_PLTENTER_MEMBERS \
+    ElfW(Addr) (*aarch64_gnu_pltenter) (ElfW(Sym) *,                    \
+					unsigned int,			\
+                                        uintptr_t *,			\
+					uintptr_t *,                    \
+					struct La_aarch64_regs *,	\
+					unsigned int *,			\
+					const char *,			\
+					long int *)
+
+#define ARCH_PLTEXIT_MEMBERS \
+    ElfW(Addr) (*aarch64_gnu_pltexit) (ElfW(Sym) *,                     \
+				       unsigned int,                    \
+				       uintptr_t *,			\
+				       uintptr_t *,			\
+				       struct La_aarch64_regs *,	\
+				       struct La_aarch64_retval *,	\
+				       const char *)
+
+#include_next <ldsodefs.h>
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/libc-tls.c glibc/ports/sysdeps/aarch64/libc-tls.c
--- glibc.orig/ports/sysdeps/aarch64/libc-tls.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/libc-tls.c	2012-09-24 13:11:55.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+/* On AArch64, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/libm-test-ulps glibc/ports/sysdeps/aarch64/libm-test-ulps
--- glibc.orig/ports/sysdeps/aarch64/libm-test-ulps	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/libm-test-ulps	2012-09-28 12:55:43.000000000 +0100
@@ -0,0 +1,3726 @@
+# Begin of automatic generation
+
+# acos_downward
+Test "acos_downward (-0) == pi/2":
+float: 1
+ifloat: 1
+Test "acos_downward (-0.5) == M_PI_6l*4.0":
+double: 1
+idouble: 1
+Test "acos_downward (-1) == pi":
+float: 1
+ifloat: 1
+Test "acos_downward (0) == pi/2":
+float: 1
+ifloat: 1
+Test "acos_downward (0.5) == M_PI_6l*2.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# acos_towardzero
+Test "acos_towardzero (-0) == pi/2":
+float: 1
+ifloat: 1
+Test "acos_towardzero (-0.5) == M_PI_6l*4.0":
+double: 1
+idouble: 1
+Test "acos_towardzero (-1) == pi":
+float: 1
+ifloat: 1
+Test "acos_towardzero (0) == pi/2":
+float: 1
+ifloat: 1
+Test "acos_towardzero (0.5) == M_PI_6l*2.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# acos_upward
+Test "acos_upward (-0) == pi/2":
+ildouble: 1
+ldouble: 1
+Test "acos_upward (-1) == pi":
+ildouble: 1
+ldouble: 1
+Test "acos_upward (0) == pi/2":
+ildouble: 1
+ldouble: 1
+
+# asin_downward
+Test "asin_downward (-0.5) == -pi/6":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "asin_downward (-1.0) == -pi/2":
+ildouble: 1
+ldouble: 1
+Test "asin_downward (0.5) == pi/6":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "asin_downward (1.0) == pi/2":
+float: 1
+ifloat: 1
+
+# asin_towardzero
+Test "asin_towardzero (-0.5) == -pi/6":
+double: 1
+idouble: 1
+Test "asin_towardzero (-1.0) == -pi/2":
+float: 1
+ifloat: 1
+Test "asin_towardzero (0.5) == pi/6":
+double: 1
+idouble: 1
+Test "asin_towardzero (1.0) == pi/2":
+float: 1
+ifloat: 1
+
+# asin_upward
+Test "asin_upward (-1.0) == -pi/2":
+float: 1
+ifloat: 1
+Test "asin_upward (1.0) == pi/2":
+ildouble: 1
+ldouble: 1
+
+# atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994379639112":
+ildouble: 1
+ldouble: 1
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacos
+Test "Imaginary part of: cacos (+0 + 0.5 i) == pi/2 - 0.4812118250596034474977589134243684231352 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (+0 + 1.0 i) == pi/2 - 0.8813735870195430252326093249797923090282 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cacos (+0 + 1.5 i) == pi/2 - 1.194763217287109304111930828519090523536 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cacos (+0 - 0.5 i) == pi/2 + 0.4812118250596034474977589134243684231352 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (+0 - 1.0 i) == pi/2 + 0.8813735870195430252326093249797923090282 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (+0 - 1.5 i) == pi/2 + 1.194763217287109304111930828519090523536 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (-0 + 0.5 i) == pi/2 - 0.4812118250596034474977589134243684231352 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (-0 + 1.0 i) == pi/2 - 0.8813735870195430252326093249797923090282 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cacos (-0 + 1.5 i) == pi/2 - 1.194763217287109304111930828519090523536 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cacos (-0 - 0.5 i) == pi/2 + 0.4812118250596034474977589134243684231352 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (-0 - 1.0 i) == pi/2 + 0.8813735870195430252326093249797923090282 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (-0 - 1.5 i) == pi/2 + 1.194763217287109304111930828519090523536 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (-1.5 + +0 i) == pi - 0.9624236501192068949955178268487368462704 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacos (0.5 + +0 i) == 1.047197551196597746154214461093167628066 - 0 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacos (0.5 - 0 i) == 1.047197551196597746154214461093167628066 + +0 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (0.75 + 1.25 i) == 1.11752014915610270578240049553777969 - 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacos (1.5 + +0 i) == +0 - 0.9624236501192068949955178268487368462704 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cacosh
+Test "Real part of: cacosh (+0 + 0.5 i) == 0.4812118250596034474977589134243684231352 + pi/2 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (+0 + 1.0 i) == 0.8813735870195430252326093249797923090282 + pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (+0 + 1.5 i) == 1.194763217287109304111930828519090523536 + pi/2 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (+0 - 0.5 i) == 0.4812118250596034474977589134243684231352 - pi/2 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (+0 - 1.0 i) == 0.8813735870195430252326093249797923090282 - pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (+0 - 1.5 i) == 1.194763217287109304111930828519090523536 - pi/2 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 + 0.5 i) == 0.4812118250596034474977589134243684231352 + pi/2 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 + 1.0 i) == 0.8813735870195430252326093249797923090282 + pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 + 1.5 i) == 1.194763217287109304111930828519090523536 + pi/2 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 - 0.5 i) == 0.4812118250596034474977589134243684231352 - pi/2 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 - 1.0 i) == 0.8813735870195430252326093249797923090282 - pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-0 - 1.5 i) == 1.194763217287109304111930828519090523536 - pi/2 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacosh (-0.5 + +0 i) == +0 + 2.094395102393195492308428922186335256131 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: cacosh (-0.5 - 0 i) == +0 - 2.094395102393195492308428922186335256131 i":
+double: 1
+idouble: 1
+Test "Real part of: cacosh (-1.5 + +0 i) == 0.9624236501192068949955178268487368462704 + pi i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (-1.5 - 0 i) == 0.9624236501192068949955178268487368462704 - pi i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (1.5 + +0 i) == 0.9624236501192068949955178268487368462704 + +0 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cacosh (1.5 - 0 i) == 0.9624236501192068949955178268487368462704 - 0 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casin
+Test "Imaginary part of: casin (+0 + 0.5 i) == +0 + 0.4812118250596034474977589134243684231352 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (+0 + 1.0 i) == +0 + 0.8813735870195430252326093249797923090282 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: casin (+0 + 1.5 i) == +0 + 1.194763217287109304111930828519090523536 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: casin (+0 - 0.5 i) == +0 - 0.4812118250596034474977589134243684231352 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (+0 - 1.0 i) == +0 - 0.8813735870195430252326093249797923090282 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (+0 - 1.5 i) == +0 - 1.194763217287109304111930828519090523536 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (-0 + 0.5 i) == -0 + 0.4812118250596034474977589134243684231352 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (-0 + 1.0 i) == -0 + 0.8813735870195430252326093249797923090282 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: casin (-0 + 1.5 i) == -0 + 1.194763217287109304111930828519090523536 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: casin (-0 - 0.5 i) == -0 - 0.4812118250596034474977589134243684231352 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (-0 - 1.0 i) == -0 - 0.8813735870195430252326093249797923090282 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (-0 - 1.5 i) == -0 - 1.194763217287109304111930828519090523536 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (-1.5 + +0 i) == -pi/2 + 0.9624236501192068949955178268487368462704 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casin (1.5 + +0 i) == pi/2 + 0.9624236501192068949955178268487368462704 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casinh
+Test "Real part of: casinh (-0 + 1.5 i) == -0.9624236501192068949955178268487368462704 + pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (-0 - 1.5 i) == -0.9624236501192068949955178268487368462704 - pi/2 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (-0.5 + +0 i) == -0.4812118250596034474977589134243684231352 + +0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (-0.5 - 0 i) == -0.4812118250596034474977589134243684231352 - 0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (-1.0 + +0 i) == -0.8813735870195430252326093249797923090282 + +0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Real part of: casinh (-1.0 - 0 i) == -0.8813735870195430252326093249797923090282 - 0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "Real part of: casinh (-1.5 + +0 i) == -1.194763217287109304111930828519090523536 + +0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (-1.5 - 0 i) == -1.194763217287109304111930828519090523536 - 0 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (0.5 + +0 i) == 0.4812118250596034474977589134243684231352 + +0 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (0.5 - 0 i) == 0.4812118250596034474977589134243684231352 - 0 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (1.0 + +0 i) == 0.8813735870195430252326093249797923090282 + +0 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (1.0 - 0 i) == 0.8813735870195430252326093249797923090282 - 0 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (1.5 + +0 i) == 1.194763217287109304111930828519090523536 + +0 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: casinh (1.5 - 0 i) == 1.194763217287109304111930828519090523536 - 0 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+# catan
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+ildouble: 1
+ldouble: 1
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+ildouble: 1
+ldouble: 1
+
+# cbrt
+Test "cbrt (-0.001) == -0.1":
+ildouble: 1
+ldouble: 1
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Imaginary part of: ccos (-0.75 + 11357.25 i) == 9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-0.75 + 710.5 i) == 1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (-0.75 + 89.5 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-0.75 + 89.5 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-0.75 - 11357.25 i) == 9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-0.75 - 710.5 i) == 1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (-0.75 - 89.5 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-0.75 - 89.5 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 11357.25 i) == 9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0.75 + 710.5 i) == 1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 89.5 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0.75 + 89.5 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0.75 - 11357.25 i) == 9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0.75 - 710.5 i) == 1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 - 89.5 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0.75 - 89.5 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (0x1p-1074 + 1440 i) == inf - 5.981479269486130556466515778180916082415e301 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ccos (0x1p-16434 + 22730 i) == inf - 1.217853148905605987081057582351152052687e4924 i":
+ildouble: 1
+ldouble: 1
+
+# ccosh
+Test "Imaginary part of: ccosh (-11357.25 + 0.75 i) == 9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-11357.25 - 0.75 i) == 9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-710.5 + 0.75 i) == 1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-710.5 - 0.75 i) == 1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (-89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (-89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (11357.25 + 0.75 i) == 9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (11357.25 - 0.75 i) == 9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (1440 + 0x1p-1074 i) == inf + 5.981479269486130556466515778180916082415e301 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ccosh (22730 + 0x1p-16434 i) == inf + 1.217853148905605987081057582351152052687e4924 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (710.5 + 0.75 i) == 1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (710.5 - 0.75 i) == 1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cexp
+Test "Imaginary part of: cexp (-10000 + 0x1p16383 i) == 1.045876464564882298442774542991176546722e-4343 + 4.421154026488516836023811173959413420548e-4344 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-720 + 0.75 i) == 1.486960657116368433685753325516638551722e-313 + 1.385247284245720590980701226843815229385e-313 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-95 + 0.75 i) == 4.039714446238306526889476684000081624047e-42 + 3.763383677300535390271646960780570275931e-42 i":
+double: 1
+idouble: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (1440 + 0x1p-1074 i) == inf + 1.196295853897226111293303155636183216483e302 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: cexp (1440 + 0x1p-1074 i) == inf + 1.196295853897226111293303155636183216483e302 i plus overflow exception":
+double: 1
+idouble: 1
+Test "Imaginary part of: cexp (22730 + 0x1p-16434 i) == inf + 2.435706297811211974162115164702304105374e4924 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (22730 + 0x1p-16434 i) == inf + 2.435706297811211974162115164702304105374e4924 i plus overflow exception":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (50 + 0x1p127 i) == 4.053997150228616856622417636046265337193e21 + 3.232070315463388524466674772633810238819e21 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (50 + 0x1p127 i) == 4.053997150228616856622417636046265337193e21 + 3.232070315463388524466674772633810238819e21 i":
+double: 1
+idouble: 1
+Test "Real part of: cexp (500 + 0x1p1023 i) == -1.159886268932754433233243794561351783426e217 + 7.904017694554466595359379965081774849708e216 i":
+double: 1
+idouble: 1
+Test "Real part of: cexp (709.8125 + 0.75 i) == 1.355121963080879535248452862759108365762e308 + 1.262426823598609432507811340856186873507e308 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: cexp (709.8125 + 0.75 i) == 1.355121963080879535248452862759108365762e308 + 1.262426823598609432507811340856186873507e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (88.75 + 0.75 i) == 2.558360358486542817001900410314204322891e38 + 2.383359453227311447654736314679677655100e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (88.75 + 0.75 i) == 2.558360358486542817001900410314204322891e38 + 2.383359453227311447654736314679677655100e38 i":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# clog
+Test "Real part of: clog (-0x1.0000000123456p0 + 0x1.2345678p-1000 i) == 2.649094276923003995420209214900915462737e-10 + 3.141592653589793238462643383279502884197 i":
+double: 1
+idouble: 1
+Test "Real part of: clog (-0x1.0000000123456p0 + 0x1.2345678p-30 i) == 2.649094282537168795982991778475646793277e-10 + 3.141592652530155111500161671113150737892 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog (-0x1.234566p-40 - 1.0 i) == 5.354083939753840089583620652120903838944e-25 - 1.570796326795931422008642456283782656359 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (-0x1.fp+127 + 0x1p-149 i) == 88.69109041335841930424871526389807508374 + pi i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (-0x1.fp+127 - 0x1p-149 i) == 88.69109041335841930424871526389807508374 - pi i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (-0x1.fp+16383 + 0x1p-16445 i) == 11356.49165759582936919077408168801636572 + pi i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1.fp+16383 + 0x1p-16494 i) == 11356.49165759582936919077408168801636572 + pi i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1.fp+16383 - 0x1p-16445 i) == 11356.49165759582936919077408168801636572 - pi i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1.fp+16383 - 0x1p-16494 i) == 11356.49165759582936919077408168801636572 - pi i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1p-149 + 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 + pi/2 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog (-0x1p-149 + 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 + pi/2 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (-0x1p-149 - 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 - pi/2 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog (-0x1p-149 - 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 - pi/2 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (-0x1p-16445 + 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 + pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1p-16445 - 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 - pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1p-16494 + 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 + pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (-0x1p-16494 - 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 - pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1.000566p0 + 0x1.234p-10 i) == 8.298731898331237038231468223024422855654e-5 + 1.110938609507128729312743251313024793990e-3 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog (0x1.000566p0 + 0x1.234p-10 i) == 8.298731898331237038231468223024422855654e-5 + 1.110938609507128729312743251313024793990e-3 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog (0x1.fffffffffffffp+1023 + 0x1p+1023 i) == 709.8942846690411016323109979483151967689 + 0.4636476090008061606231772164674799632783 i":
+double: 1
+idouble: 1
+Test "Real part of: clog (0x1.fp+127 + 0x1p-149 i) == 88.69109041335841930424871526389807508374 + +0 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (0x1.fp+127 - 0x1p-149 i) == 88.69109041335841930424871526389807508374 - 0 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (0x1.fp+16383 + 0x1.fp+16383 i) == 11356.83823118610934184548269774874545400 + pi/4 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1.fp+16383 + 0x1p-16445 i) == 11356.49165759582936919077408168801636572 + +0 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1.fp+16383 + 0x1p-16494 i) == 11356.49165759582936919077408168801636572 + +0 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1.fp+16383 - 0x1p-16445 i) == 11356.49165759582936919077408168801636572 - 0 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1.fp+16383 - 0x1p-16494 i) == 11356.49165759582936919077408168801636572 - 0 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1p-1074 + 0x1p-1074 i) == -744.0934983311012896593986823853525458290 + pi/4 i":
+double: 1
+idouble: 1
+Test "Real part of: clog (0x1p-147 + 0x1p-147 i) == -101.5460619520319878296245057936228672231 + pi/4 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (0x1p-149 + 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 + pi/2 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (0x1p-149 - 0x1.fp+127 i) == 88.69109041335841930424871526389807508374 - pi/2 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog (0x1p-16445 + 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 + pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1p-16445 - 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 - pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1p-16494 + 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 + pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (0x1p-16494 - 0x1.fp+16383 i) == 11356.49165759582936919077408168801636572 - pi/2 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog (1.0 + 0x1.234566p-10 i) == 6.172834701221959432440126967147726538097e-7 + 1.111110564353742042376451655136933182201e-3 i":
+float: 1
+ifloat: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (-0x1.0000000123456p0 + 0x1.2345678p-1000 i) == 1.150487026509145544402795327729455391948e-10 + 1.364376353841841347485783625431355770210 i":
+double: 2
+idouble: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-0x1.0000000123456p0 + 0x1.2345678p-1000 i) == 1.150487026509145544402795327729455391948e-10 + 1.364376353841841347485783625431355770210 i":
+double: 1
+idouble: 1
+Test "Real part of: clog10 (-0x1.0000000123456p0 + 0x1.2345678p-30 i) == 1.150487028947346337782682105935961875822e-10 + 1.364376353381646356131680448946397884147 i":
+double: 2
+idouble: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-0x1.0000000123456p0 + 0x1.2345678p-30 i) == 1.150487028947346337782682105935961875822e-10 + 1.364376353381646356131680448946397884147 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1.fp+1023 + 0x1p-1074 i) == 308.2409272754311106024666378243768099991 + 1.364376353841841347485783625431355770210 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1.fp+1023 - 0x1p-1074 i) == 308.2409272754311106024666378243768099991 - 1.364376353841841347485783625431355770210 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1.fp+127 + 0x1p-149 i) == 38.51805116050395969095658815123105801479 + 1.364376353841841347485783625431355770210 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0x1.fp+127 - 0x1p-149 i) == 38.51805116050395969095658815123105801479 - 1.364376353841841347485783625431355770210 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0x1p-1074 + 0x1.fp+1023 i) == 308.2409272754311106024666378243768099991 + 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1p-1074 - 0x1.fp+1023 i) == 308.2409272754311106024666378243768099991 - 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1p-149 + 0x1.fp+127 i) == 38.51805116050395969095658815123105801479 + 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-0x1p-149 - 0x1.fp+127 i) == 38.51805116050395969095658815123105801479 - 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-1.0 + 0x1.234566p-20 i) == 2.556638434669064077889576526006849923281e-13 + 1.364375882602207106407956770293808181427 i":
+double: 1
+idouble: 1
+Test "Real part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + inf i) == inf + 3/4 pi*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog10 (0x1.00000000000000123456789abcp0 + 0x1.23456789p-1000 i) == 4.285899851347756186652871946325962330640e-19 + 4.611541215247321502041995872887317363241e-302 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1.00000000000000123456789abcp0 + 0x1.23456789p-1000 i) == 4.285899851347756186652871946325962330640e-19 + 4.611541215247321502041995872887317363241e-302 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1.00000000000000123456789abcp0 + 0x1.23456789p-60 i) == 4.285899851347756188767674032946882584784e-19 + 4.285899850759344225805480528847018395861e-19 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog10 (0x1.000566p0 + 0x1.234p-10 i) == 3.604093470239754109961125085078190708674e-5 + 4.824745078422174667425851670822596859720e-4 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1.000566p0 + 0x1.234p-10 i) == 3.604093470239754109961125085078190708674e-5 + 4.824745078422174667425851670822596859720e-4 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: clog10 (0x1.000566p0 + 0x1.234p-100 i) == 3.577293486783822178310971763308187385546e-5 + 3.897399639875661463735636919790792140598e-31 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1.000566p0 + 0x1.234p-100 i) == 3.577293486783822178310971763308187385546e-5 + 3.897399639875661463735636919790792140598e-31 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1.234566p-30 + 1.0 i) == 2.438200411482400072282924063740535840474e-19 + 6.821881764607257184291586401763604544928e-1 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog10 (0x1.234566p-50 + 1.0 i) == 2.217530356103816369479108963807448194409e-31 + 6.821881769209202348667823902864283966959e-1 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1.234566p-50 + 1.0 i) == 2.217530356103816369479108963807448194409e-31 + 6.821881769209202348667823902864283966959e-1 i":
+float: 1
+ifloat: 1
+Test "Real part of: clog10 (0x1.234566p-60 + 1.0 i) == 2.114801746467415208319767917450504756866e-37 + 6.821881769209206733143018621078368211515e-1 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1.234566p-60 + 1.0 i) == 2.114801746467415208319767917450504756866e-37 + 6.821881769209206733143018621078368211515e-1 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1.fffffep+127 + 0x1.fffffep+127 i) == 38.68235441693561449174780668781319348761 + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0x1.fffffep+127 + 1.0 i) == 38.53183941910362389414093724045094697423 + 1.276276851248440096917018665609900318458e-39 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1.fffffffffffffp+1023 + 0x1.fffffffffffffp+1023 i) == 308.4052305577487344482591243175787477115 + pi/4*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1.fffffffffffffp+1023 + 0x1p+1023 i) == 308.3031705664207720674749211936626341569 + 0.2013595981366865903254995612594728746470 i":
+double: 1
+idouble: 1
+Test "Real part of: clog10 (0x1.fp+16383 + 0x1.fp+16383 i) == 4932.212175672014259683102930239951947672 + pi/4*log10(e) i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: clog10 (0x1.fp+16383 + 0x1p+16383 i) == 4932.112944269463028900262609694408579449 + 0.2069271710841128115912940666587802677383 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (0x1p-1073 + 0x1p-1073 i) == -322.8546703496198318667349645920187712089 + pi/4*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-1074 + 0x1.fp+1023 i) == 308.2409272754311106024666378243768099991 + 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Real part of: clog10 (0x1p-1074 + 0x1p-1074 i) == -323.1557003452838130619487034867432642357 + pi/4*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-1074 + 0x1p-1074 i) == -323.1557003452838130619487034867432642357 + pi/4*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-1074 - 0x1.fp+1023 i) == 308.2409272754311106024666378243768099991 - 0.6821881769209206737428918127156778851051 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-147 + 0x1p-147 i) == -44.10089436477324509881274807713822842154 + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-149 + 0x1.fp+127 i) == 38.51805116050395969095658815123105801479 + 0.6821881769209206737428918127156778851051 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-149 + 0x1p-149 i) == -44.70295435610120748924022586658721447508 + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-149 - 0x1.fp+127 i) == 38.51805116050395969095658815123105801479 - 0.6821881769209206737428918127156778851051 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-509 + 1.0 i) == 7.730698388614835910296270976605350994446e-308 + 6.821881769209206737428918127156778851051e-1 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-510 + 1.0 i) == 1.932674597153708977574067744151337748612e-308 + 6.821881769209206737428918127156778851051e-1 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-511 + 1.0 i) == 4.831686492884272443935169360378344371529e-309 + 6.821881769209206737428918127156778851051e-1 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (0x1p-61 + 1.0 i) == 4.084085680564517578238994467153626207224e-38 + 6.821881769209206735545466044044889962925e-1 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-62 + 1.0 i) == 1.021021420141129394559748616788406551878e-38 + 6.821881769209206736487192085600834406988e-1 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0x1p-63 + 1.0 i) == 2.552553550352823486399371541971016379740e-39 + 6.821881769209206736958055106378806629019e-1 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (1.0 + 0x1.234566p-10 i) == 2.680828048441605163181684680300513080769e-7 + 4.825491868832381486767558728169977751564e-4 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cos
+Test "cos (0x1p+120) == -9.25879022854837867303861764107414946730833e-01":
+float: 1
+ifloat: 1
+Test "cos (0x1p+127) == 7.81914638714960072263910298466369236613162e-01":
+float: 1
+ifloat: 1
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+idouble: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cos_downward
+Test "cos_downward (1) == 0.5403023058681397174009366074429766037323":
+float: 1
+ifloat: 1
+Test "cos_downward (10) == -0.8390715290764524522588639478240648345199":
+ildouble: 1
+ldouble: 1
+Test "cos_downward (2) == -0.4161468365471423869975682295007621897660":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_downward (3) == -0.9899924966004454572715727947312613023937":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_downward (4) == -0.6536436208636119146391681830977503814241":
+float: 1
+ifloat: 1
+Test "cos_downward (5) == 0.2836621854632262644666391715135573083344":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_downward (6) == 0.9601702866503660205456522979229244054519":
+ildouble: 1
+ldouble: 1
+Test "cos_downward (7) == 0.7539022543433046381411975217191820122183":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_downward (8) == -0.1455000338086135258688413818311946826093":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+# cos_tonearest
+Test "cos_tonearest (7) == 0.7539022543433046381411975217191820122183":
+float: 1
+ifloat: 1
+
+# cos_towardzero
+Test "cos_towardzero (10) == -0.8390715290764524522588639478240648345199":
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (2) == -0.4161468365471423869975682295007621897660":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (3) == -0.9899924966004454572715727947312613023937":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (5) == 0.2836621854632262644666391715135573083344":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (6) == 0.9601702866503660205456522979229244054519":
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (7) == 0.7539022543433046381411975217191820122183":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cos_towardzero (8) == -0.1455000338086135258688413818311946826093":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+# cos_upward
+Test "cos_upward (1) == 0.5403023058681397174009366074429766037323":
+ildouble: 1
+ldouble: 1
+Test "cos_upward (10) == -0.8390715290764524522588639478240648345199":
+float: 1
+ifloat: 1
+Test "cos_upward (4) == -0.6536436208636119146391681830977503814241":
+ildouble: 1
+ldouble: 1
+Test "cos_upward (6) == 0.9601702866503660205456522979229244054519":
+float: 1
+ifloat: 1
+Test "cos_upward (7) == 0.7539022543433046381411975217191820122183":
+float: 1
+ifloat: 1
+Test "cos_upward (9) == -0.9111302618846769883682947111811653112463":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# cosh_downward
+Test "cosh_downward (22) == 1792456423.065795780980053377632656584997":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cosh_downward (23) == 4872401723.124451300068625740569997090344":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cosh_downward (24) == 13244561064.92173614708845674912733665919":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cosh_tonearest
+Test "cosh_tonearest (22) == 1792456423.065795780980053377632656584997":
+ildouble: 1
+ldouble: 1
+
+# cosh_towardzero
+Test "cosh_towardzero (22) == 1792456423.065795780980053377632656584997":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cosh_towardzero (23) == 4872401723.124451300068625740569997090344":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "cosh_towardzero (24) == 13244561064.92173614708845674912733665919":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cosh_upward
+Test "cosh_upward (22) == 1792456423.065795780980053377632656584997":
+ildouble: 1
+ldouble: 1
+Test "cosh_upward (23) == 4872401723.124451300068625740569997090344":
+ildouble: 1
+ldouble: 1
+Test "cosh_upward (24) == 13244561064.92173614708845674912733665919":
+ildouble: 1
+ldouble: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 4
+ldouble: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+ildouble: 11
+ldouble: 11
+Test "Real part of: cpow (2 + 0 i, 10 + 0 i) == 1024.0 + 0.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# csin
+Test "Real part of: csin (-0.75 + 11357.25 i) == -8.385498349388321535962327491346664141020e4931 + 9.001213196851067077465606717616495588201e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (-0.75 + 710.5 i) == -1.255317763348154410745082950806112487736e308 + 1.347490911916428129246890157395342279438e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (-0.75 + 89.5 i) == -2.522786001038096774676288412995370563339e38 + 2.708024460708609732016532185663087200560e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csin (-0.75 + 89.5 i) == -2.522786001038096774676288412995370563339e38 + 2.708024460708609732016532185663087200560e38 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (-0.75 - 11357.25 i) == -8.385498349388321535962327491346664141020e4931 - 9.001213196851067077465606717616495588201e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (-0.75 - 710.5 i) == -1.255317763348154410745082950806112487736e308 - 1.347490911916428129246890157395342279438e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (-0.75 - 89.5 i) == -2.522786001038096774676288412995370563339e38 - 2.708024460708609732016532185663087200560e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csin (-0.75 - 89.5 i) == -2.522786001038096774676288412995370563339e38 - 2.708024460708609732016532185663087200560e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csin (-2 - 3 i) == -9.15449914691142957346729954460983256 + 4.16890695996656435075481305885375484 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 1.25 i) == 1.28722291002649188575873510790565441 + 1.17210635989270256101081285116138863 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 11357.25 i) == 8.385498349388321535962327491346664141020e4931 + 9.001213196851067077465606717616495588201e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 710.5 i) == 1.255317763348154410745082950806112487736e308 + 1.347490911916428129246890157395342279438e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 89.5 i) == 2.522786001038096774676288412995370563339e38 + 2.708024460708609732016532185663087200560e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csin (0.75 + 89.5 i) == 2.522786001038096774676288412995370563339e38 + 2.708024460708609732016532185663087200560e38 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 - 11357.25 i) == 8.385498349388321535962327491346664141020e4931 - 9.001213196851067077465606717616495588201e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 - 710.5 i) == 1.255317763348154410745082950806112487736e308 - 1.347490911916428129246890157395342279438e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 - 89.5 i) == 2.522786001038096774676288412995370563339e38 - 2.708024460708609732016532185663087200560e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csin (0.75 - 89.5 i) == 2.522786001038096774676288412995370563339e38 - 2.708024460708609732016532185663087200560e38 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0x1p-1074 + 1440 i) == 5.981479269486130556466515778180916082415e301 + inf i":
+double: 1
+idouble: 1
+Test "Real part of: csin (0x1p-16434 + 22730 i) == 1.217853148905605987081057582351152052687e4924 + inf i":
+ildouble: 1
+ldouble: 1
+
+# csinh
+Test "Imaginary part of: csinh (-11357.25 + 0.75 i) == -9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-11357.25 - 0.75 i) == -9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: csinh (-710.5 + 0.75 i) == -1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-710.5 - 0.75 i) == -1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (-89.5 + 0.75 i) == -2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-89.5 + 0.75 i) == -2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (-89.5 - 0.75 i) == -2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-89.5 - 0.75 i) == -2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (11357.25 + 0.75 i) == 9.001213196851067077465606717616495588201e4931 + 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (11357.25 - 0.75 i) == 9.001213196851067077465606717616495588201e4931 - 8.385498349388321535962327491346664141020e4931 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (1440 + 0x1p-1074 i) == inf + 5.981479269486130556466515778180916082415e301 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: csinh (22730 + 0x1p-16434 i) == inf + 1.217853148905605987081057582351152052687e4924 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (710.5 + 0.75 i) == 1.347490911916428129246890157395342279438e308 + 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (710.5 - 0.75 i) == 1.347490911916428129246890157395342279438e308 - 1.255317763348154410745082950806112487736e308 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (89.5 + 0.75 i) == 2.708024460708609732016532185663087200560e38 + 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csinh (89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (89.5 - 0.75 i) == 2.708024460708609732016532185663087200560e38 - 2.522786001038096774676288412995370563339e38 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# csqrt
+Test "Real part of: csqrt (-0x1.0000000000000000000000000001p-16382 - 0x1.0000000000000000000000000001p-16382 i) == 8.344545284118961663847948339519226074126e-2467 - 2.014551439675644900022606748976158925145e-2466 i":
+ldouble: 1
+Test "Real part of: csqrt (-0x1.0000000000000002p-16382 - 0x1.0000000000000002p-16382 i) == 8.344545284118961664300307045791497724440e-2467 - 2.014551439675644900131815801350165472778e-2466 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (-0x1.0000000000000002p-16382 - 0x1.0000000000000002p-16382 i) == 8.344545284118961664300307045791497724440e-2467 - 2.014551439675644900131815801350165472778e-2466 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-0x1.0000000000001p-1022 - 0x1.0000000000001p-1022 i) == 6.788430486774966350907249113759995429568e-155 - 1.638872094839911521020410942677082920935e-154 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-0x1.000002p-126 - 0x1.000002p-126 i) == 4.934094449071842328766868579214125217132e-20 - 1.191195773697904627170323731331667740087e-19 i":
+double: 1
+idouble: 1
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0.75 + 1.25 i) == 1.05065169626078392338656675760808326 + 0.594868882070379067881984030639932657 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.0000000000000000000000000001p-16382 + 0x1.0000000000000000000000000001p-16382 i) == 2.014551439675644900022606748976158925145e-2466 + 8.344545284118961663847948339519226074126e-2467 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (0x1.0000000000000002p-16382 + 0x1.0000000000000002p-16382 i) == 2.014551439675644900131815801350165472778e-2466 + 8.344545284118961664300307045791497724440e-2467 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.0000000000000002p-16382 + 0x1.0000000000000002p-16382 i) == 2.014551439675644900131815801350165472778e-2466 + 8.344545284118961664300307045791497724440e-2467 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.0000000000001p-1022 + 0x1.0000000000001p-1022 i) == 1.638872094839911521020410942677082920935e-154 + 6.788430486774966350907249113759995429568e-155 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.000002p-126 + 0x1.000002p-126 i) == 1.191195773697904627170323731331667740087e-19 + 4.934094449071842328766868579214125217132e-20 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: csqrt (0x1.fffffep+127 + 1.0 i) == 1.844674352395372953599975585936590505260e+19 + 2.710505511993121390769065968615872097053e-20 i":
+float: 1
+ifloat: 1
+Test "Real part of: csqrt (0x1.fffffffffffffp+1023 + 0x1.fffffffffffffp+1023 i) == 1.473094556905565378990473658199034571917e+154 + 6.101757441282702188537080005372547713595e+153 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: csqrt (0x1.fffffffffffffp+1023 + 0x1.fffffffffffffp+1023 i) == 1.473094556905565378990473658199034571917e+154 + 6.101757441282702188537080005372547713595e+153 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.fffffffffffffp+1023 + 0x1p+1023 i) == 1.379778091031440685006200821918878702861e+154 + 3.257214233483129514781233066898042490248e+153 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (0x1.fp+16383 + 0x1.fp+16383 i) == 1.179514222452201722651836720466795901016e+2466 + 4.885707879516577666702435054303191575148e+2465 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.fp+16383 + 0x1.fp+16383 i) == 1.179514222452201722651836720466795901016e+2466 + 4.885707879516577666702435054303191575148e+2465 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1.fp+16383 + 0x1p+16383 i) == 1.106698967236475180613254276996359485630e+2466 + 2.687568007603946993388538156299100955642e+2465 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0x1p-16440 + 0x1p-16441 i) == 3.514690655930285351254618340783294558136e-2475 + 8.297059146828716918029689466551384219370e-2476 i":
+ildouble: 1
+ldouble: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan (0x1p1023 + 1 i) == -0.2254627924997545057926782581695274244229 + 0.8786063118883068695462540226219865087189 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctan (0x1p1023 + 1 i) == -0.2254627924997545057926782581695274244229 + 0.8786063118883068695462540226219865087189 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan (0x1p127 + 1 i) == 0.2446359391192790896381501310437708987204 + 0.9101334047676183761532873794426475906201 i":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctan (0x1p127 + 1 i) == 0.2446359391192790896381501310437708987204 + 0.9101334047676183761532873794426475906201 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan (0x1p16383 + 1 i) == 0.1608598776370396607204448234354670036772 + 0.8133818522051542536316746743877629761488 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0x1p16383 + 1 i) == 0.1608598776370396607204448234354670036772 + 0.8133818522051542536316746743877629761488 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan (0x3.243f6cp-1 + 0 i) == -2.287733242885645987394874673945769518150e7 + 0.0 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan (1 + 355 i) == 8.140551093483276762350406321792653551513e-309 + 1.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan (1 + 365 i) == 1.677892637497921890115075995898773550884e-317 + 1.0 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan (1 + 45 i) == 1.490158918874345552942703234806348520895e-39 + 1.000000000000000000000000000000000000001 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan (1 + 47 i) == 2.729321264492904590777293425576722354636e-41 + 1.0 i":
+ildouble: 1
+ldouble: 1
+
+# ctan_downward
+Test "Real part of: ctan_downward (0x1.921fb54442d1846ap+0 + 0x1p-16445 i) == -3.986797629811710706723242948653362815645e19 + 5.793882568875674066286163141055208625180e-4912 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan_downward (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: ctan_downward (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 3
+ldouble: 3
+Test "Real part of: ctan_downward (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctan_downward (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+# ctan_tonearest
+Test "Imaginary part of: ctan_tonearest (0x1.921fb54442d1846ap+0 + 0x1p-16445 i) == -3.986797629811710706723242948653362815645e19 + 5.793882568875674066286163141055208625180e-4912 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan_tonearest (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: ctan_tonearest (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 3
+ldouble: 3
+Test "Real part of: ctan_tonearest (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan_tonearest (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+# ctan_towardzero
+Test "Real part of: ctan_towardzero (0x1.921fb54442d1846ap+0 + 0x1p-16445 i) == -3.986797629811710706723242948653362815645e19 + 5.793882568875674066286163141055208625180e-4912 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan_towardzero (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan_towardzero (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctan_towardzero (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ctan_towardzero (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+# ctan_upward
+Test "Real part of: ctan_upward (0x1.921fb54442d1846ap+0 + 0x1p-16445 i) == -3.986797629811710706723242948653362815645e19 + 5.793882568875674066286163141055208625180e-4912 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan_upward (0x1.921fb54442d1846ap+0 + 0x1p-16445 i) == -3.986797629811710706723242948653362815645e19 + 5.793882568875674066286163141055208625180e-4912 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctan_upward (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctan_upward (0x1.921fb54442d18p+0 + 0x1p-1074 i) == 1.633123935319536975596773704152891653086e16 + 1.317719414943508315995636961402669067843e-291 i":
+ildouble: 3
+ldouble: 3
+Test "Real part of: ctan_upward (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctan_upward (0x1.921fb6p+0 + 0x1p-149 i) == -2.287733242885645987394874673945769518150e7 + 7.334008549954377778731880988481078535821e-31 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctanh (0 + 0x3.243f6cp-1 i) == 0.0 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (1 + 0x1p1023 i) == 0.8786063118883068695462540226219865087189 - 0.2254627924997545057926782581695274244229 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh (1 + 0x1p1023 i) == 0.8786063118883068695462540226219865087189 - 0.2254627924997545057926782581695274244229 i":
+double: 1
+idouble: 1
+Test "Real part of: ctanh (1 + 0x1p127 i) == 0.9101334047676183761532873794426475906201 + 0.2446359391192790896381501310437708987204 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (1 + 0x1p127 i) == 0.9101334047676183761532873794426475906201 + 0.2446359391192790896381501310437708987204 i":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctanh (1 + 0x1p16383 i) == 0.8133818522051542536316746743877629761488 + 0.1608598776370396607204448234354670036772 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh (1 + 0x1p16383 i) == 0.8133818522051542536316746743877629761488 + 0.1608598776370396607204448234354670036772 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (355 + 1 i) == 1.0 + 8.140551093483276762350406321792653551513e-309 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh (365 + 1 i) == 1.0 + 1.677892637497921890115075995898773550884e-317 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (45 + 1 i) == 1.000000000000000000000000000000000000001 + 1.490158918874345552942703234806348520895e-39 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh (47 + 1 i) == 1.0 + 2.729321264492904590777293425576722354636e-41 i":
+ildouble: 1
+ldouble: 1
+
+# ctanh_downward
+Test "Real part of: ctanh_downward (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: ctanh_downward (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 4
+ldouble: 4
+Test "Real part of: ctanh_downward (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "Imaginary part of: ctanh_downward (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh_downward (0x1p-16445 + 0x1.921fb54442d1846ap+0 i) == 5.793882568875674066286163141055208625180e-4912 - 3.986797629811710706723242948653362815645e19 i":
+ildouble: 2
+ldouble: 2
+
+# ctanh_tonearest
+Test "Real part of: ctanh_tonearest (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: ctanh_tonearest (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 3
+ldouble: 3
+Test "Real part of: ctanh_tonearest (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh_tonearest (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctanh_tonearest (0x1p-16445 + 0x1.921fb54442d1846ap+0 i) == 5.793882568875674066286163141055208625180e-4912 - 3.986797629811710706723242948653362815645e19 i":
+ildouble: 1
+ldouble: 1
+
+# ctanh_towardzero
+Test "Real part of: ctanh_towardzero (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: ctanh_towardzero (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: ctanh_towardzero (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "Imaginary part of: ctanh_towardzero (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ctanh_towardzero (0x1p-16445 + 0x1.921fb54442d1846ap+0 i) == 5.793882568875674066286163141055208625180e-4912 - 3.986797629811710706723242948653362815645e19 i":
+ildouble: 1
+ldouble: 1
+
+# ctanh_upward
+Test "Real part of: ctanh_upward (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: ctanh_upward (0x1p-1074 + 0x1.921fb54442d18p+0 i) == 1.317719414943508315995636961402669067843e-291 + 1.633123935319536975596773704152891653086e16 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctanh_upward (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "Imaginary part of: ctanh_upward (0x1p-149 + 0x1.921fb6p+0 i) == 7.334008549954377778731880988481078535821e-31 - 2.287733242885645987394874673945769518150e7 i":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "Real part of: ctanh_upward (0x1p-16445 + 0x1.921fb54442d1846ap+0 i) == 5.793882568875674066286163141055208625180e-4912 - 3.986797629811710706723242948653362815645e19 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh_upward (0x1p-16445 + 0x1.921fb54442d1846ap+0 i) == 5.793882568875674066286163141055208625180e-4912 - 3.986797629811710706723242948653362815645e19 i":
+ildouble: 1
+ldouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (0.75) == 0.288844366346484868401062165408589223":
+float: 1
+ifloat: 1
+Test "erfc (0x1.f7303cp+1) == 2.705500297238986897105236321218861842255e-8":
+double: 1
+idouble: 1
+Test "erfc (0x1.ffa002p+2) == 1.233585992097580296336099501489175967033e-29":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "erfc (0x1.ffffc8p+2) == 1.122671365033056305522366683719541099329e-29":
+ildouble: 1
+ldouble: 1
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (27.0) == 0.523704892378925568501606768284954709e-318":
+ildouble: 1
+ldouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# errno
+Test "errno for pow(0,-odd) == ERANGE":
+float: -34
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (-305) == 1.0e-305":
+double: 1
+idouble: 1
+Test "exp10 (-36) == 1.0e-36":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "exp10 (36) == 1.0e36":
+double: 1
+idouble: 1
+Test "exp10 (4932) == 1.0e4932":
+ildouble: 1
+ldouble: 1
+
+# exp2
+Test "exp2 (100.5) == 1.792728671193156477399422023278661496394e+30":
+ildouble: 1
+ldouble: 1
+
+# exp_downward
+Test "exp_downward (2) == e^2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "exp_downward (3) == e^3":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# exp_towardzero
+Test "exp_towardzero (2) == e^2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "exp_towardzero (3) == e^3":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# exp_upward
+Test "exp_upward (1) == e":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# expm1
+Test "expm1 (-79.0) == -0.9999999999999999999999999999999999509391":
+ildouble: 1
+ldouble: 1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "expm1 (500.0) == 1.4035922178528374107397703328409120821806e+217":
+double: 1
+idouble: 1
+
+# gamma
+Test "gamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-0x1.001000001p+593) == -3.927269966354206207832593635798954916263e-90":
+ildouble: 1
+ldouble: 1
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0x1.d7ce3ap+107) == 2.775523647291230802651040996274861694514e-17":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+ildouble: 2
+ldouble: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# j1
+Test "j1 (-1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "j1 (0x1.3ffp+74) == 1.818984347516051243459364437186082741567e-12":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "j1 (0x1.ff00000000002p+840) == 1.846591691699331493194965158699937660696e-127":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "j1 (1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+ildouble: 2
+ldouble: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (1, -1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+Test "jn (10, -1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "jn (2, 0x1.ffff62p+99) == -4.43860668048170034334926693188979974489e-16":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+Test "jn (2, 2.4048255576957729) == 0.43175480701968038399746111312430703":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+idouble: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+float: 1
+ifloat: 1
+Test "jn (3, 2.4048255576957729) == 0.19899990535769083404042146764530813":
+double: 3
+float: 2
+idouble: 3
+ildouble: 1
+ldouble: 1
+Test "jn (4, 2.4048255576957729) == 0.647466661641779720084932282551219891E-1":
+double: 1
+float: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "jn (5, 2.4048255576957729) == 0.163892432048058525099230549946147698E-1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (6, 2.4048255576957729) == 0.34048184720278336646673682895929161E-2":
+double: 4
+float: 4
+idouble: 4
+ifloat: 3
+ildouble: 5
+ldouble: 5
+Test "jn (7, 2.4048255576957729) == 0.60068836573295394221291569249883076E-3":
+double: 3
+float: 5
+idouble: 3
+ifloat: 5
+ildouble: 3
+ldouble: 3
+Test "jn (8, 2.4048255576957729) == 0.92165786705344923232879022467054148E-4":
+double: 3
+float: 4
+idouble: 3
+ifloat: 2
+ildouble: 8
+ldouble: 8
+Test "jn (9, 2.4048255576957729) == 0.12517270977961513005428966643852564E-4":
+double: 1
+float: 5
+idouble: 1
+ifloat: 2
+ildouble: 3
+ldouble: 3
+
+# lgamma
+Test "lgamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# llrint_downward
+Test "llrint_downward (-0.2) == -1":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-1.4) == -2":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-4503599627370495.4999999999999) == -4503599627370496LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-4503599627370496.25) == -4503599627370497LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-4503599627370496.4999999999999) == -4503599627370497LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-4503599627370496.5) == -4503599627370497LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-4503599627370497.4999999999999) == -4503599627370498LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-72057594037927936.25) == -72057594037927937LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-72057594037927936.5) == -72057594037927937LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-8388600.3) == -8388601":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9007199254740991.4999999999999) == -9007199254740992LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9007199254740992.25) == -9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9007199254740992.4999999999999) == -9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9007199254740992.5) == -9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9007199254740993.4999999999999) == -9007199254740994LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9223372036854775806.25) == -9223372036854775807LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (-9223372036854775806.5) == -9223372036854775807LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370494.5000000000001) == 4503599627370494LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370495.5) == 4503599627370495LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370495.5000000000001) == 4503599627370495LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370496.5000000000001) == 4503599627370496LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370496.75) == 4503599627370496LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (4503599627370497.5) == 4503599627370497LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (72057594037927935.5) == 72057594037927935LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (72057594037927936.75) == 72057594037927936LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (72057594037927937.5) == 72057594037927937LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740991.5) == 9007199254740991LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740991.5000000000001) == 9007199254740991LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740992.5000000000001) == 9007199254740992LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740992.75) == 9007199254740992LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740993.5) == 9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9007199254740993.5000000000001) == 9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9223372036854775805.5) == 9223372036854775805LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_downward (9223372036854775806.75) == 9223372036854775806LL":
+ildouble: 1
+ldouble: 1
+
+# llrint_towardzero
+Test "llrint_towardzero (4503599627370494.5000000000001) == 4503599627370494LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (4503599627370495.5) == 4503599627370495LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (4503599627370495.5000000000001) == 4503599627370495LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (4503599627370496.5000000000001) == 4503599627370496LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (4503599627370496.75) == 4503599627370496LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (4503599627370497.5) == 4503599627370497LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (72057594037927935.5) == 72057594037927935LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (72057594037927936.75) == 72057594037927936LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (72057594037927937.5) == 72057594037927937LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740991.5) == 9007199254740991LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740991.5000000000001) == 9007199254740991LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740992.5000000000001) == 9007199254740992LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740992.75) == 9007199254740992LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740993.5) == 9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9007199254740993.5000000000001) == 9007199254740993LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9223372036854775805.5) == 9223372036854775805LL":
+ildouble: 1
+ldouble: 1
+Test "llrint_towardzero (9223372036854775806.75) == 9223372036854775806LL":
+ildouble: 1
+ldouble: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# log2
+Test "log2 (0.75) == -.415037499278843818546261056052183492":
+ildouble: 1
+ldouble: 1
+
+# lrint_downward
+Test "lrint_downward (-0.2) == -1":
+ildouble: 1
+ldouble: 1
+Test "lrint_downward (-0.5) == -1":
+ildouble: 1
+ldouble: 1
+Test "lrint_downward (-1.4) == -2":
+ildouble: 1
+ldouble: 1
+Test "lrint_downward (-8388600.3) == -8388601":
+ildouble: 1
+ldouble: 1
+Test "lrint_downward (0.8) == 0":
+ildouble: 1
+ldouble: 1
+
+# pow
+Test "pow (0x0.ffffffp0, 0x1p24) == 0.3678794302077803437135155590023422899744":
+float: 1
+ifloat: 1
+
+# pow_downward
+Test "pow_downward (1.5, 1.03125) == 1.519127098714743184071644334163037684948":
+float: 1
+ifloat: 1
+
+# pow_towardzero
+Test "pow_towardzero (1.5, 1.03125) == 1.519127098714743184071644334163037684948":
+float: 1
+ifloat: 1
+
+# pow_upward
+Test "pow_upward (1.0625, 1.125) == 1.070582293028761362162622578677070098674":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# sin_downward
+Test "sin_downward (10) == -0.5440211108893698134047476618513772816836":
+float: 1
+ifloat: 1
+Test "sin_downward (2) == 0.9092974268256816953960198659117448427023":
+ildouble: 1
+ldouble: 1
+Test "sin_downward (3) == 0.1411200080598672221007448028081102798469":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sin_downward (4) == -0.7568024953079282513726390945118290941359":
+ildouble: 1
+ldouble: 1
+Test "sin_downward (5) == -0.9589242746631384688931544061559939733525":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sin_downward (6) == -0.2794154981989258728115554466118947596280":
+float: 1
+ifloat: 1
+Test "sin_downward (8) == 0.9893582466233817778081235982452886721164":
+ildouble: 1
+ldouble: 1
+Test "sin_downward (9) == 0.4121184852417565697562725663524351793439":
+ildouble: 1
+ldouble: 1
+
+# sin_tonearest
+Test "sin_tonearest (1) == 0.8414709848078965066525023216302989996226":
+float: 1
+ifloat: 1
+Test "sin_tonearest (3) == 0.1411200080598672221007448028081102798469":
+ildouble: 1
+ldouble: 1
+
+# sin_towardzero
+Test "sin_towardzero (1) == 0.8414709848078965066525023216302989996226":
+float: 1
+ifloat: 1
+Test "sin_towardzero (10) == -0.5440211108893698134047476618513772816836":
+float: 1
+ifloat: 1
+Test "sin_towardzero (2) == 0.9092974268256816953960198659117448427023":
+ildouble: 1
+ldouble: 1
+Test "sin_towardzero (3) == 0.1411200080598672221007448028081102798469":
+ildouble: 1
+ldouble: 1
+Test "sin_towardzero (4) == -0.7568024953079282513726390945118290941359":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sin_towardzero (5) == -0.9589242746631384688931544061559939733525":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sin_towardzero (8) == 0.9893582466233817778081235982452886721164":
+ildouble: 1
+ldouble: 1
+Test "sin_towardzero (9) == 0.4121184852417565697562725663524351793439":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# sin_upward
+Test "sin_upward (1) == 0.8414709848078965066525023216302989996226":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sin_upward (10) == -0.5440211108893698134047476618513772816836":
+ildouble: 1
+ldouble: 1
+Test "sin_upward (2) == 0.9092974268256816953960198659117448427023":
+float: 2
+ifloat: 2
+Test "sin_upward (3) == 0.1411200080598672221007448028081102798469":
+ildouble: 1
+ldouble: 1
+Test "sin_upward (4) == -0.7568024953079282513726390945118290941359":
+float: 1
+ifloat: 1
+Test "sin_upward (6) == -0.2794154981989258728115554466118947596280":
+ildouble: 1
+ldouble: 1
+Test "sin_upward (7) == 0.6569865987187890903969990915936351779369":
+ildouble: 1
+ldouble: 1
+Test "sin_upward (9) == 0.4121184852417565697562725663524351793439":
+float: 1
+ifloat: 1
+
+# sincos
+Test "sincos (0x1p+120, &sin_res, &cos_res) puts -9.25879022854837867303861764107414946730833e-01 in cos_res":
+float: 1
+ifloat: 1
+Test "sincos (0x1p+127, &sin_res, &cos_res) puts 7.81914638714960072263910298466369236613162e-01 in cos_res":
+float: 1
+ifloat: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+idouble: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# sinh_downward
+Test "sinh_downward (22) == 1792456423.065795780701106568345764104225":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sinh_downward (23) == 4872401723.124451299966006944252978187305":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "sinh_downward (24) == 13244561064.92173614705070540368454568168":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# sinh_towardzero
+Test "sinh_towardzero (22) == 1792456423.065795780701106568345764104225":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sinh_towardzero (23) == 4872401723.124451299966006944252978187305":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "sinh_towardzero (24) == 13244561064.92173614705070540368454568168":
+float: 1
+ifloat: 1
+
+# sinh_upward
+Test "sinh_upward (22) == 1792456423.065795780701106568345764104225":
+ildouble: 1
+ldouble: 1
+Test "sinh_upward (23) == 4872401723.124451299966006944252978187305":
+ildouble: 1
+ldouble: 1
+Test "sinh_upward (24) == 13244561064.92173614705070540368454568168":
+ildouble: 1
+ldouble: 1
+
+# sqrt
+Test "sqrt (2) == M_SQRT2l":
+ildouble: 1
+ldouble: 1
+
+# tan_downward
+Test "tan_downward (1) == 1.5574077246549022305069748074583601730873":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_downward (10) == 0.6483608274590866712591249330098086768169":
+float: 1
+ifloat: 1
+Test "tan_downward (2) == -2.1850398632615189916433061023136825434320":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_downward (6) == -0.2910061913847491570536995888681755428312":
+float: 1
+ifloat: 1
+Test "tan_downward (8) == -6.7997114552203786999252627596086333648814":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_downward (9) == -0.4523156594418098405903708757987855343087":
+float: 1
+ifloat: 1
+
+# tan_towardzero
+Test "tan_towardzero (10) == 0.6483608274590866712591249330098086768169":
+float: 1
+ifloat: 1
+Test "tan_towardzero (3) == -0.1425465430742778052956354105339134932261":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_towardzero (4) == 1.1578212823495775831373424182673239231198":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_towardzero (5) == -3.3805150062465856369827058794473439087096":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_towardzero (6) == -0.2910061913847491570536995888681755428312":
+ildouble: 1
+ldouble: 1
+Test "tan_towardzero (9) == -0.4523156594418098405903708757987855343087":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# tan_upward
+Test "tan_upward (10) == 0.6483608274590866712591249330098086768169":
+ildouble: 1
+ldouble: 1
+Test "tan_upward (2) == -2.1850398632615189916433061023136825434320":
+ildouble: 1
+ldouble: 1
+Test "tan_upward (3) == -0.1425465430742778052956354105339134932261":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_upward (4) == 1.1578212823495775831373424182673239231198":
+ildouble: 1
+ldouble: 1
+Test "tan_upward (5) == -3.3805150062465856369827058794473439087096":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tan_upward (6) == -0.2910061913847491570536995888681755428312":
+ildouble: 1
+ldouble: 1
+Test "tan_upward (9) == -0.4523156594418098405903708757987855343087":
+ildouble: 1
+ldouble: 1
+
+# tanh
+Test "tanh (-0.75) == -0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (-1.0) == -0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+Test "tanh (0.75) == 0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (1.0) == 0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (4) == 6":
+ildouble: 1
+ldouble: 1
+
+# y0
+Test "y0 (0x1.3ffp+74) == 1.818984347516051243459467456433028748678e-12":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "y0 (0x1.ff00000000002p+840) == 1.846591691699331493194965158699937660696e-127":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "y0 (2.0) == 0.510375672649745119596606592727157873":
+double: 1
+idouble: 1
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "y1 (0x1.001000001p+593) == 3.927269966354206207832593635798954916263e-90":
+ildouble: 1
+ldouble: 1
+Test "y1 (0x1.27e204p+99) == -8.881610148467797208469612080785210013461e-16":
+double: 1
+idouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (0, 2.0) == 0.510375672649745119596606592727157873":
+double: 1
+idouble: 1
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 5
+ldouble: 5
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 2
+idouble: 2
+ildouble: 2
+ldouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "acos_downward":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "acos_towardzero":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "acos_upward":
+ildouble: 1
+ldouble: 1
+
+Function: "asin_downward":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "asin_towardzero":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "asin_upward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atan2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cacos":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Real part of "cacosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "casin":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+ildouble: 1
+ldouble: 1
+
+Function: "cbrt":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cexp":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cos_downward":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "cos_tonearest":
+float: 1
+ifloat: 1
+
+Function: "cos_towardzero":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "cos_upward":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "cosh_downward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cosh_tonearest":
+ildouble: 1
+ldouble: 1
+
+Function: "cosh_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cosh_upward":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 5
+idouble: 2
+ifloat: 5
+ildouble: 11
+ldouble: 11
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csqrt":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ldouble: 1
+
+Function: Imaginary part of "csqrt":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "ctan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctan_downward":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "ctan_downward":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+Function: Real part of "ctan_tonearest":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Imaginary part of "ctan_tonearest":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Real part of "ctan_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctan_towardzero":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+Function: Real part of "ctan_upward":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "ctan_upward":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 3
+ldouble: 3
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "ctanh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctanh_downward":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_downward":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Real part of "ctanh_tonearest":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Imaginary part of "ctanh_tonearest":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: Real part of "ctanh_towardzero":
+float: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+
+Function: Imaginary part of "ctanh_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctanh_upward":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 3
+ldouble: 3
+
+Function: Imaginary part of "ctanh_upward":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "exp2":
+ildouble: 1
+ldouble: 1
+
+Function: "exp_downward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp_upward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "gamma":
+ildouble: 1
+ldouble: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 4
+ldouble: 4
+
+Function: "jn":
+double: 4
+float: 5
+idouble: 4
+ifloat: 5
+ildouble: 8
+ldouble: 8
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log":
+float: 1
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log1p":
+ildouble: 1
+ldouble: 1
+
+Function: "log2":
+ildouble: 1
+ldouble: 1
+
+Function: "pow":
+float: 1
+ifloat: 1
+
+Function: "pow_downward":
+float: 1
+ifloat: 1
+
+Function: "pow_towardzero":
+float: 1
+ifloat: 1
+
+Function: "pow_upward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sin_downward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sin_tonearest":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sin_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sin_upward":
+float: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sinh_downward":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "sinh_towardzero":
+float: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+
+Function: "sinh_upward":
+ildouble: 1
+ldouble: 1
+
+Function: "sqrt":
+ildouble: 1
+ldouble: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tan_downward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "tan_towardzero":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "tan_upward":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "tanh":
+ildouble: 1
+ldouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 5
+ldouble: 5
+
+# end of automatic generation
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/memusage.h glibc/ports/sysdeps/aarch64/memusage.h
--- glibc.orig/ports/sysdeps/aarch64/memusage.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/memusage.h	2012-09-24 13:12:05.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2000, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("sp"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/Makefile glibc/ports/sysdeps/aarch64/nptl/Makefile
--- glibc.orig/ports/sysdeps/aarch64/nptl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/Makefile	2012-09-28 12:54:07.000000000 +0100
@@ -0,0 +1,21 @@
+# Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+#
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/pthread_spin_lock.c glibc/ports/sysdeps/aarch64/nptl/pthread_spin_lock.c
--- glibc.orig/ports/sysdeps/aarch64/nptl/pthread_spin_lock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/pthread_spin_lock.c	2012-09-24 13:12:34.000000000 +0100
@@ -0,0 +1,29 @@
+/* Copyright (C) 2008-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  while (atomic_compare_and_exchange_val_acq (lock, 1, 0) != 0)
+    while (*lock != 0)
+      ;
+  return 0;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/pthread_spin_trylock.c glibc/ports/sysdeps/aarch64/nptl/pthread_spin_trylock.c
--- glibc.orig/ports/sysdeps/aarch64/nptl/pthread_spin_trylock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/pthread_spin_trylock.c	2012-09-24 13:12:43.000000000 +0100
@@ -0,0 +1,27 @@
+/* Copyright (C) 2008-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  return atomic_compare_and_exchange_val_acq (lock, 1, 0) ? EBUSY : 0;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/pthreaddef.h glibc/ports/sysdeps/aarch64/nptl/pthreaddef.h
--- glibc.orig/ports/sysdeps/aarch64/nptl/pthreaddef.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/pthreaddef.h	2012-09-24 13:12:54.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002, 2003, 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  SSE requires 16
+   bytes.  */
+#define STACK_ALIGN 16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK 2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT 16
+
+/* Location of current stack frame.
+
+   __builtin_frame_address (0) returns the value of the hard frame
+   pointer, which will point at the location of the saved PC on the
+   stack.  Below this in memory is the remainder of the linkage info,
+   occupying 12 bytes.  Therefore in order to address from
+   CURRENT_STACK_FRAME using "struct layout", we need to have the macro
+   return the hard FP minus 12.  Of course, this makes no sense
+   without the obsolete APCS stack layout...  */
+#define CURRENT_STACK_FRAME	(__builtin_frame_address (0) - 12)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/tcb-offsets.sym glibc/ports/sysdeps/aarch64/nptl/tcb-offsets.sym
--- glibc.orig/ports/sysdeps/aarch64/nptl/tcb-offsets.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/tcb-offsets.sym	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,7 @@
+#include <sysdep.h>
+#include <tls.h>
+
+PTHREAD_MULTIPLE_THREADS_OFFSET		offsetof (struct pthread, header.multiple_threads)
+PTHREAD_PID_OFFSET			offsetof (struct pthread, pid)
+PTHREAD_TID_OFFSET			offsetof (struct pthread, tid)
+PTHREAD_SIZEOF				sizeof (struct pthread)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/nptl/tls.h glibc/ports/sysdeps/aarch64/nptl/tls.h
--- glibc.orig/ports/sysdeps/aarch64/nptl/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/nptl/tls.h	2012-09-24 13:13:31.000000000 +0100
@@ -0,0 +1,142 @@
+/* Copyright (C) 2005, 2007, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (tcbhead_t)
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __asm __volatile ("msr tpidr_el0, %0" : : "r" (tcbp)); 0; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) __builtin_thread_pointer ())->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *)__builtin_thread_pointer () - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (64, sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  descr->member
+#define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/preconfigure glibc/ports/sysdeps/aarch64/preconfigure
--- glibc.orig/ports/sysdeps/aarch64/preconfigure	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/preconfigure	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,14 @@
+case "$machine" in
+aarch64*)
+	base_machine=aarch64
+	machine=aarch64
+	;;
+esac
+
+case "$machine" in
+aarch64*)
+	# Parameters to allow auto-detection of -z relro.
+	libc_commonpagesize=0x1000
+	libc_relro_required=yes
+	;;
+esac
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/setjmp.S glibc/ports/sysdeps/aarch64/setjmp.S
--- glibc.orig/ports/sysdeps/aarch64/setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/setjmp.S	2012-09-24 13:13:45.000000000 +0100
@@ -0,0 +1,51 @@
+/* Copyright (C) 1997, 1998, 2008-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <jmpbuf-offsets.h>
+
+        /* Keep traditional entry points in with sigsetjmp(). */
+ENTRY (setjmp)
+	mov	x1, #1
+	b	1f
+END (setjmp)
+
+ENTRY (_setjmp)
+	mov	x1, #0
+	b	1f
+END (_setjmp)
+libc_hidden_def (_setjmp)
+
+ENTRY (__sigsetjmp)
+
+1:
+	stp	x19, x20, [x0, #JB_X19<<3]
+	stp	x21, x22, [x0, #JB_X21<<3]
+	stp	x23, x24, [x0, #JB_X23<<3]
+	stp	x25, x26, [x0, #JB_X25<<3]
+	stp	x27, x28, [x0, #JB_X27<<3]
+	stp	x29, x30, [x0, #JB_X29<<3]
+	stp	 d8,  d9, [x0, #JB_D8<<3]
+	stp	d10, d11, [x0, #JB_D10<<3]
+	stp	d12, d13, [x0, #JB_D12<<3]
+	stp	d14, d15, [x0, #JB_D14<<3]
+	mov	x1,  sp
+	str	x1,  [x0, #JB_SP<<3]
+	b	PLTJMP(C_SYMBOL_NAME(__sigjmp_save))
+END (__sigsetjmp)
+hidden_def (__sigsetjmp)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/shlib-versions glibc/ports/sysdeps/aarch64/shlib-versions
--- glibc.orig/ports/sysdeps/aarch64/shlib-versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/shlib-versions	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,2 @@
+aarch64.*-.*-linux.*	DEFAULT			GLIBC_2.16
+aarch64.*-.*-linux.*	ld=ld-linux-aarch64.so.1
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/soft-fp/Makefile glibc/ports/sysdeps/aarch64/soft-fp/Makefile
--- glibc.orig/ports/sysdeps/aarch64/soft-fp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/soft-fp/Makefile	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/soft-fp/e_sqrtl.c glibc/ports/sysdeps/aarch64/soft-fp/e_sqrtl.c
--- glibc.orig/ports/sysdeps/aarch64/soft-fp/e_sqrtl.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/soft-fp/e_sqrtl.c	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,38 @@
+/* long double square root in software floating-point emulation.
+   Copyright (C) 1997, 1999, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <soft-fp.h>
+#include <quad.h>
+
+long double
+__ieee754_sqrtl (const long double a)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(C);
+  long double c;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_Q(A, a);
+  FP_SQRT_Q(C, A);
+  FP_PACK_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+  return c;
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/soft-fp/sfp-machine.h glibc/ports/sysdeps/aarch64/soft-fp/sfp-machine.h
--- glibc.orig/ports/sysdeps/aarch64/soft-fp/sfp-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/soft-fp/sfp-machine.h	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,70 @@
+#include <fenv.h>
+#include <fpu_control.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long long
+#define _FP_WS_TYPE		signed long long
+#define _FP_I_TYPE		long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_DECL_EX		fpu_control_t _fcw
+
+#define FP_ROUNDMODE		(_fcw & 0x3)
+
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#define FP_INIT_ROUNDMODE			\
+do {						\
+  _FPU_GETCW (_fcw);				\
+} while (0)
+
+#define FP_HANDLE_EXCEPTIONS			\
+do {						\
+  if (__builtin_expect (_fex, 0))		\
+    _FPU_SETCW (_fcw | _fex | (_fex << 10));	\
+} while (0)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/stackinfo.h glibc/ports/sysdeps/aarch64/stackinfo.h
--- glibc.orig/ports/sysdeps/aarch64/stackinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/stackinfo.h	2012-09-24 13:14:11.000000000 +0100
@@ -0,0 +1,33 @@
+/* Copyright (C) 2001, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On AArch64 the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to a non-executable stack. */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W)
+
+#endif	/* stackinfo.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/start.S glibc/ports/sysdeps/aarch64/start.S
--- glibc.orig/ports/sysdeps/aarch64/start.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/start.S	2012-09-24 13:14:30.000000000 +0100
@@ -0,0 +1,94 @@
+/* Copyright (C) 1995-1998, 2001, 2002, 2005, 2008-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.
+
+   Note that the code in the .init section has already been run.
+   This includes _init and _libc_init
+
+
+   At this entry point, most registers' values are unspecified, except:
+
+   x1		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp		The stack contains the arguments and environment:
+		0(sp)			argc
+		8(sp)			argv[0]
+		...
+		(8*argc)(sp)		NULL
+		(8*(argc+1))(sp)	envp[0]
+		...
+					NULL
+ */
+
+	.text
+	.globl _start
+	.type _start,#function
+_start:
+	/* Create an initial frame with 0 LR and FP */
+	mov	x29, #0
+	mov	x30, #0
+	mov	x29, sp
+
+	/* Setup rtld_fini in argument register */
+	mov	x5, x0
+
+	/* Load argc and a pointer to argv */
+	ldr	x1, [sp, #0]
+	add	x2, sp, #8
+
+	/* Setup stack limit in argument register */
+	mov	x6, sp
+
+#ifdef SHARED
+        adrp    x0, :got:main
+	ldr     x0, [x0, #:got_lo12:main]
+
+        adrp    x3, :got:__libc_csu_init
+	ldr     x3, [x3, #:got_lo12:__libc_csu_init]
+
+        adrp    x4, :got:__libc_csu_fini
+	ldr     x4, [x4, #:got_lo12:__libc_csu_fini]
+#else
+	/* Set up the other arguments in registers */
+	ldr	x0, =main
+	ldr	x3, =__libc_csu_init
+	ldr	x4, =__libc_csu_fini
+#endif
+
+	/* __libc_start_main (main, argc, argv, init, fini, rtld_fini,
+			      stack_end) */
+
+	/* Let the libc call main and exit with its return code.  */
+	bl	__libc_start_main
+
+	/* should never get here....*/
+	bl	abort
+
+	/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/sysdep.h glibc/ports/sysdeps/aarch64/sysdep.h
--- glibc.orig/ports/sysdeps/aarch64/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/sysdep.h	2012-09-24 13:14:42.000000000 +0100
@@ -0,0 +1,65 @@
+/* Copyright (C) 1997, 1998, 2003, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/generic/sysdep.h>
+
+#ifdef	__ASSEMBLER__
+
+/* Syntactic details of assembler.  */
+
+#define ALIGNARG(log2) log2
+#define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+#define PLTJMP(_x)	_x
+
+/* Define an entry point visible from C.  */
+#define	ENTRY(name)							      \
+  .globl C_SYMBOL_NAME(name);						      \
+  .type C_SYMBOL_NAME(name),%function;					      \
+  .align ALIGNARG(4);							      \
+  C_LABEL(name)								      \
+  cfi_startproc;							      \
+  CALL_MCOUNT
+
+#undef	END
+#define END(name)							      \
+  cfi_endproc;								      \
+  ASM_SIZE_DIRECTIVE(name)
+
+/* If compiled for profiling, call `mcount' at the start of each function.  */
+#ifdef	PROF
+#define CALL_MCOUNT			\
+	str	x30, [sp, #-16]!;	\
+	bl	PLTJMP(mcount)	;	\
+	ldr	x30, [sp], #16	;
+#else
+#define CALL_MCOUNT		/* Do nothing.  */
+#endif
+
+/* Local label name for asm code.  */
+#ifndef L
+#define L(name)         .L##name
+#endif
+
+/* Since C identifiers are not normally prefixed with an underscore
+   on this system, the asm identifier `syscall_error' intrudes on the
+   C name space.  Make sure we use an innocuous name.  */
+#define	syscall_error	__syscall_error
+#define mcount		_mcount
+
+#endif	/* __ASSEMBLER__ */
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/tls-macros.h glibc/ports/sysdeps/aarch64/tls-macros.h
--- glibc.orig/ports/sysdeps/aarch64/tls-macros.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/tls-macros.h	2012-09-24 13:15:11.000000000 +0100
@@ -0,0 +1,51 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TLS_LD(x) TLS_GD(x)
+
+#define TLS_GD(x)					\
+  ({ register unsigned long __result asm ("x0");	\
+     asm ("adrp	%0, :tlsgd:" #x "; "			\
+	  "add	%0, %0, #:tlsgd_lo12:" #x "; "		\
+	  "bl	__tls_get_addr;"			\
+	  "nop"						\
+	  : "=r" (__result)				\
+	  :						\
+	  : "x1", "x2", "x3", "x4", "x5", "x6",		\
+	    "x7", "x8", "x9", "x10", "x11", "x12",	\
+	    "x13", "x14", "x15", "x16", "x17", "x18",	\
+	    "x30", "memory");				\
+     (int *) (__result); })
+
+#define TLS_IE(x)					\
+  ({ register unsigned long __result asm ("x0");	\
+     register unsigned long __t;			\
+     asm ("mrs	%1, tpidr_el0; "			\
+	  "adrp	%0, :gottprel:" #x "; "			\
+	  "ldr	%0, [%0, #:gottprel_lo12:" #x "]; "	\
+	  "add	%0, %0, %1"				\
+	  : "=r" (__result), "=r" (__t));		\
+     (int *) (__result); })
+
+#define TLS_LE(x)					\
+  ({ register unsigned long __result asm ("x0");	\
+     asm ("mrs	%0, tpidr_el0; "			\
+	  "add	%0, %0, :tprel_hi12:" #x "; "		\
+	  "add	%0, %0, :tprel_lo12_nc:" #x		\
+	  : "=r" (__result));				\
+     (int *) (__result); })
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/tlsdesc.c glibc/ports/sysdeps/aarch64/tlsdesc.c
--- glibc.orig/ports/sysdeps/aarch64/tlsdesc.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/tlsdesc.c	2012-09-24 13:15:42.000000000 +0100
@@ -0,0 +1,154 @@
+/* Manage TLS descriptors.
+   AArch64 version.
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <link.h>
+#include <ldsodefs.h>
+#include <elf/dynamic-link.h>
+#include <tls.h>
+#include <dl-tlsdesc.h>
+#include <tlsdeschtab.h>
+
+/* The following functions take an entry_check_offset argument.  It's
+   computed by the caller as an offset between its entry point and the
+   call site, such that by adding the built-in return address that is
+   implicitly passed to the function with this offset, we can easily
+   obtain the caller's entry point to compare with the entry point
+   given in the TLS descriptor.  If it's changed, we want to return
+   immediately.  */
+
+/* This function is used to lazily resolve TLS_DESC RELA relocations.
+   The argument location is used to hold a pointer to the relocation.  */
+
+void
+attribute_hidden
+_dl_tlsdesc_resolve_rela_fixup (struct tlsdesc volatile *td,
+				struct link_map *l)
+{
+  const ElfW(Rela) *reloc = td->arg;
+
+  if (_dl_tlsdesc_resolve_early_return_p
+      (td, (void*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_PLT)]) + l->l_addr)))
+    return;
+
+  /* The code below was borrowed from _dl_fixup(),
+     except for checking for STB_LOCAL.  */
+  const ElfW(Sym) *const symtab
+    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
+  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
+  const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)];
+  lookup_t result;
+
+   /* Look up the target symbol.  If the normal lookup rules are not
+      used don't look in the global scope.  */
+  if (ELFW(ST_BIND) (sym->st_info) != STB_LOCAL
+      && __builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)
+    {
+      const struct r_found_version *version = NULL;
+
+      if (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+	{
+	  const ElfW(Half) *vernum =
+	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
+	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc->r_info)] & 0x7fff;
+	  version = &l->l_versions[ndx];
+	  if (version->hash == 0)
+	    version = NULL;
+	}
+
+      result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym,
+				    l->l_scope, version, ELF_RTYPE_CLASS_PLT,
+				    DL_LOOKUP_ADD_DEPENDENCY, NULL);
+    }
+  else
+    {
+      /* We already found the symbol.  The module (and therefore its load
+	 address) is also known.  */
+      result = l;
+    }
+
+  if (!sym)
+    {
+      td->arg = (void*) reloc->r_addend;
+      td->entry = _dl_tlsdesc_undefweak;
+    }
+  else
+    {
+#  ifndef SHARED
+      CHECK_STATIC_TLS (l, result);
+#  else
+      if (!TRY_STATIC_TLS (l, result))
+	{
+	  td->arg = _dl_make_tlsdesc_dynamic (result, sym->st_value
+					      + reloc->r_addend);
+	  td->entry = _dl_tlsdesc_dynamic;
+	}
+      else
+#  endif
+	{
+	  td->arg = (void*) (sym->st_value + result->l_tls_offset
+			     + reloc->r_addend);
+	  td->entry = _dl_tlsdesc_return;
+	}
+    }
+
+  _dl_tlsdesc_wake_up_held_fixups ();
+}
+
+/* This function is used to avoid busy waiting for other threads to
+   complete the lazy relocation.  Once another thread wins the race to
+   relocate a TLS descriptor, it sets the descriptor up such that this
+   function is called to wait until the resolver releases the
+   lock.  */
+
+void
+attribute_hidden
+_dl_tlsdesc_resolve_hold_fixup (struct tlsdesc volatile *td,
+				void *caller)
+{
+  /* Maybe we're lucky and can return early.  */
+  if (caller != td->entry)
+    return;
+
+  /* Locking here will stop execution until the running resolver runs
+     _dl_tlsdesc_wake_up_held_fixups(), releasing the lock.
+
+     FIXME: We'd be better off waiting on a condition variable, such
+     that we didn't have to hold the lock throughout the relocation
+     processing.  */
+  __rtld_lock_lock_recursive (GL(dl_load_lock));
+  __rtld_lock_unlock_recursive (GL(dl_load_lock));
+}
+
+
+/* Unmap the dynamic object, but also release its TLS descriptor table
+   if there is one.  */
+
+void
+internal_function
+_dl_unmap (struct link_map *map)
+{
+  __munmap ((void *) (map)->l_map_start,
+	    (map)->l_map_end - (map)->l_map_start);
+
+#if SHARED
+  if (map->l_mach.tlsdesc_table)
+    htab_delete (map->l_mach.tlsdesc_table);
+#endif
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/tlsdesc.sym glibc/ports/sysdeps/aarch64/tlsdesc.sym
--- glibc.orig/ports/sysdeps/aarch64/tlsdesc.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/tlsdesc.sym	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,15 @@
+#include <stddef.h>
+#include <sysdep.h>
+#include <tls.h>
+#include <link.h>
+#include <dl-tlsdesc.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+
+TLSDESC_ARG			offsetof(struct tlsdesc, arg)
+
+TLSDESC_GEN_COUNT	offsetof(struct tlsdesc_dynamic_arg, gen_count)
+TLSDESC_MODID		offsetof(struct tlsdesc_dynamic_arg, tlsinfo.ti_module)
+TLSDESC_MODOFF		offsetof(struct tlsdesc_dynamic_arg, tlsinfo.ti_offset)
diff -x .git -uNr glibc.orig/ports/sysdeps/aarch64/tst-audit.h glibc/ports/sysdeps/aarch64/tst-audit.h
--- glibc.orig/ports/sysdeps/aarch64/tst-audit.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/aarch64/tst-audit.h	2012-09-24 13:15:59.000000000 +0100
@@ -0,0 +1,25 @@
+/* Definitions for testing PLT entry/exit auditing.  AArch64 version.
+
+   Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define pltenter la_aarch64_gnu_pltenter
+#define pltexit la_aarch64_gnu_pltexit
+#define La_regs La_aarch64_regs
+#define La_retval La_aarch64_retval
+#define int_retval lrv_xreg[0]
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Implies glibc/ports/sysdeps/unix/sysv/linux/aarch64/Implies
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Implies	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/Implies	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,2 @@
+unix/sysv/linux/generic
+unix/sysv/linux/wordsize-64
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Makefile glibc/ports/sysdeps/unix/sysv/linux/aarch64/Makefile
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/Makefile	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,41 @@
+ifeq ($(subdir),csu)
+sysdep_routines      += __read_tp libc-__read_tp
+static-only-routines += __read_tp
+shared-only-routines += libc-__read_tp
+
+# In order for unwinding to fail when it falls out of main, we need a
+# cantunwind marker.  There's one in start.S.  To make sure we reach it, add
+# unwind tables for __libc_start_main.
+CFLAGS-libc-start.c += -fexceptions
+endif
+
+ifeq ($(subdir),io)
+CFLAGS-creat.c += -fexceptions
+CFLAGS-open.c += -fexceptions
+CFLAGS-open64.c += -fexceptions
+endif
+
+ifeq ($(subdir),elf)
+sysdep_routines	     += dl-vdso
+sysdep-rtld-routines += __read_tp
+endif
+
+ifeq ($(subdir),misc)
+sysdep_routines += epoll_create epoll_wait inotify_init
+sysdep_headers += sys/elf.h
+CFLAGS-select.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-open.c += -fexceptions
+CFLAGS-open64.c += -fexceptions
+CFLAGS-pause.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+CFLAGS-recv.c += -fexceptions
+endif
+
+ifeq ($(subdir),stdlib)
+
+gen-as-const-headers += ucontext_i.sym
+
+endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Versions glibc/ports/sysdeps/unix/sysv/linux/aarch64/Versions
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/Versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/Versions	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,6 @@
+libc {
+  GLIBC_PRIVATE {
+    __vdso_clock_gettime;
+    __vdso_clock_getres;
+  }
+}
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/__read_tp.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/__read_tp.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/__read_tp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/__read_tp.S	2012-09-24 12:42:40.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+	.hidden __read_tp
+ENTRY (__read_tp)
+	mrs	x0, tpidr_el0
+	RET
+END   (__read_tp)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/fcntl.h	2012-09-24 12:43:27.000000000 +0100
@@ -0,0 +1,339 @@
+/* O_*, F_*, FD_* bit values for the AArch64 Linux ABI.
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+#include <bits/wordsize.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on a few file systems.  */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC	       04010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_XOPEN2K8
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_CLOEXEC     02000000 /* Set close_on_exec.  */
+#endif
+#ifdef __USE_GNU
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_NOATIME     01000000 /* Do not set atime.  */
+# define O_PATH	      010000000 /* Resolve pathname but do not open file.  */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	010000	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# if __WORDSIZE == 64
+#  define O_LARGEFILE	0
+# else
+#  define O_LARGEFILE	0400000
+# endif
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#if __WORDSIZE == 64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+/* Not necessary, we always have 64-bit offsets.  */
+# define F_GETLK64	5	/* Get record locking info.  */
+# define F_SETLK64	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	7	/* Set record locking info (blocking).	*/
+#else
+# ifndef __USE_FILE_OFFSET64
+#  define F_GETLK	5	/* Get record locking info.  */
+#  define F_SETLK	6	/* Set record locking info (non-blocking).  */
+#  define F_SETLKW	7	/* Set record locking info (blocking).	*/
+# else
+#  define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+#  define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+#  define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+# endif
+# define F_GETLK64	12	/* Get record locking info.  */
+# define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+#endif
+
+#if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K8
+# define F_SETOWN	8	/* Get owner (process receiving SIGIO).  */
+# define F_GETOWN	9	/* Set owner (process receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+# define F_SETOWN_EX	15	/* Get owner (thread receiving SIGIO).  */
+# define F_GETOWN_EX	16	/* Set owner (thread receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_SETPIPE_SZ	1031	/* Set pipe page size array.  */
+# define F_GETPIPE_SZ	1032	/* Set pipe page size array.  */
+#endif
+#ifdef __USE_XOPEN2K8
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set.  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+#ifdef __USE_GNU
+/* Owner types.  */
+enum __pid_type
+  {
+    F_OWNER_TID = 0,		/* Kernel thread.  */
+    F_OWNER_PID,		/* Process.  */
+    F_OWNER_PGRP,		/* Process group.  */
+    F_OWNER_GID = F_OWNER_PGRP	/* Alternative, obsolete name.  */
+  };
+
+/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
+struct f_owner_ex
+  {
+    enum __pid_type type;	/* Owner type of ID.  */
+    __pid_t pid;		/* ID of owner.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+
+
+/* File handle structure.  */
+struct file_handle
+{
+  unsigned int handle_bytes;
+  int handle_type;
+  /* File identifier.  */
+  unsigned char f_handle[0];
+};
+
+/* Maximum handle size (for now).  */
+# define MAX_HANDLE_SZ	128
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+/* Reserve storage for the data of the file associated with FD.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+# ifndef __USE_FILE_OFFSET64
+extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fallocate, (int __fd, int __mode, __off64_t __offset,
+				   __off64_t __len),
+		       fallocate64);
+#  else
+#   define fallocate fallocate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
+			__off64_t __len);
+# endif
+
+
+/* Map file name to file handle.  */
+extern int name_to_handle_at (int __dfd, const char *__name,
+			      struct file_handle *__handle, int *__mnt_id,
+			      int __flags) __THROW;
+
+/* Open file using the file handle.
+
+   This function is a possible cancellation point and therefore not
+   marked with __THROW.  */
+extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
+			      int __flags);
+
+#endif	/* use GNU */
+
+__END_DECLS
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/libc-vdso.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/libc-vdso.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/libc-vdso.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/libc-vdso.h	2012-09-24 12:43:51.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBC_VDSO_H
+#define _LIBC_VDSO_H
+
+#ifdef SHARED
+
+extern void (*__vdso_gettimeofday) (struct timeval *, void *)
+   attribute_hidden;
+extern void (*__vdso_clock_gettime) (clockid_t, struct timespec *);
+extern void (*__vdso_clock_getres) (clockid_t, struct timespec *);
+
+#endif
+
+#endif /* _LIBC_VDSO_H */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/mman.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/mman.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/bits/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/bits/mman.h	2012-09-24 12:44:12.000000000 +0100
@@ -0,0 +1,114 @@
+/* Definitions for POSIX memory map interface.  Linux/AArch64 version.
+   Copyright (C) 1997, 2000, 2003, 2005, 2006, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+#ifdef __USE_MISC
+/* These are Linux-specific.  */
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+# define MAP_STACK	0x20000		/* Allocation is for a stack.  */
+# define MAP_HUGETLB	0x40000		/* Create huge page mapping.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	  0	/* No further special treatment.  */
+# define MADV_RANDOM	  1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL  2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	  3	/* Will need these pages.  */
+# define MADV_DONTNEED	  4	/* Don't need these pages.  */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	  10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	  11	/* Do inherit across fork.  */
+# define MADV_MERGEABLE	  12	/* KSM may merge identical pages.  */
+# define MADV_UNMERGEABLE 13	/* KSM may not merge identical pages.  */
+# define MADV_HUGEPAGE	  14	/* Worth backing with hugepages.  */
+# define MADV_NOHUGEPAGE  15	/* Not worth backing with hugepages.  */
+# define MADV_DONTDUMP	  16	/* Explicity exclude from the core dump,
+				   overrides the coredump filter bits.  */
+# define MADV_DODUMP	  17	/* Clear the MADV_DONTDUMP flag.  */
+# define MADV_HWPOISON	  100	/* Poison a page for testing.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/clone.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/clone.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/clone.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/clone.S	2012-09-24 12:44:25.000000000 +0100
@@ -0,0 +1,99 @@
+/* Copyright (C) 1996, 1997, 1998, 1999, 2002, 2005, 2008, 2009-2012
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Pat Beirne <patb@corelcomputer.com>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+#define CLONE_VM_BIT      8
+#define CLONE_VM          (1 << CLONE_VM_BIT)
+
+#define CLONE_THREAD_BIT  16
+#define CLONE_THREAD      (1 << CLONE_THREAD_BIT)
+
+/* int clone(int (*fn)(void *arg),            x0
+	     void *child_stack,               x1
+	     int flags,                       x2
+	     void *arg,                       x3
+	     pid_t *ptid,                     x4
+	     struct user_desc *tls,           x5
+             pid_t *ctid);                    x6
+ */
+        .text
+ENTRY(__clone)
+	/* Sanity check args.  */
+	cbz	x0, 1f
+	cbz	x1, 1f
+	/* Insert the args onto the new stack.  */
+	stp	x0, x3, [x1, #-16]!	/* Fn, arg.  */
+
+	/* Do the system call.  */
+	mov	x0, x2                  /* flags  */
+
+	/* New sp is already in x1.  */
+	mov	x2, x4			/* ptid  */
+	mov	x3, x5			/* tls  */
+	mov	x4, x6			/* ctid  */
+
+#ifdef RESET_PID
+	/* We rely on the kernel preserving the argument regsiters across a
+	   each system call so that we can inspect the flags against after
+	   the clone call.  */
+	mov	x5, x0
+#endif
+
+	mov	x8, #SYS_ify(clone)
+	/* X0:flags, x1:newsp, x2:parenttidptr, x3:newtls, x4:childtid.  */
+	svc	0x0
+	cmp	x0, #0
+	beq	2f
+	blt	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+	RET
+1:	mov	x0, #-EINVAL
+	b	PLTJMP(syscall_error)
+
+2:
+#ifdef RESET_PID
+	tbnz	x5, #CLONE_THREAD_BIT, 3f
+	mov	x0, #-1
+	tbnz	x5, #CLONE_VM_BIT, 2f
+	mov	x8, #SYS_ify(getpid)
+	svc	0x0
+2:
+	mrs	x1, tpidr_el0
+	sub	x1, x1, #PTHREAD_SIZEOF
+	str	w0, [x1, #PTHREAD_PID_OFFSET]
+	str	w0, [x1, #PTHREAD_TID_OFFSET]
+
+3:
+#endif
+	/* Pick the function arg and call address from the stack and
+	   execute.  */
+	ldp	x1, x0, [sp], #16
+	blr	x1
+
+	/* We are done, pass the return value through x0.  */
+	b	PLTJMP(HIDDEN_JUMPTARGET(_exit))
+
+PSEUDO_END (__clone)
+
+weak_alias (__clone, clone)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/configure glibc/ports/sysdeps/unix/sysv/linux/aarch64/configure
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/configure	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/configure	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,3 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+
+arch_minimum_kernel=2.6.39
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/configure.in glibc/ports/sysdeps/unix/sysv/linux/aarch64/configure.in
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/configure.in	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,4 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/aarch64.
+
+arch_minimum_kernel=2.6.39
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/getcontext.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/getcontext.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/getcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/getcontext.S	2012-09-24 12:44:46.000000000 +0100
@@ -0,0 +1,105 @@
+/* Save current context.
+
+   Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include "ucontext_i.h"
+#include "ucontext-internal.h"
+
+/* int getcontext (ucontext_t *ucp)
+
+   Returns 0 on success -1 and errno on failure.
+ */
+
+	.text
+
+ENTRY(__getcontext)
+	/* The saved context will return to the getcontext() call point
+	   with a return value of 0 */
+	str	xzr,	  [x0, oX0 +  0 * SZREG]
+
+	stp	x18, x19, [x0, oX0 + 18 * SZREG]
+	stp	x20, x21, [x0, oX0 + 20 * SZREG]
+	stp	x22, x23, [x0, oX0 + 22 * SZREG]
+	stp	x24, x25, [x0, oX0 + 24 * SZREG]
+	stp	x26, x27, [x0, oX0 + 26 * SZREG]
+	stp	x28, x29, [x0, oX0 + 28 * SZREG]
+	str     x30,      [x0, oX0 + 30 * SZREG]
+
+	/* Place LR into the saved PC, this will ensure that when
+	   switching to this saved context with setcontext() control
+	   will pass back to the caller of getcontext(), we have
+	   already arrange to return the appropriate return value in x0
+	   above.  */
+	str	x30, [x0, oPC]
+
+	/* Save the current SP */
+	mov	x2, sp
+	str     x2, [x0, oSP]
+
+	/* Figure out where to place the first context extension
+	   block.  */
+	add     x2, x0, #oEXTENSION
+
+	/* Write the context extension fpsimd header.  */
+	mov	w3, #(FPSIMD_MAGIC & 0xffff)
+	movk	w3, #(FPSIMD_MAGIC >> 16), lsl #16
+	str	w3, [x2, #oHEAD + oMAGIC]
+	mov	w3, #FPSIMD_CONTEXT_SIZE
+	str	w3, [x2, #oHEAD + oSIZE]
+
+	/* Fill in the FP SIMD context.  */
+	add	x3, x2, #oV0 + 8 * SZVREG
+	stp	 d8,  d9, [x3], # 2 * SZVREG
+	stp	d10, d11, [x3], # 2 * SZVREG
+	stp	d12, d13, [x3], # 2 * SZVREG
+	stp	d14, d15, [x3], # 2 * SZVREG
+
+	add	x3, x2, oFPSR
+
+	mrs	x4, fpsr
+	str	w4, [x3]
+
+	mrs	x4, fpcr
+	str	w4, [x3, oFPCR - oFPSR]
+
+	/* Write the termination context extension header.  */
+	add	x2, x2, #FPSIMD_CONTEXT_SIZE
+
+	str	xzr, [x2, #oHEAD + oMAGIC]
+	str	xzr, [x2, #oHEAD + oSIZE]
+
+	/* Grab the signal mask */
+	/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	add	x2, x0, #UCONTEXT_SIGMASK
+	mov	x0, SIG_BLOCK
+	mov	x1, 0
+	mov	x3, _NSIG8
+	mov	x8, SYS_ify (rt_sigprocmask)
+	svc	0
+	cbnz	x0, 1f
+
+	/* Return 0 for success */
+	mov	x0, 0
+	RET
+1:
+	b	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+
+	PSEUDO_END (__getcontext)
+weak_alias (__getcontext, getcontext)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/gettimeofday.c	2012-09-24 12:44:55.000000000 +0100
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/time.h>
+
+#undef __gettimeofday
+
+#include <bits/libc-vdso.h>
+#include <bp-checks.h>
+
+/* Get the current time of day and timezone information,
+   putting it into *tv and *tz.  If tz is null, *tz is not filled.
+   Returns 0 on success, -1 on errors.  */
+int
+__gettimeofday (tv, tz)
+     struct timeval *tv;
+     struct timezone *tz;
+{
+  return INLINE_VSYSCALL (gettimeofday, 2, CHECK_1 (tv), CHECK_1 (tz));
+}
+libc_hidden_def (__gettimeofday)
+weak_alias (__gettimeofday, gettimeofday)
+libc_hidden_weak (gettimeofday)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/init-first.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/init-first.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/init-first.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/init-first.c	2012-09-24 12:45:16.000000000 +0100
@@ -0,0 +1,43 @@
+/* Copyright (C) 2007, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+# undef __gettimeofday
+# undef __clock_gettime
+# undef __clock_getres
+# include <bits/libc-vdso.h>
+
+void (*__vdso_gettimeofday) (struct timeval *, void *) attribute_hidden;
+void (*__vdso_clock_gettime) (clockid_t, struct timespec *);
+void (*__vdso_clock_getres) (clockid_t, struct timespec *);
+
+static inline void
+_libc_vdso_platform_setup (void)
+{
+  PREPARE_VERSION (linux2639, "LINUX_2.6.39", 123718537);
+
+  __vdso_gettimeofday  = _dl_vdso_vsym ("__kernel_gettimeofday",  &linux2639);
+  __vdso_clock_gettime = _dl_vdso_vsym ("__kernel_clock_gettime", &linux2639);
+  __vdso_clock_getres  = _dl_vdso_vsym ("__kernel_clock_getres",  &linux2639);
+}
+
+# define VDSO_SETUP _libc_vdso_platform_setup
+#endif
+
+#include <sysdeps/unix/sysv/linux/init-first.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ioctl.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/ioctl.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ioctl.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/ioctl.S	2012-09-24 12:45:26.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (C) 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY(__ioctl)
+	movz	x8, #__NR_ioctl
+        sxtw	x0, w0
+        svc	#0x0
+	cmn	x0, #0x1, lsl #12
+	b.hi	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+	ret
+
+	PSEUDO_END (__ioctl)
+
+weak_alias (__ioctl, ioctl)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/kernel-features.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/kernel-features.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/kernel-features.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/kernel-features.h	2012-09-24 15:06:11.000000000 +0100
@@ -0,0 +1,39 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+
+   Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <linux/version.h>
+
+/* AArch64 support starts with 2.6.39, guaranteeing many kernel
+   features.  */
+
+#define __ASSUME_ACCEPT4                1
+#define __ASSUME_DUP3                   1
+#define __ASSUME_EVENTFD2		1
+#define __ASSUME_IN_NONBLOCK            1
+#define __ASSUME_O_CLOEXEC              1
+#define __ASSUME_PIPE2                  1
+#define __ASSUME_PREAD			1
+#define __ASSUME_PWRITE			1
+#define __ASSUME_SIGNALFD4		1
+#define __ASSUME_SOCK_CLOEXEC           1
+#define __ASSUME_UTIMES                 1
+
+#include_next <kernel-features.h>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/kernel_rt_sigframe.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/kernel_rt_sigframe.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/kernel_rt_sigframe.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/kernel_rt_sigframe.h	2012-09-24 12:45:57.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This structure must have the same shape as the linux kernel
+   equivalent.  */
+struct kernel_rt_sigframe
+{
+  siginfo_t info;
+  struct ucontext uc;
+};
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ldconfig.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/ldconfig.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/ldconfig.h	2012-09-24 12:46:13.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld-linux-aarch64.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/libc-__read_tp.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/libc-__read_tp.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/libc-__read_tp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/libc-__read_tp.S	2012-09-24 12:46:17.000000000 +0100
@@ -0,0 +1,19 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <__read_tp.S>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/makecontext.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/makecontext.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/makecontext.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/makecontext.c	2012-09-24 12:46:32.000000000 +0100
@@ -0,0 +1,75 @@
+/* Create new context.
+   Copyright (C) 2002, 2004, 2005, 2008, 2011, 2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <ucontext.h>
+
+
+/* makecontext sets up a stack and the registers for the
+   user context.  The stack looks like this:
+
+               +-----------------------+
+	       | padding as required   |
+               +-----------------------+
+    sp ->      | parameter 7-n         |
+               +-----------------------+
+
+   The registers are set up like this:
+     %x0 .. %x7: parameter 1 to 8
+     %x19   : uc_link
+     %sp    : stack pointer.
+*/
+
+void
+__makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
+{
+  extern void __startcontext (void);
+  unsigned long int *sp;
+  va_list ap;
+  int i;
+
+  sp = (unsigned long int *)
+    ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+
+  /* Allocate stack arguments.  */
+  sp -= argc < 8 ? 0 : argc - 8;
+
+  /* Keep the stack aligned.  */
+  sp = (unsigned long int *) (((uintptr_t) sp) & -16L);
+
+  ucp->uc_mcontext.regs[19] = (uintptr_t) ucp->uc_link;
+  ucp->uc_mcontext.sp = (uintptr_t) sp;
+  ucp->uc_mcontext.pc = (uintptr_t) func;
+  ucp->uc_mcontext.regs[29] = (uintptr_t) 0;
+  ucp->uc_mcontext.regs[30] = (uintptr_t) &__startcontext;
+
+  va_start (ap, argc);
+  for (i = 0; i < argc; ++i)
+    if (i < 8)
+      ucp->uc_mcontext.regs[i] = va_arg (ap, unsigned long int);
+    else
+      sp[i - 8] = va_arg (ap, unsigned long int);
+
+  va_end (ap);
+}
+
+weak_alias (__makecontext, makecontext)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/mmap.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/mmap.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/mmap.c	2012-09-24 12:46:44.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <sys/syscall.h>
+#include <sysdep.h>
+#include <unistd.h>
+
+__ptr_t
+__mmap (__ptr_t addr, size_t len, int prot, int flags, int fd, off_t offset)
+{
+  return INLINE_SYSCALL (mmap, 6, addr, len, prot, flags, fd, offset);
+}
+
+weak_alias (__mmap, mmap)
+weak_alias (__mmap, mmap64)
+weak_alias (__mmap, __mmap64)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/local_lim.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/local_lim.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/local_lim.h	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,100 @@
+/* Minimum guaranteed maximum values for system limits.  Linux version.
+   Copyright (C) 1993-1998,2000,2002-2004,2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* The kernel header pollutes the namespace with the NR_OPEN symbol
+   and defines LINK_MAX although filesystems have different maxima.  A
+   similar thing is true for OPEN_MAX: the limit can be changed at
+   runtime and therefore the macro must not be defined.  Remove this
+   after including the header if necessary.  */
+#ifndef NR_OPEN
+# define __undef_NR_OPEN
+#endif
+#ifndef LINK_MAX
+# define __undef_LINK_MAX
+#endif
+#ifndef OPEN_MAX
+# define __undef_OPEN_MAX
+#endif
+#ifndef ARG_MAX
+# define __undef_ARG_MAX
+#endif
+
+/* The kernel sources contain a file with all the needed information.  */
+#include <linux/limits.h>
+
+/* Have to remove NR_OPEN?  */
+#ifdef __undef_NR_OPEN
+# undef NR_OPEN
+# undef __undef_NR_OPEN
+#endif
+/* Have to remove LINK_MAX?  */
+#ifdef __undef_LINK_MAX
+# undef LINK_MAX
+# undef __undef_LINK_MAX
+#endif
+/* Have to remove OPEN_MAX?  */
+#ifdef __undef_OPEN_MAX
+# undef OPEN_MAX
+# undef __undef_OPEN_MAX
+#endif
+/* Have to remove ARG_MAX?  */
+#ifdef __undef_ARG_MAX
+# undef ARG_MAX
+# undef __undef_ARG_MAX
+#endif
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  At least two pages for systems with 64k
+   pages.  */
+#define PTHREAD_STACK_MIN	131072
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX		32
+
+/* Maximum login name length.  This is arbitrary.  */
+#define LOGIN_NAME_MAX		256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX		64
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX		32768
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/pthreadtypes.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/pthreadtypes.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/pthreadtypes.h	2012-09-24 12:47:13.000000000 +0100
@@ -0,0 +1,170 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#define __SIZEOF_PTHREAD_ATTR_T        64
+#define __SIZEOF_PTHREAD_MUTEX_T       48
+#define __SIZEOF_PTHREAD_MUTEXATTR_T    8
+#define __SIZEOF_PTHREAD_COND_T        48
+#define __SIZEOF_PTHREAD_COND_COMPAT_T 48
+#define __SIZEOF_PTHREAD_CONDATTR_T     8
+#define __SIZEOF_PTHREAD_RWLOCK_T      56
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T   8
+#define __SIZEOF_PTHREAD_BARRIER_T     32
+#define __SIZEOF_PTHREAD_BARRIERATTR_T  8
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+union pthread_attr_t
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+};
+#ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+# define __have_pthread_attr_t1
+#endif
+
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    unsigned int __nusers;
+    int __kind;
+    int __spins;
+    __pthread_list_t __list;
+#define __PTHREAD_MUTEX_HAVE_PREV	1
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  long int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    unsigned int __flags;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+#endif	/* bits/pthreadtypes.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/semaphore.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/semaphore.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/bits/semaphore.h	2012-09-24 12:47:32.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002, 2005, 2007, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	32
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/c++-types.data glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/c++-types.data
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/c++-types.data	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/c++-types.data	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,67 @@
+blkcnt64_t:l
+blkcnt_t:l
+blksize_t:i
+caddr_t:Pc
+clockid_t:i
+clock_t:l
+daddr_t:i
+dev_t:m
+fd_mask:l
+fsblkcnt64_t:m
+fsblkcnt_t:m
+fsfilcnt64_t:m
+fsfilcnt_t:m
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:m
+ino_t:m
+int16_t:s
+int32_t:i
+int64_t:l
+int8_t:a
+intptr_t:l
+key_t:i
+loff_t:l
+mode_t:j
+nlink_t:j
+off64_t:l
+off_t:l
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:l
+register_t:l
+rlim64_t:m
+rlim_t:m
+sigset_t:10__sigset_t
+size_t:m
+socklen_t:j
+ssize_t:l
+suseconds_t:l
+time_t:l
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:m
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:m
+useconds_t:j
+ushort:t
+u_short:t
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/clone.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/clone.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/clone.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/clone.S	2012-09-24 12:47:49.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define RESET_PID
+#include <tcb-offsets.h>
+#include "../clone.S"
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/createthread.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/createthread.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/createthread.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/createthread.c	2012-09-24 12:47:59.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE (pd + 1)
+
+/* Get the real implementation.	 */
+#include <sysdeps/pthread/createthread.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/fork.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/fork.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/fork.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/fork.c	2012-09-24 12:48:11.000000000 +0100
@@ -0,0 +1,30 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Phil Blundell <pb@nexus.co.uk>, 2005
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+
+
+#define ARCH_FORK()							\
+  INLINE_SYSCALL (clone, 5,						\
+		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
+		  NULL, NULL, NULL, &THREAD_SELF->tid)
+
+#include <sysdeps/unix/sysv/linux/fork.c>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/ld.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/ld.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/ld.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/ld.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,12 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ __libc_memalign F
+ __libc_stack_end D 0x8
+ __stack_chk_guard D 0x8
+ __tls_get_addr F
+ _dl_mcount F
+ _r_debug D 0x28
+ calloc F
+ free F
+ malloc F
+ realloc F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libBrokenLocale.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libBrokenLocale.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libBrokenLocale.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libBrokenLocale.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,3 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ __ctype_get_mb_cur_max F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libanl.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libanl.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libanl.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libanl.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,6 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ gai_cancel F
+ gai_error F
+ gai_suspend F
+ getaddrinfo_a F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libc.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libc.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libc.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libc.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,2079 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ _Exit F
+ _IO_2_1_stderr_ D 0xe0
+ _IO_2_1_stdin_ D 0xe0
+ _IO_2_1_stdout_ D 0xe0
+ _IO_adjust_column F
+ _IO_adjust_wcolumn F
+ _IO_default_doallocate F
+ _IO_default_finish F
+ _IO_default_pbackfail F
+ _IO_default_uflow F
+ _IO_default_xsgetn F
+ _IO_default_xsputn F
+ _IO_do_write F
+ _IO_doallocbuf F
+ _IO_fclose F
+ _IO_fdopen F
+ _IO_feof F
+ _IO_ferror F
+ _IO_fflush F
+ _IO_fgetpos F
+ _IO_fgetpos64 F
+ _IO_fgets F
+ _IO_file_attach F
+ _IO_file_close F
+ _IO_file_close_it F
+ _IO_file_doallocate F
+ _IO_file_finish F
+ _IO_file_fopen F
+ _IO_file_init F
+ _IO_file_jumps D 0xa8
+ _IO_file_open F
+ _IO_file_overflow F
+ _IO_file_read F
+ _IO_file_seek F
+ _IO_file_seekoff F
+ _IO_file_setbuf F
+ _IO_file_stat F
+ _IO_file_sync F
+ _IO_file_underflow F
+ _IO_file_write F
+ _IO_file_xsputn F
+ _IO_flockfile F
+ _IO_flush_all F
+ _IO_flush_all_linebuffered F
+ _IO_fopen F
+ _IO_fprintf F
+ _IO_fputs F
+ _IO_fread F
+ _IO_free_backup_area F
+ _IO_free_wbackup_area F
+ _IO_fsetpos F
+ _IO_fsetpos64 F
+ _IO_ftell F
+ _IO_ftrylockfile F
+ _IO_funlockfile F
+ _IO_fwrite F
+ _IO_getc F
+ _IO_getline F
+ _IO_getline_info F
+ _IO_gets F
+ _IO_init F
+ _IO_init_marker F
+ _IO_init_wmarker F
+ _IO_iter_begin F
+ _IO_iter_end F
+ _IO_iter_file F
+ _IO_iter_next F
+ _IO_least_wmarker F
+ _IO_link_in F
+ _IO_list_all D 0x8
+ _IO_list_lock F
+ _IO_list_resetlock F
+ _IO_list_unlock F
+ _IO_marker_delta F
+ _IO_marker_difference F
+ _IO_padn F
+ _IO_peekc_locked F
+ _IO_popen F
+ _IO_printf F
+ _IO_proc_close F
+ _IO_proc_open F
+ _IO_putc F
+ _IO_puts F
+ _IO_remove_marker F
+ _IO_seekmark F
+ _IO_seekoff F
+ _IO_seekpos F
+ _IO_seekwmark F
+ _IO_setb F
+ _IO_setbuffer F
+ _IO_setvbuf F
+ _IO_sgetn F
+ _IO_sprintf F
+ _IO_sputbackc F
+ _IO_sputbackwc F
+ _IO_sscanf F
+ _IO_str_init_readonly F
+ _IO_str_init_static F
+ _IO_str_overflow F
+ _IO_str_pbackfail F
+ _IO_str_seekoff F
+ _IO_str_underflow F
+ _IO_sungetc F
+ _IO_sungetwc F
+ _IO_switch_to_get_mode F
+ _IO_switch_to_main_wget_area F
+ _IO_switch_to_wbackup_area F
+ _IO_switch_to_wget_mode F
+ _IO_un_link F
+ _IO_ungetc F
+ _IO_unsave_markers F
+ _IO_unsave_wmarkers F
+ _IO_vfprintf F
+ _IO_vfscanf F
+ _IO_vsprintf F
+ _IO_wdefault_doallocate F
+ _IO_wdefault_finish F
+ _IO_wdefault_pbackfail F
+ _IO_wdefault_uflow F
+ _IO_wdefault_xsgetn F
+ _IO_wdefault_xsputn F
+ _IO_wdo_write F
+ _IO_wdoallocbuf F
+ _IO_wfile_jumps D 0xa8
+ _IO_wfile_overflow F
+ _IO_wfile_seekoff F
+ _IO_wfile_sync F
+ _IO_wfile_underflow F
+ _IO_wfile_xsputn F
+ _IO_wmarker_delta F
+ _IO_wsetb F
+ ___brk_addr D 0x8
+ __adjtimex F
+ __after_morecore_hook D 0x8
+ __argz_count F
+ __argz_next F
+ __argz_stringify F
+ __asprintf F
+ __asprintf_chk F
+ __assert F
+ __assert_fail F
+ __assert_perror_fail F
+ __backtrace F
+ __backtrace_symbols F
+ __backtrace_symbols_fd F
+ __bsd_getpgrp F
+ __bzero F
+ __check_rhosts_file D 0x4
+ __chk_fail F
+ __clone F
+ __close F
+ __cmsg_nxthdr F
+ __confstr_chk F
+ __connect F
+ __ctype_b_loc F
+ __ctype_get_mb_cur_max F
+ __ctype_tolower_loc F
+ __ctype_toupper_loc F
+ __curbrk D 0x8
+ __cxa_at_quick_exit F
+ __cxa_atexit F
+ __cxa_finalize F
+ __cyg_profile_func_enter F
+ __cyg_profile_func_exit F
+ __daylight D 0x4
+ __dcgettext F
+ __default_morecore F
+ __dgettext F
+ __dprintf_chk F
+ __dup2 F
+ __duplocale F
+ __endmntent F
+ __environ D 0x8
+ __errno_location F
+ __fbufsize F
+ __fcntl F
+ __fdelt_chk F
+ __fdelt_warn F
+ __ffs F
+ __fgets_chk F
+ __fgets_unlocked_chk F
+ __fgetws_chk F
+ __fgetws_unlocked_chk F
+ __finite F
+ __finitef F
+ __finitel F
+ __flbf F
+ __fork F
+ __fpending F
+ __fprintf_chk F
+ __fpu_control D 0x4
+ __fpurge F
+ __fread_chk F
+ __fread_unlocked_chk F
+ __freadable F
+ __freading F
+ __free_hook D 0x8
+ __freelocale F
+ __fsetlocking F
+ __fwprintf_chk F
+ __fwritable F
+ __fwriting F
+ __fxstat F
+ __fxstat64 F
+ __fxstatat F
+ __fxstatat64 F
+ __getauxval F
+ __getcwd_chk F
+ __getdelim F
+ __getdomainname_chk F
+ __getgroups_chk F
+ __gethostname_chk F
+ __getlogin_r_chk F
+ __getmntent_r F
+ __getpagesize F
+ __getpgid F
+ __getpid F
+ __gets_chk F
+ __gettimeofday F
+ __getwd_chk F
+ __gmtime_r F
+ __h_errno_location F
+ __isalnum_l F
+ __isalpha_l F
+ __isascii_l F
+ __isblank_l F
+ __iscntrl_l F
+ __isctype F
+ __isdigit_l F
+ __isgraph_l F
+ __isinf F
+ __isinff F
+ __isinfl F
+ __islower_l F
+ __isnan F
+ __isnanf F
+ __isnanl F
+ __isoc99_fscanf F
+ __isoc99_fwscanf F
+ __isoc99_scanf F
+ __isoc99_sscanf F
+ __isoc99_swscanf F
+ __isoc99_vfscanf F
+ __isoc99_vfwscanf F
+ __isoc99_vscanf F
+ __isoc99_vsscanf F
+ __isoc99_vswscanf F
+ __isoc99_vwscanf F
+ __isoc99_wscanf F
+ __isprint_l F
+ __ispunct_l F
+ __isspace_l F
+ __isupper_l F
+ __iswalnum_l F
+ __iswalpha_l F
+ __iswblank_l F
+ __iswcntrl_l F
+ __iswctype F
+ __iswctype_l F
+ __iswdigit_l F
+ __iswgraph_l F
+ __iswlower_l F
+ __iswprint_l F
+ __iswpunct_l F
+ __iswspace_l F
+ __iswupper_l F
+ __iswxdigit_l F
+ __isxdigit_l F
+ __ivaliduser F
+ __key_decryptsession_pk_LOCAL D 0x8
+ __key_encryptsession_pk_LOCAL D 0x8
+ __key_gendes_LOCAL D 0x8
+ __libc_allocate_rtsig F
+ __libc_calloc F
+ __libc_current_sigrtmax F
+ __libc_current_sigrtmin F
+ __libc_free F
+ __libc_freeres F
+ __libc_init_first F
+ __libc_mallinfo F
+ __libc_malloc F
+ __libc_mallopt F
+ __libc_memalign F
+ __libc_pvalloc F
+ __libc_realloc F
+ __libc_sa_len F
+ __libc_start_main F
+ __libc_valloc F
+ __longjmp_chk F
+ __lseek F
+ __lxstat F
+ __lxstat64 F
+ __malloc_hook D 0x8
+ __malloc_initialize_hook D 0x8
+ __mbrlen F
+ __mbrtowc F
+ __mbsnrtowcs_chk F
+ __mbsrtowcs_chk F
+ __mbstowcs_chk F
+ __memalign_hook D 0x8
+ __memcpy_chk F
+ __memmove_chk F
+ __mempcpy F
+ __mempcpy_chk F
+ __mempcpy_small F
+ __memset_chk F
+ __monstartup F
+ __morecore D 0x8
+ __nanosleep F
+ __newlocale F
+ __nl_langinfo_l F
+ __nss_configure_lookup F
+ __nss_database_lookup F
+ __nss_group_lookup F
+ __nss_hostname_digits_dots F
+ __nss_hosts_lookup F
+ __nss_next F
+ __nss_passwd_lookup F
+ __obstack_printf_chk F
+ __obstack_vprintf_chk F
+ __open F
+ __open64 F
+ __open64_2 F
+ __open_2 F
+ __openat64_2 F
+ __openat_2 F
+ __overflow F
+ __pipe F
+ __poll F
+ __poll_chk F
+ __posix_getopt F
+ __ppoll_chk F
+ __pread64 F
+ __pread64_chk F
+ __pread_chk F
+ __printf_chk F
+ __printf_fp F
+ __profile_frequency F
+ __progname D 0x8
+ __progname_full D 0x8
+ __ptsname_r_chk F
+ __pwrite64 F
+ __rawmemchr F
+ __rcmd_errstr D 0x8
+ __read F
+ __read_chk F
+ __readlink_chk F
+ __readlinkat_chk F
+ __realloc_hook D 0x8
+ __realpath_chk F
+ __recv_chk F
+ __recvfrom_chk F
+ __register_atfork F
+ __res_init F
+ __res_nclose F
+ __res_ninit F
+ __res_randomid F
+ __res_state F
+ __rpc_thread_createerr F
+ __rpc_thread_svc_fdset F
+ __rpc_thread_svc_max_pollfd F
+ __rpc_thread_svc_pollfd F
+ __sbrk F
+ __sched_cpualloc F
+ __sched_cpucount F
+ __sched_cpufree F
+ __sched_get_priority_max F
+ __sched_get_priority_min F
+ __sched_getparam F
+ __sched_getscheduler F
+ __sched_setscheduler F
+ __sched_yield F
+ __secure_getenv F
+ __select F
+ __setmntent F
+ __setpgid F
+ __sigaction F
+ __sigaddset F
+ __sigdelset F
+ __sigismember F
+ __signbit F
+ __signbitf F
+ __signbitl F
+ __sigpause F
+ __sigsetjmp F
+ __sigsuspend F
+ __snprintf_chk F
+ __sprintf_chk F
+ __stack_chk_fail F
+ __statfs F
+ __stpcpy F
+ __stpcpy_chk F
+ __stpcpy_small F
+ __stpncpy F
+ __stpncpy_chk F
+ __strcasecmp F
+ __strcasecmp_l F
+ __strcasestr F
+ __strcat_chk F
+ __strcoll_l F
+ __strcpy_chk F
+ __strcpy_small F
+ __strcspn_c1 F
+ __strcspn_c2 F
+ __strcspn_c3 F
+ __strdup F
+ __strerror_r F
+ __strfmon_l F
+ __strftime_l F
+ __strncasecmp_l F
+ __strncat_chk F
+ __strncpy_chk F
+ __strndup F
+ __strpbrk_c2 F
+ __strpbrk_c3 F
+ __strsep_1c F
+ __strsep_2c F
+ __strsep_3c F
+ __strsep_g F
+ __strspn_c1 F
+ __strspn_c2 F
+ __strspn_c3 F
+ __strtod_internal F
+ __strtod_l F
+ __strtof_internal F
+ __strtof_l F
+ __strtok_r F
+ __strtok_r_1c F
+ __strtol_internal F
+ __strtol_l F
+ __strtold_internal F
+ __strtold_l F
+ __strtoll_internal F
+ __strtoll_l F
+ __strtoul_internal F
+ __strtoul_l F
+ __strtoull_internal F
+ __strtoull_l F
+ __strverscmp F
+ __strxfrm_l F
+ __swprintf_chk F
+ __sysconf F
+ __syslog_chk F
+ __sysv_signal F
+ __timezone D 0x8
+ __toascii_l F
+ __tolower_l F
+ __toupper_l F
+ __towctrans F
+ __towctrans_l F
+ __towlower_l F
+ __towupper_l F
+ __ttyname_r_chk F
+ __tzname D 0x10
+ __uflow F
+ __underflow F
+ __uselocale F
+ __vasprintf_chk F
+ __vdprintf_chk F
+ __vfork F
+ __vfprintf_chk F
+ __vfscanf F
+ __vfwprintf_chk F
+ __vprintf_chk F
+ __vsnprintf F
+ __vsnprintf_chk F
+ __vsprintf_chk F
+ __vsscanf F
+ __vswprintf_chk F
+ __vsyslog_chk F
+ __vwprintf_chk F
+ __wait F
+ __waitpid F
+ __wcpcpy_chk F
+ __wcpncpy_chk F
+ __wcrtomb_chk F
+ __wcscasecmp_l F
+ __wcscat_chk F
+ __wcscoll_l F
+ __wcscpy_chk F
+ __wcsftime_l F
+ __wcsncasecmp_l F
+ __wcsncat_chk F
+ __wcsncpy_chk F
+ __wcsnrtombs_chk F
+ __wcsrtombs_chk F
+ __wcstod_internal F
+ __wcstod_l F
+ __wcstof_internal F
+ __wcstof_l F
+ __wcstol_internal F
+ __wcstol_l F
+ __wcstold_internal F
+ __wcstold_l F
+ __wcstoll_internal F
+ __wcstoll_l F
+ __wcstombs_chk F
+ __wcstoul_internal F
+ __wcstoul_l F
+ __wcstoull_internal F
+ __wcstoull_l F
+ __wcsxfrm_l F
+ __wctomb_chk F
+ __wctrans_l F
+ __wctype_l F
+ __wmemcpy_chk F
+ __wmemmove_chk F
+ __wmempcpy_chk F
+ __wmemset_chk F
+ __woverflow F
+ __wprintf_chk F
+ __write F
+ __wuflow F
+ __wunderflow F
+ __xmknod F
+ __xmknodat F
+ __xpg_basename F
+ __xpg_sigpause F
+ __xpg_strerror_r F
+ __xstat F
+ __xstat64 F
+ _authenticate F
+ _dl_mcount_wrapper F
+ _dl_mcount_wrapper_check F
+ _environ D 0x8
+ _exit F
+ _flushlbf F
+ _libc_intl_domainname D 0x5
+ _longjmp F
+ _mcleanup F
+ _mcount F
+ _nl_default_dirname D 0x12
+ _nl_domain_bindings D 0x8
+ _nl_msg_cat_cntr D 0x4
+ _null_auth D 0x18
+ _obstack_allocated_p F
+ _obstack_begin F
+ _obstack_begin_1 F
+ _obstack_free F
+ _obstack_memory_used F
+ _obstack_newchunk F
+ _res D 0x238
+ _res_hconf D 0x48
+ _rpc_dtablesize F
+ _seterr_reply F
+ _setjmp F
+ _sys_errlist D 0x438
+ _sys_nerr D 0x4
+ _sys_siglist D 0x208
+ _tolower F
+ _toupper F
+ a64l F
+ abort F
+ abs F
+ accept F
+ accept4 F
+ access F
+ acct F
+ addmntent F
+ addseverity F
+ adjtime F
+ adjtimex F
+ advance F
+ alarm F
+ aligned_alloc F
+ alphasort F
+ alphasort64 F
+ argp_err_exit_status D 0x4
+ argp_error F
+ argp_failure F
+ argp_help F
+ argp_parse F
+ argp_program_bug_address D 0x8
+ argp_program_version D 0x8
+ argp_program_version_hook D 0x8
+ argp_state_help F
+ argp_usage F
+ argz_add F
+ argz_add_sep F
+ argz_append F
+ argz_count F
+ argz_create F
+ argz_create_sep F
+ argz_delete F
+ argz_extract F
+ argz_insert F
+ argz_next F
+ argz_replace F
+ argz_stringify F
+ asctime F
+ asctime_r F
+ asprintf F
+ atof F
+ atoi F
+ atol F
+ atoll F
+ authdes_create F
+ authdes_getucred F
+ authdes_pk_create F
+ authnone_create F
+ authunix_create F
+ authunix_create_default F
+ backtrace F
+ backtrace_symbols F
+ backtrace_symbols_fd F
+ basename F
+ bcmp F
+ bcopy F
+ bdflush F
+ bind F
+ bind_textdomain_codeset F
+ bindresvport F
+ bindtextdomain F
+ brk F
+ bsd_signal F
+ bsearch F
+ btowc F
+ bzero F
+ c16rtomb F
+ c32rtomb F
+ calloc F
+ callrpc F
+ canonicalize_file_name F
+ capget F
+ capset F
+ catclose F
+ catgets F
+ catopen F
+ cbc_crypt F
+ cfgetispeed F
+ cfgetospeed F
+ cfmakeraw F
+ cfree F
+ cfsetispeed F
+ cfsetospeed F
+ cfsetspeed F
+ chdir F
+ chflags F
+ chmod F
+ chown F
+ chroot F
+ clearenv F
+ clearerr F
+ clearerr_unlocked F
+ clnt_broadcast F
+ clnt_create F
+ clnt_pcreateerror F
+ clnt_perrno F
+ clnt_perror F
+ clnt_spcreateerror F
+ clnt_sperrno F
+ clnt_sperror F
+ clntraw_create F
+ clnttcp_create F
+ clntudp_bufcreate F
+ clntudp_create F
+ clntunix_create F
+ clock F
+ clock_adjtime F
+ clone F
+ close F
+ closedir F
+ closelog F
+ confstr F
+ connect F
+ copysign F
+ copysignf F
+ copysignl F
+ creat F
+ creat64 F
+ create_module F
+ ctermid F
+ ctime F
+ ctime_r F
+ cuserid F
+ daemon F
+ daylight D 0x4
+ dcgettext F
+ dcngettext F
+ delete_module F
+ des_setparity F
+ dgettext F
+ difftime F
+ dirfd F
+ dirname F
+ div F
+ dl_iterate_phdr F
+ dngettext F
+ dprintf F
+ drand48 F
+ drand48_r F
+ dup F
+ dup2 F
+ dup3 F
+ duplocale F
+ dysize F
+ eaccess F
+ ecb_crypt F
+ ecvt F
+ ecvt_r F
+ endaliasent F
+ endfsent F
+ endgrent F
+ endhostent F
+ endmntent F
+ endnetent F
+ endnetgrent F
+ endprotoent F
+ endpwent F
+ endrpcent F
+ endservent F
+ endsgent F
+ endspent F
+ endttyent F
+ endusershell F
+ endutent F
+ endutxent F
+ environ D 0x8
+ envz_add F
+ envz_entry F
+ envz_get F
+ envz_merge F
+ envz_remove F
+ envz_strip F
+ epoll_create F
+ epoll_create1 F
+ epoll_ctl F
+ epoll_pwait F
+ epoll_wait F
+ erand48 F
+ erand48_r F
+ err F
+ error F
+ error_at_line F
+ error_message_count D 0x4
+ error_one_per_line D 0x4
+ error_print_progname D 0x8
+ errx F
+ ether_aton F
+ ether_aton_r F
+ ether_hostton F
+ ether_line F
+ ether_ntoa F
+ ether_ntoa_r F
+ ether_ntohost F
+ euidaccess F
+ eventfd F
+ eventfd_read F
+ eventfd_write F
+ execl F
+ execle F
+ execlp F
+ execv F
+ execve F
+ execvp F
+ execvpe F
+ exit F
+ faccessat F
+ fallocate F
+ fallocate64 F
+ fanotify_init F
+ fanotify_mark F
+ fattach F
+ fchdir F
+ fchflags F
+ fchmod F
+ fchmodat F
+ fchown F
+ fchownat F
+ fclose F
+ fcloseall F
+ fcntl F
+ fcvt F
+ fcvt_r F
+ fdatasync F
+ fdetach F
+ fdopen F
+ fdopendir F
+ feof F
+ feof_unlocked F
+ ferror F
+ ferror_unlocked F
+ fexecve F
+ fflush F
+ fflush_unlocked F
+ ffs F
+ ffsl F
+ ffsll F
+ fgetc F
+ fgetc_unlocked F
+ fgetgrent F
+ fgetgrent_r F
+ fgetpos F
+ fgetpos64 F
+ fgetpwent F
+ fgetpwent_r F
+ fgets F
+ fgets_unlocked F
+ fgetsgent F
+ fgetsgent_r F
+ fgetspent F
+ fgetspent_r F
+ fgetwc F
+ fgetwc_unlocked F
+ fgetws F
+ fgetws_unlocked F
+ fgetxattr F
+ fileno F
+ fileno_unlocked F
+ finite F
+ finitef F
+ finitel F
+ flistxattr F
+ flock F
+ flockfile F
+ fmemopen F
+ fmtmsg F
+ fnmatch F
+ fopen F
+ fopen64 F
+ fopencookie F
+ fork F
+ fpathconf F
+ fprintf F
+ fputc F
+ fputc_unlocked F
+ fputs F
+ fputs_unlocked F
+ fputwc F
+ fputwc_unlocked F
+ fputws F
+ fputws_unlocked F
+ fread F
+ fread_unlocked F
+ free F
+ freeaddrinfo F
+ freeifaddrs F
+ freelocale F
+ fremovexattr F
+ freopen F
+ freopen64 F
+ frexp F
+ frexpf F
+ frexpl F
+ fscanf F
+ fseek F
+ fseeko F
+ fseeko64 F
+ fsetpos F
+ fsetpos64 F
+ fsetxattr F
+ fstatfs F
+ fstatfs64 F
+ fstatvfs F
+ fstatvfs64 F
+ fsync F
+ ftell F
+ ftello F
+ ftello64 F
+ ftime F
+ ftok F
+ ftruncate F
+ ftruncate64 F
+ ftrylockfile F
+ fts_children F
+ fts_close F
+ fts_open F
+ fts_read F
+ fts_set F
+ ftw F
+ ftw64 F
+ funlockfile F
+ futimens F
+ futimes F
+ futimesat F
+ fwide F
+ fwprintf F
+ fwrite F
+ fwrite_unlocked F
+ fwscanf F
+ gai_strerror F
+ gcvt F
+ get_avphys_pages F
+ get_current_dir_name F
+ get_kernel_syms F
+ get_myaddress F
+ get_nprocs F
+ get_nprocs_conf F
+ get_phys_pages F
+ getaddrinfo F
+ getaliasbyname F
+ getaliasbyname_r F
+ getaliasent F
+ getaliasent_r F
+ getauxval F
+ getc F
+ getc_unlocked F
+ getchar F
+ getchar_unlocked F
+ getcontext F
+ getcwd F
+ getdate F
+ getdate_err D 0x4
+ getdate_r F
+ getdelim F
+ getdirentries F
+ getdirentries64 F
+ getdomainname F
+ getdtablesize F
+ getegid F
+ getenv F
+ geteuid F
+ getfsent F
+ getfsfile F
+ getfsspec F
+ getgid F
+ getgrent F
+ getgrent_r F
+ getgrgid F
+ getgrgid_r F
+ getgrnam F
+ getgrnam_r F
+ getgrouplist F
+ getgroups F
+ gethostbyaddr F
+ gethostbyaddr_r F
+ gethostbyname F
+ gethostbyname2 F
+ gethostbyname2_r F
+ gethostbyname_r F
+ gethostent F
+ gethostent_r F
+ gethostid F
+ gethostname F
+ getifaddrs F
+ getipv4sourcefilter F
+ getitimer F
+ getline F
+ getloadavg F
+ getlogin F
+ getlogin_r F
+ getmntent F
+ getmntent_r F
+ getmsg F
+ getnameinfo F
+ getnetbyaddr F
+ getnetbyaddr_r F
+ getnetbyname F
+ getnetbyname_r F
+ getnetent F
+ getnetent_r F
+ getnetgrent F
+ getnetgrent_r F
+ getnetname F
+ getopt F
+ getopt_long F
+ getopt_long_only F
+ getpagesize F
+ getpass F
+ getpeername F
+ getpgid F
+ getpgrp F
+ getpid F
+ getpmsg F
+ getppid F
+ getpriority F
+ getprotobyname F
+ getprotobyname_r F
+ getprotobynumber F
+ getprotobynumber_r F
+ getprotoent F
+ getprotoent_r F
+ getpt F
+ getpublickey F
+ getpw F
+ getpwent F
+ getpwent_r F
+ getpwnam F
+ getpwnam_r F
+ getpwuid F
+ getpwuid_r F
+ getresgid F
+ getresuid F
+ getrlimit F
+ getrlimit64 F
+ getrpcbyname F
+ getrpcbyname_r F
+ getrpcbynumber F
+ getrpcbynumber_r F
+ getrpcent F
+ getrpcent_r F
+ getrpcport F
+ getrusage F
+ gets F
+ getsecretkey F
+ getservbyname F
+ getservbyname_r F
+ getservbyport F
+ getservbyport_r F
+ getservent F
+ getservent_r F
+ getsgent F
+ getsgent_r F
+ getsgnam F
+ getsgnam_r F
+ getsid F
+ getsockname F
+ getsockopt F
+ getsourcefilter F
+ getspent F
+ getspent_r F
+ getspnam F
+ getspnam_r F
+ getsubopt F
+ gettext F
+ gettimeofday F
+ getttyent F
+ getttynam F
+ getuid F
+ getusershell F
+ getutent F
+ getutent_r F
+ getutid F
+ getutid_r F
+ getutline F
+ getutline_r F
+ getutmp F
+ getutmpx F
+ getutxent F
+ getutxid F
+ getutxline F
+ getw F
+ getwc F
+ getwc_unlocked F
+ getwchar F
+ getwchar_unlocked F
+ getwd F
+ getxattr F
+ glob F
+ glob64 F
+ glob_pattern_p F
+ globfree F
+ globfree64 F
+ gmtime F
+ gmtime_r F
+ gnu_dev_major F
+ gnu_dev_makedev F
+ gnu_dev_minor F
+ gnu_get_libc_release F
+ gnu_get_libc_version F
+ grantpt F
+ group_member F
+ gsignal F
+ gtty F
+ h_errlist D 0x28
+ h_nerr D 0x4
+ hasmntopt F
+ hcreate F
+ hcreate_r F
+ hdestroy F
+ hdestroy_r F
+ herror F
+ host2netname F
+ hsearch F
+ hsearch_r F
+ hstrerror F
+ htonl F
+ htons F
+ iconv F
+ iconv_close F
+ iconv_open F
+ if_freenameindex F
+ if_indextoname F
+ if_nameindex F
+ if_nametoindex F
+ imaxabs F
+ imaxdiv F
+ in6addr_any D 0x10
+ in6addr_loopback D 0x10
+ index F
+ inet6_opt_append F
+ inet6_opt_find F
+ inet6_opt_finish F
+ inet6_opt_get_val F
+ inet6_opt_init F
+ inet6_opt_next F
+ inet6_opt_set_val F
+ inet6_option_alloc F
+ inet6_option_append F
+ inet6_option_find F
+ inet6_option_init F
+ inet6_option_next F
+ inet6_option_space F
+ inet6_rth_add F
+ inet6_rth_getaddr F
+ inet6_rth_init F
+ inet6_rth_reverse F
+ inet6_rth_segments F
+ inet6_rth_space F
+ inet_addr F
+ inet_aton F
+ inet_lnaof F
+ inet_makeaddr F
+ inet_netof F
+ inet_network F
+ inet_nsap_addr F
+ inet_nsap_ntoa F
+ inet_ntoa F
+ inet_ntop F
+ inet_pton F
+ init_module F
+ initgroups F
+ initstate F
+ initstate_r F
+ innetgr F
+ inotify_add_watch F
+ inotify_init F
+ inotify_init1 F
+ inotify_rm_watch F
+ insque F
+ ioctl F
+ iruserok F
+ iruserok_af F
+ isalnum F
+ isalnum_l F
+ isalpha F
+ isalpha_l F
+ isascii F
+ isastream F
+ isatty F
+ isblank F
+ isblank_l F
+ iscntrl F
+ iscntrl_l F
+ isctype F
+ isdigit F
+ isdigit_l F
+ isfdtype F
+ isgraph F
+ isgraph_l F
+ isinf F
+ isinff F
+ isinfl F
+ islower F
+ islower_l F
+ isnan F
+ isnanf F
+ isnanl F
+ isprint F
+ isprint_l F
+ ispunct F
+ ispunct_l F
+ isspace F
+ isspace_l F
+ isupper F
+ isupper_l F
+ iswalnum F
+ iswalnum_l F
+ iswalpha F
+ iswalpha_l F
+ iswblank F
+ iswblank_l F
+ iswcntrl F
+ iswcntrl_l F
+ iswctype F
+ iswctype_l F
+ iswdigit F
+ iswdigit_l F
+ iswgraph F
+ iswgraph_l F
+ iswlower F
+ iswlower_l F
+ iswprint F
+ iswprint_l F
+ iswpunct F
+ iswpunct_l F
+ iswspace F
+ iswspace_l F
+ iswupper F
+ iswupper_l F
+ iswxdigit F
+ iswxdigit_l F
+ isxdigit F
+ isxdigit_l F
+ jrand48 F
+ jrand48_r F
+ key_decryptsession F
+ key_decryptsession_pk F
+ key_encryptsession F
+ key_encryptsession_pk F
+ key_gendes F
+ key_get_conv F
+ key_secretkey_is_set F
+ key_setnet F
+ key_setsecret F
+ kill F
+ killpg F
+ klogctl F
+ l64a F
+ labs F
+ lchmod F
+ lchown F
+ lckpwdf F
+ lcong48 F
+ lcong48_r F
+ ldexp F
+ ldexpf F
+ ldexpl F
+ ldiv F
+ lfind F
+ lgetxattr F
+ link F
+ linkat F
+ listen F
+ listxattr F
+ llabs F
+ lldiv F
+ llistxattr F
+ llseek F
+ loc1 D 0x8
+ loc2 D 0x8
+ localeconv F
+ localtime F
+ localtime_r F
+ lockf F
+ lockf64 F
+ locs D 0x8
+ longjmp F
+ lrand48 F
+ lrand48_r F
+ lremovexattr F
+ lsearch F
+ lseek F
+ lseek64 F
+ lsetxattr F
+ lutimes F
+ madvise F
+ makecontext F
+ mallinfo F
+ malloc F
+ malloc_get_state F
+ malloc_info F
+ malloc_set_state F
+ malloc_stats F
+ malloc_trim F
+ malloc_usable_size F
+ mallopt F
+ mallwatch D 0x8
+ mblen F
+ mbrlen F
+ mbrtoc16 F
+ mbrtoc32 F
+ mbrtowc F
+ mbsinit F
+ mbsnrtowcs F
+ mbsrtowcs F
+ mbstowcs F
+ mbtowc F
+ mcheck F
+ mcheck_check_all F
+ mcheck_pedantic F
+ mcount F
+ memalign F
+ memccpy F
+ memchr F
+ memcmp F
+ memcpy F
+ memfrob F
+ memmem F
+ memmove F
+ mempcpy F
+ memrchr F
+ memset F
+ mincore F
+ mkdir F
+ mkdirat F
+ mkdtemp F
+ mkfifo F
+ mkfifoat F
+ mkostemp F
+ mkostemp64 F
+ mkostemps F
+ mkostemps64 F
+ mkstemp F
+ mkstemp64 F
+ mkstemps F
+ mkstemps64 F
+ mktemp F
+ mktime F
+ mlock F
+ mlockall F
+ mmap F
+ mmap64 F
+ modf F
+ modff F
+ modfl F
+ moncontrol F
+ monstartup F
+ mount F
+ mprobe F
+ mprotect F
+ mrand48 F
+ mrand48_r F
+ mremap F
+ msgctl F
+ msgget F
+ msgrcv F
+ msgsnd F
+ msync F
+ mtrace F
+ munlock F
+ munlockall F
+ munmap F
+ muntrace F
+ name_to_handle_at F
+ nanosleep F
+ netname2host F
+ netname2user F
+ newlocale F
+ nfsservctl F
+ nftw F
+ nftw64 F
+ ngettext F
+ nice F
+ nl_langinfo F
+ nl_langinfo_l F
+ nrand48 F
+ nrand48_r F
+ ntohl F
+ ntohs F
+ ntp_adjtime F
+ ntp_gettime F
+ ntp_gettimex F
+ obstack_alloc_failed_handler D 0x8
+ obstack_exit_failure D 0x4
+ obstack_free F
+ obstack_printf F
+ obstack_vprintf F
+ on_exit F
+ open F
+ open64 F
+ open_by_handle_at F
+ open_memstream F
+ open_wmemstream F
+ openat F
+ openat64 F
+ opendir F
+ openlog F
+ optarg D 0x8
+ opterr D 0x4
+ optind D 0x4
+ optopt D 0x4
+ parse_printf_format F
+ passwd2des F
+ pathconf F
+ pause F
+ pclose F
+ perror F
+ personality F
+ pipe F
+ pipe2 F
+ pivot_root F
+ pmap_getmaps F
+ pmap_getport F
+ pmap_rmtcall F
+ pmap_set F
+ pmap_unset F
+ poll F
+ popen F
+ posix_fadvise F
+ posix_fadvise64 F
+ posix_fallocate F
+ posix_fallocate64 F
+ posix_madvise F
+ posix_memalign F
+ posix_openpt F
+ posix_spawn F
+ posix_spawn_file_actions_addclose F
+ posix_spawn_file_actions_adddup2 F
+ posix_spawn_file_actions_addopen F
+ posix_spawn_file_actions_destroy F
+ posix_spawn_file_actions_init F
+ posix_spawnattr_destroy F
+ posix_spawnattr_getflags F
+ posix_spawnattr_getpgroup F
+ posix_spawnattr_getschedparam F
+ posix_spawnattr_getschedpolicy F
+ posix_spawnattr_getsigdefault F
+ posix_spawnattr_getsigmask F
+ posix_spawnattr_init F
+ posix_spawnattr_setflags F
+ posix_spawnattr_setpgroup F
+ posix_spawnattr_setschedparam F
+ posix_spawnattr_setschedpolicy F
+ posix_spawnattr_setsigdefault F
+ posix_spawnattr_setsigmask F
+ posix_spawnp F
+ ppoll F
+ prctl F
+ pread F
+ pread64 F
+ preadv F
+ preadv64 F
+ printf F
+ printf_size F
+ printf_size_info F
+ prlimit F
+ prlimit64 F
+ process_vm_readv F
+ process_vm_writev F
+ profil F
+ program_invocation_name D 0x8
+ program_invocation_short_name D 0x8
+ pselect F
+ psiginfo F
+ psignal F
+ pthread_attr_destroy F
+ pthread_attr_getdetachstate F
+ pthread_attr_getinheritsched F
+ pthread_attr_getschedparam F
+ pthread_attr_getschedpolicy F
+ pthread_attr_getscope F
+ pthread_attr_init F
+ pthread_attr_setdetachstate F
+ pthread_attr_setinheritsched F
+ pthread_attr_setschedparam F
+ pthread_attr_setschedpolicy F
+ pthread_attr_setscope F
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+ pthread_condattr_destroy F
+ pthread_condattr_init F
+ pthread_equal F
+ pthread_exit F
+ pthread_getschedparam F
+ pthread_mutex_destroy F
+ pthread_mutex_init F
+ pthread_mutex_lock F
+ pthread_mutex_unlock F
+ pthread_self F
+ pthread_setcancelstate F
+ pthread_setcanceltype F
+ pthread_setschedparam F
+ ptrace F
+ ptsname F
+ ptsname_r F
+ putc F
+ putc_unlocked F
+ putchar F
+ putchar_unlocked F
+ putenv F
+ putgrent F
+ putmsg F
+ putpmsg F
+ putpwent F
+ puts F
+ putsgent F
+ putspent F
+ pututline F
+ pututxline F
+ putw F
+ putwc F
+ putwc_unlocked F
+ putwchar F
+ putwchar_unlocked F
+ pvalloc F
+ pwrite F
+ pwrite64 F
+ pwritev F
+ pwritev64 F
+ qecvt F
+ qecvt_r F
+ qfcvt F
+ qfcvt_r F
+ qgcvt F
+ qsort F
+ qsort_r F
+ query_module F
+ quick_exit F
+ quotactl F
+ raise F
+ rand F
+ rand_r F
+ random F
+ random_r F
+ rawmemchr F
+ rcmd F
+ rcmd_af F
+ re_comp F
+ re_compile_fastmap F
+ re_compile_pattern F
+ re_exec F
+ re_match F
+ re_match_2 F
+ re_search F
+ re_search_2 F
+ re_set_registers F
+ re_set_syntax F
+ re_syntax_options D 0x8
+ read F
+ readahead F
+ readdir F
+ readdir64 F
+ readdir64_r F
+ readdir_r F
+ readlink F
+ readlinkat F
+ readv F
+ realloc F
+ realpath F
+ reboot F
+ recv F
+ recvfrom F
+ recvmmsg F
+ recvmsg F
+ regcomp F
+ regerror F
+ regexec F
+ regfree F
+ register_printf_function F
+ register_printf_modifier F
+ register_printf_specifier F
+ register_printf_type F
+ registerrpc F
+ remap_file_pages F
+ remove F
+ removexattr F
+ remque F
+ rename F
+ renameat F
+ revoke F
+ rewind F
+ rewinddir F
+ rexec F
+ rexec_af F
+ rexecoptions D 0x4
+ rindex F
+ rmdir F
+ rpc_createerr D 0x20
+ rpmatch F
+ rresvport F
+ rresvport_af F
+ rtime F
+ ruserok F
+ ruserok_af F
+ ruserpass F
+ sbrk F
+ scalbn F
+ scalbnf F
+ scalbnl F
+ scandir F
+ scandir64 F
+ scandirat F
+ scandirat64 F
+ scanf F
+ sched_get_priority_max F
+ sched_get_priority_min F
+ sched_getaffinity F
+ sched_getcpu F
+ sched_getparam F
+ sched_getscheduler F
+ sched_rr_get_interval F
+ sched_setaffinity F
+ sched_setparam F
+ sched_setscheduler F
+ sched_yield F
+ seed48 F
+ seed48_r F
+ seekdir F
+ select F
+ semctl F
+ semget F
+ semop F
+ semtimedop F
+ send F
+ sendfile F
+ sendfile64 F
+ sendmmsg F
+ sendmsg F
+ sendto F
+ setaliasent F
+ setbuf F
+ setbuffer F
+ setcontext F
+ setdomainname F
+ setegid F
+ setenv F
+ seteuid F
+ setfsent F
+ setfsgid F
+ setfsuid F
+ setgid F
+ setgrent F
+ setgroups F
+ sethostent F
+ sethostid F
+ sethostname F
+ setipv4sourcefilter F
+ setitimer F
+ setjmp F
+ setlinebuf F
+ setlocale F
+ setlogin F
+ setlogmask F
+ setmntent F
+ setnetent F
+ setnetgrent F
+ setns F
+ setpgid F
+ setpgrp F
+ setpriority F
+ setprotoent F
+ setpwent F
+ setregid F
+ setresgid F
+ setresuid F
+ setreuid F
+ setrlimit F
+ setrlimit64 F
+ setrpcent F
+ setservent F
+ setsgent F
+ setsid F
+ setsockopt F
+ setsourcefilter F
+ setspent F
+ setstate F
+ setstate_r F
+ settimeofday F
+ setttyent F
+ setuid F
+ setusershell F
+ setutent F
+ setutxent F
+ setvbuf F
+ setxattr F
+ sgetsgent F
+ sgetsgent_r F
+ sgetspent F
+ sgetspent_r F
+ shmat F
+ shmctl F
+ shmdt F
+ shmget F
+ shutdown F
+ sigaction F
+ sigaddset F
+ sigaltstack F
+ sigandset F
+ sigblock F
+ sigdelset F
+ sigemptyset F
+ sigfillset F
+ siggetmask F
+ sighold F
+ sigignore F
+ siginterrupt F
+ sigisemptyset F
+ sigismember F
+ siglongjmp F
+ signal F
+ signalfd F
+ sigorset F
+ sigpause F
+ sigpending F
+ sigprocmask F
+ sigqueue F
+ sigrelse F
+ sigreturn F
+ sigset F
+ sigsetmask F
+ sigstack F
+ sigsuspend F
+ sigtimedwait F
+ sigvec F
+ sigwait F
+ sigwaitinfo F
+ sleep F
+ snprintf F
+ sockatmark F
+ socket F
+ socketpair F
+ splice F
+ sprintf F
+ sprofil F
+ srand F
+ srand48 F
+ srand48_r F
+ srandom F
+ srandom_r F
+ sscanf F
+ ssignal F
+ sstk F
+ statfs F
+ statfs64 F
+ statvfs F
+ statvfs64 F
+ stderr D 0x8
+ stdin D 0x8
+ stdout D 0x8
+ step F
+ stime F
+ stpcpy F
+ stpncpy F
+ strcasecmp F
+ strcasecmp_l F
+ strcasestr F
+ strcat F
+ strchr F
+ strchrnul F
+ strcmp F
+ strcoll F
+ strcoll_l F
+ strcpy F
+ strcspn F
+ strdup F
+ strerror F
+ strerror_l F
+ strerror_r F
+ strfmon F
+ strfmon_l F
+ strfry F
+ strftime F
+ strftime_l F
+ strlen F
+ strncasecmp F
+ strncasecmp_l F
+ strncat F
+ strncmp F
+ strncpy F
+ strndup F
+ strnlen F
+ strpbrk F
+ strptime F
+ strptime_l F
+ strrchr F
+ strsep F
+ strsignal F
+ strspn F
+ strstr F
+ strtod F
+ strtod_l F
+ strtof F
+ strtof_l F
+ strtoimax F
+ strtok F
+ strtok_r F
+ strtol F
+ strtol_l F
+ strtold F
+ strtold_l F
+ strtoll F
+ strtoll_l F
+ strtoq F
+ strtoul F
+ strtoul_l F
+ strtoull F
+ strtoull_l F
+ strtoumax F
+ strtouq F
+ strverscmp F
+ strxfrm F
+ strxfrm_l F
+ stty F
+ svc_exit F
+ svc_fdset D 0x80
+ svc_getreq F
+ svc_getreq_common F
+ svc_getreq_poll F
+ svc_getreqset F
+ svc_max_pollfd D 0x4
+ svc_pollfd D 0x8
+ svc_register F
+ svc_run F
+ svc_sendreply F
+ svc_unregister F
+ svcauthdes_stats D 0x18
+ svcerr_auth F
+ svcerr_decode F
+ svcerr_noproc F
+ svcerr_noprog F
+ svcerr_progvers F
+ svcerr_systemerr F
+ svcerr_weakauth F
+ svcfd_create F
+ svcraw_create F
+ svctcp_create F
+ svcudp_bufcreate F
+ svcudp_create F
+ svcudp_enablecache F
+ svcunix_create F
+ svcunixfd_create F
+ swab F
+ swapcontext F
+ swapoff F
+ swapon F
+ swprintf F
+ swscanf F
+ symlink F
+ symlinkat F
+ sync F
+ sync_file_range F
+ syncfs F
+ sys_errlist D 0x438
+ sys_nerr D 0x4
+ sys_sigabbrev D 0x208
+ sys_siglist D 0x208
+ syscall F
+ sysconf F
+ sysctl F
+ sysinfo F
+ syslog F
+ system F
+ sysv_signal F
+ tcdrain F
+ tcflow F
+ tcflush F
+ tcgetattr F
+ tcgetpgrp F
+ tcgetsid F
+ tcsendbreak F
+ tcsetattr F
+ tcsetpgrp F
+ tdelete F
+ tdestroy F
+ tee F
+ telldir F
+ tempnam F
+ textdomain F
+ tfind F
+ time F
+ timegm F
+ timelocal F
+ timerfd_create F
+ timerfd_gettime F
+ timerfd_settime F
+ times F
+ timespec_get F
+ timezone D 0x8
+ tmpfile F
+ tmpfile64 F
+ tmpnam F
+ tmpnam_r F
+ toascii F
+ tolower F
+ tolower_l F
+ toupper F
+ toupper_l F
+ towctrans F
+ towctrans_l F
+ towlower F
+ towlower_l F
+ towupper F
+ towupper_l F
+ tr_break F
+ truncate F
+ truncate64 F
+ tsearch F
+ ttyname F
+ ttyname_r F
+ ttyslot F
+ twalk F
+ tzname D 0x10
+ tzset F
+ ualarm F
+ ulckpwdf F
+ ulimit F
+ umask F
+ umount F
+ umount2 F
+ uname F
+ ungetc F
+ ungetwc F
+ unlink F
+ unlinkat F
+ unlockpt F
+ unsetenv F
+ unshare F
+ updwtmp F
+ updwtmpx F
+ uselib F
+ uselocale F
+ user2netname F
+ usleep F
+ ustat F
+ utime F
+ utimensat F
+ utimes F
+ utmpname F
+ utmpxname F
+ valloc F
+ vasprintf F
+ vdprintf F
+ verr F
+ verrx F
+ versionsort F
+ versionsort64 F
+ vfork F
+ vfprintf F
+ vfscanf F
+ vfwprintf F
+ vfwscanf F
+ vhangup F
+ vlimit F
+ vmsplice F
+ vprintf F
+ vscanf F
+ vsnprintf F
+ vsprintf F
+ vsscanf F
+ vswprintf F
+ vswscanf F
+ vsyslog F
+ vtimes F
+ vwarn F
+ vwarnx F
+ vwprintf F
+ vwscanf F
+ wait F
+ wait3 F
+ wait4 F
+ waitid F
+ waitpid F
+ warn F
+ warnx F
+ wcpcpy F
+ wcpncpy F
+ wcrtomb F
+ wcscasecmp F
+ wcscasecmp_l F
+ wcscat F
+ wcschr F
+ wcschrnul F
+ wcscmp F
+ wcscoll F
+ wcscoll_l F
+ wcscpy F
+ wcscspn F
+ wcsdup F
+ wcsftime F
+ wcsftime_l F
+ wcslen F
+ wcsncasecmp F
+ wcsncasecmp_l F
+ wcsncat F
+ wcsncmp F
+ wcsncpy F
+ wcsnlen F
+ wcsnrtombs F
+ wcspbrk F
+ wcsrchr F
+ wcsrtombs F
+ wcsspn F
+ wcsstr F
+ wcstod F
+ wcstod_l F
+ wcstof F
+ wcstof_l F
+ wcstoimax F
+ wcstok F
+ wcstol F
+ wcstol_l F
+ wcstold F
+ wcstold_l F
+ wcstoll F
+ wcstoll_l F
+ wcstombs F
+ wcstoq F
+ wcstoul F
+ wcstoul_l F
+ wcstoull F
+ wcstoull_l F
+ wcstoumax F
+ wcstouq F
+ wcswcs F
+ wcswidth F
+ wcsxfrm F
+ wcsxfrm_l F
+ wctob F
+ wctomb F
+ wctrans F
+ wctrans_l F
+ wctype F
+ wctype_l F
+ wcwidth F
+ wmemchr F
+ wmemcmp F
+ wmemcpy F
+ wmemmove F
+ wmempcpy F
+ wmemset F
+ wordexp F
+ wordfree F
+ wprintf F
+ write F
+ writev F
+ wscanf F
+ xdecrypt F
+ xdr_accepted_reply F
+ xdr_array F
+ xdr_authdes_cred F
+ xdr_authdes_verf F
+ xdr_authunix_parms F
+ xdr_bool F
+ xdr_bytes F
+ xdr_callhdr F
+ xdr_callmsg F
+ xdr_char F
+ xdr_cryptkeyarg F
+ xdr_cryptkeyarg2 F
+ xdr_cryptkeyres F
+ xdr_des_block F
+ xdr_double F
+ xdr_enum F
+ xdr_float F
+ xdr_free F
+ xdr_getcredres F
+ xdr_hyper F
+ xdr_int F
+ xdr_int16_t F
+ xdr_int32_t F
+ xdr_int64_t F
+ xdr_int8_t F
+ xdr_key_netstarg F
+ xdr_key_netstres F
+ xdr_keybuf F
+ xdr_keystatus F
+ xdr_long F
+ xdr_longlong_t F
+ xdr_netnamestr F
+ xdr_netobj F
+ xdr_opaque F
+ xdr_opaque_auth F
+ xdr_pmap F
+ xdr_pmaplist F
+ xdr_pointer F
+ xdr_quad_t F
+ xdr_reference F
+ xdr_rejected_reply F
+ xdr_replymsg F
+ xdr_rmtcall_args F
+ xdr_rmtcallres F
+ xdr_short F
+ xdr_sizeof F
+ xdr_string F
+ xdr_u_char F
+ xdr_u_hyper F
+ xdr_u_int F
+ xdr_u_long F
+ xdr_u_longlong_t F
+ xdr_u_quad_t F
+ xdr_u_short F
+ xdr_uint16_t F
+ xdr_uint32_t F
+ xdr_uint64_t F
+ xdr_uint8_t F
+ xdr_union F
+ xdr_unixcred F
+ xdr_vector F
+ xdr_void F
+ xdr_wrapstring F
+ xdrmem_create F
+ xdrrec_create F
+ xdrrec_endofrecord F
+ xdrrec_eof F
+ xdrrec_skiprecord F
+ xdrstdio_create F
+ xencrypt F
+ xprt_register F
+ xprt_unregister F
+GLIBC_2.17
+ GLIBC_2.17 A
+ secure_getenv F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libcrypt.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libcrypt.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libcrypt.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libcrypt.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,9 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ crypt F
+ crypt_r F
+ encrypt F
+ encrypt_r F
+ fcrypt F
+ setkey F
+ setkey_r F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libdl.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libdl.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libdl.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libdl.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,11 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ dladdr F
+ dladdr1 F
+ dlclose F
+ dlerror F
+ dlinfo F
+ dlmopen F
+ dlopen F
+ dlsym F
+ dlvsym F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libm.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libm.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libm.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libm.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,396 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ _LIB_VERSION D 0x4
+ __acos_finite F
+ __acosf_finite F
+ __acosh_finite F
+ __acoshf_finite F
+ __acoshl_finite F
+ __acosl_finite F
+ __asin_finite F
+ __asinf_finite F
+ __asinl_finite F
+ __atan2_finite F
+ __atan2f_finite F
+ __atan2l_finite F
+ __atanh_finite F
+ __atanhf_finite F
+ __atanhl_finite F
+ __clog10 F
+ __clog10f F
+ __clog10l F
+ __cosh_finite F
+ __coshf_finite F
+ __coshl_finite F
+ __exp10_finite F
+ __exp10f_finite F
+ __exp10l_finite F
+ __exp2_finite F
+ __exp2f_finite F
+ __exp2l_finite F
+ __exp_finite F
+ __expf_finite F
+ __expl_finite F
+ __finite F
+ __finitef F
+ __finitel F
+ __fmod_finite F
+ __fmodf_finite F
+ __fmodl_finite F
+ __fpclassify F
+ __fpclassifyf F
+ __fpclassifyl F
+ __gamma_r_finite F
+ __gammaf_r_finite F
+ __gammal_r_finite F
+ __hypot_finite F
+ __hypotf_finite F
+ __hypotl_finite F
+ __j0_finite F
+ __j0f_finite F
+ __j0l_finite F
+ __j1_finite F
+ __j1f_finite F
+ __j1l_finite F
+ __jn_finite F
+ __jnf_finite F
+ __jnl_finite F
+ __lgamma_r_finite F
+ __lgammaf_r_finite F
+ __lgammal_r_finite F
+ __log10_finite F
+ __log10f_finite F
+ __log10l_finite F
+ __log2_finite F
+ __log2f_finite F
+ __log2l_finite F
+ __log_finite F
+ __logf_finite F
+ __logl_finite F
+ __pow_finite F
+ __powf_finite F
+ __powl_finite F
+ __remainder_finite F
+ __remainderf_finite F
+ __remainderl_finite F
+ __scalb_finite F
+ __scalbf_finite F
+ __scalbl_finite F
+ __signbit F
+ __signbitf F
+ __signbitl F
+ __sinh_finite F
+ __sinhf_finite F
+ __sinhl_finite F
+ __sqrt_finite F
+ __sqrtf_finite F
+ __y0_finite F
+ __y0f_finite F
+ __y0l_finite F
+ __y1_finite F
+ __y1f_finite F
+ __y1l_finite F
+ __yn_finite F
+ __ynf_finite F
+ __ynl_finite F
+ acos F
+ acosf F
+ acosh F
+ acoshf F
+ acoshl F
+ acosl F
+ asin F
+ asinf F
+ asinh F
+ asinhf F
+ asinhl F
+ asinl F
+ atan F
+ atan2 F
+ atan2f F
+ atan2l F
+ atanf F
+ atanh F
+ atanhf F
+ atanhl F
+ atanl F
+ cabs F
+ cabsf F
+ cabsl F
+ cacos F
+ cacosf F
+ cacosh F
+ cacoshf F
+ cacoshl F
+ cacosl F
+ carg F
+ cargf F
+ cargl F
+ casin F
+ casinf F
+ casinh F
+ casinhf F
+ casinhl F
+ casinl F
+ catan F
+ catanf F
+ catanh F
+ catanhf F
+ catanhl F
+ catanl F
+ cbrt F
+ cbrtf F
+ cbrtl F
+ ccos F
+ ccosf F
+ ccosh F
+ ccoshf F
+ ccoshl F
+ ccosl F
+ ceil F
+ ceilf F
+ ceill F
+ cexp F
+ cexpf F
+ cexpl F
+ cimag F
+ cimagf F
+ cimagl F
+ clog F
+ clog10 F
+ clog10f F
+ clog10l F
+ clogf F
+ clogl F
+ conj F
+ conjf F
+ conjl F
+ copysign F
+ copysignf F
+ copysignl F
+ cos F
+ cosf F
+ cosh F
+ coshf F
+ coshl F
+ cosl F
+ cpow F
+ cpowf F
+ cpowl F
+ cproj F
+ cprojf F
+ cprojl F
+ creal F
+ crealf F
+ creall F
+ csin F
+ csinf F
+ csinh F
+ csinhf F
+ csinhl F
+ csinl F
+ csqrt F
+ csqrtf F
+ csqrtl F
+ ctan F
+ ctanf F
+ ctanh F
+ ctanhf F
+ ctanhl F
+ ctanl F
+ drem F
+ dremf F
+ dreml F
+ erf F
+ erfc F
+ erfcf F
+ erfcl F
+ erff F
+ erfl F
+ exp F
+ exp10 F
+ exp10f F
+ exp10l F
+ exp2 F
+ exp2f F
+ exp2l F
+ expf F
+ expl F
+ expm1 F
+ expm1f F
+ expm1l F
+ fabs F
+ fabsf F
+ fabsl F
+ fdim F
+ fdimf F
+ fdiml F
+ feclearexcept F
+ fedisableexcept F
+ feenableexcept F
+ fegetenv F
+ fegetexcept F
+ fegetexceptflag F
+ fegetround F
+ feholdexcept F
+ feraiseexcept F
+ fesetenv F
+ fesetexceptflag F
+ fesetround F
+ fetestexcept F
+ feupdateenv F
+ finite F
+ finitef F
+ finitel F
+ floor F
+ floorf F
+ floorl F
+ fma F
+ fmaf F
+ fmal F
+ fmax F
+ fmaxf F
+ fmaxl F
+ fmin F
+ fminf F
+ fminl F
+ fmod F
+ fmodf F
+ fmodl F
+ frexp F
+ frexpf F
+ frexpl F
+ gamma F
+ gammaf F
+ gammal F
+ hypot F
+ hypotf F
+ hypotl F
+ ilogb F
+ ilogbf F
+ ilogbl F
+ j0 F
+ j0f F
+ j0l F
+ j1 F
+ j1f F
+ j1l F
+ jn F
+ jnf F
+ jnl F
+ ldexp F
+ ldexpf F
+ ldexpl F
+ lgamma F
+ lgamma_r F
+ lgammaf F
+ lgammaf_r F
+ lgammal F
+ lgammal_r F
+ llrint F
+ llrintf F
+ llrintl F
+ llround F
+ llroundf F
+ llroundl F
+ log F
+ log10 F
+ log10f F
+ log10l F
+ log1p F
+ log1pf F
+ log1pl F
+ log2 F
+ log2f F
+ log2l F
+ logb F
+ logbf F
+ logbl F
+ logf F
+ logl F
+ lrint F
+ lrintf F
+ lrintl F
+ lround F
+ lroundf F
+ lroundl F
+ matherr F
+ modf F
+ modff F
+ modfl F
+ nan F
+ nanf F
+ nanl F
+ nearbyint F
+ nearbyintf F
+ nearbyintl F
+ nextafter F
+ nextafterf F
+ nextafterl F
+ nexttoward F
+ nexttowardf F
+ nexttowardl F
+ pow F
+ pow10 F
+ pow10f F
+ pow10l F
+ powf F
+ powl F
+ remainder F
+ remainderf F
+ remainderl F
+ remquo F
+ remquof F
+ remquol F
+ rint F
+ rintf F
+ rintl F
+ round F
+ roundf F
+ roundl F
+ scalb F
+ scalbf F
+ scalbl F
+ scalbln F
+ scalblnf F
+ scalblnl F
+ scalbn F
+ scalbnf F
+ scalbnl F
+ signgam D 0x4
+ significand F
+ significandf F
+ significandl F
+ sin F
+ sincos F
+ sincosf F
+ sincosl F
+ sinf F
+ sinh F
+ sinhf F
+ sinhl F
+ sinl F
+ sqrt F
+ sqrtf F
+ sqrtl F
+ tan F
+ tanf F
+ tanh F
+ tanhf F
+ tanhl F
+ tanl F
+ tgamma F
+ tgammaf F
+ tgammal F
+ trunc F
+ truncf F
+ truncl F
+ y0 F
+ y0f F
+ y0l F
+ y1 F
+ y1f F
+ y1l F
+ yn F
+ ynf F
+ ynl F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libnsl.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libnsl.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libnsl.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libnsl.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,123 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ __free_fdresult F
+ __nis_default_access F
+ __nis_default_group F
+ __nis_default_owner F
+ __nis_default_ttl F
+ __nis_finddirectory F
+ __nis_hash F
+ __nisbind_connect F
+ __nisbind_create F
+ __nisbind_destroy F
+ __nisbind_next F
+ __yp_check F
+ nis_add F
+ nis_add_entry F
+ nis_addmember F
+ nis_checkpoint F
+ nis_clone_directory F
+ nis_clone_object F
+ nis_clone_result F
+ nis_creategroup F
+ nis_destroy_object F
+ nis_destroygroup F
+ nis_dir_cmp F
+ nis_domain_of F
+ nis_domain_of_r F
+ nis_first_entry F
+ nis_free_directory F
+ nis_free_object F
+ nis_free_request F
+ nis_freenames F
+ nis_freeresult F
+ nis_freeservlist F
+ nis_freetags F
+ nis_getnames F
+ nis_getservlist F
+ nis_ismember F
+ nis_leaf_of F
+ nis_leaf_of_r F
+ nis_lerror F
+ nis_list F
+ nis_local_directory F
+ nis_local_group F
+ nis_local_host F
+ nis_local_principal F
+ nis_lookup F
+ nis_mkdir F
+ nis_modify F
+ nis_modify_entry F
+ nis_name_of F
+ nis_name_of_r F
+ nis_next_entry F
+ nis_perror F
+ nis_ping F
+ nis_print_directory F
+ nis_print_entry F
+ nis_print_group F
+ nis_print_group_entry F
+ nis_print_link F
+ nis_print_object F
+ nis_print_result F
+ nis_print_rights F
+ nis_print_table F
+ nis_read_obj F
+ nis_remove F
+ nis_remove_entry F
+ nis_removemember F
+ nis_rmdir F
+ nis_servstate F
+ nis_sperrno F
+ nis_sperror F
+ nis_sperror_r F
+ nis_stats F
+ nis_verifygroup F
+ nis_write_obj F
+ readColdStartFile F
+ writeColdStartFile F
+ xdr_cback_data F
+ xdr_domainname F
+ xdr_keydat F
+ xdr_mapname F
+ xdr_obj_p F
+ xdr_peername F
+ xdr_valdat F
+ xdr_yp_buf F
+ xdr_ypall F
+ xdr_ypbind_binding F
+ xdr_ypbind_resp F
+ xdr_ypbind_resptype F
+ xdr_ypbind_setdom F
+ xdr_ypdelete_args F
+ xdr_ypmap_parms F
+ xdr_ypmaplist F
+ xdr_yppush_status F
+ xdr_yppushresp_xfr F
+ xdr_ypreq_key F
+ xdr_ypreq_nokey F
+ xdr_ypreq_xfr F
+ xdr_ypresp_all F
+ xdr_ypresp_key_val F
+ xdr_ypresp_maplist F
+ xdr_ypresp_master F
+ xdr_ypresp_order F
+ xdr_ypresp_val F
+ xdr_ypresp_xfr F
+ xdr_ypstat F
+ xdr_ypupdate_args F
+ xdr_ypxfrstat F
+ yp_all F
+ yp_bind F
+ yp_first F
+ yp_get_default_domain F
+ yp_maplist F
+ yp_master F
+ yp_match F
+ yp_next F
+ yp_order F
+ yp_unbind F
+ yp_update F
+ ypbinderr_string F
+ yperr_string F
+ ypprot_err F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libpthread.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libpthread.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libpthread.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libpthread.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,225 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ _IO_flockfile F
+ _IO_ftrylockfile F
+ _IO_funlockfile F
+ __close F
+ __connect F
+ __errno_location F
+ __fcntl F
+ __fork F
+ __h_errno_location F
+ __libc_allocate_rtsig F
+ __libc_current_sigrtmax F
+ __libc_current_sigrtmin F
+ __lseek F
+ __nanosleep F
+ __open F
+ __open64 F
+ __pread64 F
+ __pthread_cleanup_routine F
+ __pthread_getspecific F
+ __pthread_key_create F
+ __pthread_mutex_destroy F
+ __pthread_mutex_init F
+ __pthread_mutex_lock F
+ __pthread_mutex_trylock F
+ __pthread_mutex_unlock F
+ __pthread_mutexattr_destroy F
+ __pthread_mutexattr_init F
+ __pthread_mutexattr_settype F
+ __pthread_once F
+ __pthread_register_cancel F
+ __pthread_register_cancel_defer F
+ __pthread_rwlock_destroy F
+ __pthread_rwlock_init F
+ __pthread_rwlock_rdlock F
+ __pthread_rwlock_tryrdlock F
+ __pthread_rwlock_trywrlock F
+ __pthread_rwlock_unlock F
+ __pthread_rwlock_wrlock F
+ __pthread_setspecific F
+ __pthread_unregister_cancel F
+ __pthread_unregister_cancel_restore F
+ __pthread_unwind_next F
+ __pwrite64 F
+ __read F
+ __res_state F
+ __send F
+ __sigaction F
+ __vfork F
+ __wait F
+ __write F
+ _pthread_cleanup_pop F
+ _pthread_cleanup_pop_restore F
+ _pthread_cleanup_push F
+ _pthread_cleanup_push_defer F
+ accept F
+ close F
+ connect F
+ fcntl F
+ flockfile F
+ fork F
+ fsync F
+ ftrylockfile F
+ funlockfile F
+ longjmp F
+ lseek F
+ lseek64 F
+ msync F
+ nanosleep F
+ open F
+ open64 F
+ pause F
+ pread F
+ pread64 F
+ pthread_atfork F
+ pthread_attr_destroy F
+ pthread_attr_getaffinity_np F
+ pthread_attr_getdetachstate F
+ pthread_attr_getguardsize F
+ pthread_attr_getinheritsched F
+ pthread_attr_getschedparam F
+ pthread_attr_getschedpolicy F
+ pthread_attr_getscope F
+ pthread_attr_getstack F
+ pthread_attr_getstackaddr F
+ pthread_attr_getstacksize F
+ pthread_attr_init F
+ pthread_attr_setaffinity_np F
+ pthread_attr_setdetachstate F
+ pthread_attr_setguardsize F
+ pthread_attr_setinheritsched F
+ pthread_attr_setschedparam F
+ pthread_attr_setschedpolicy F
+ pthread_attr_setscope F
+ pthread_attr_setstack F
+ pthread_attr_setstackaddr F
+ pthread_attr_setstacksize F
+ pthread_barrier_destroy F
+ pthread_barrier_init F
+ pthread_barrier_wait F
+ pthread_barrierattr_destroy F
+ pthread_barrierattr_getpshared F
+ pthread_barrierattr_init F
+ pthread_barrierattr_setpshared F
+ pthread_cancel F
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+ pthread_condattr_destroy F
+ pthread_condattr_getclock F
+ pthread_condattr_getpshared F
+ pthread_condattr_init F
+ pthread_condattr_setclock F
+ pthread_condattr_setpshared F
+ pthread_create F
+ pthread_detach F
+ pthread_equal F
+ pthread_exit F
+ pthread_getaffinity_np F
+ pthread_getattr_np F
+ pthread_getconcurrency F
+ pthread_getcpuclockid F
+ pthread_getname_np F
+ pthread_getschedparam F
+ pthread_getspecific F
+ pthread_join F
+ pthread_key_create F
+ pthread_key_delete F
+ pthread_kill F
+ pthread_kill_other_threads_np F
+ pthread_mutex_consistent F
+ pthread_mutex_consistent_np F
+ pthread_mutex_destroy F
+ pthread_mutex_getprioceiling F
+ pthread_mutex_init F
+ pthread_mutex_lock F
+ pthread_mutex_setprioceiling F
+ pthread_mutex_timedlock F
+ pthread_mutex_trylock F
+ pthread_mutex_unlock F
+ pthread_mutexattr_destroy F
+ pthread_mutexattr_getkind_np F
+ pthread_mutexattr_getprioceiling F
+ pthread_mutexattr_getprotocol F
+ pthread_mutexattr_getpshared F
+ pthread_mutexattr_getrobust F
+ pthread_mutexattr_getrobust_np F
+ pthread_mutexattr_gettype F
+ pthread_mutexattr_init F
+ pthread_mutexattr_setkind_np F
+ pthread_mutexattr_setprioceiling F
+ pthread_mutexattr_setprotocol F
+ pthread_mutexattr_setpshared F
+ pthread_mutexattr_setrobust F
+ pthread_mutexattr_setrobust_np F
+ pthread_mutexattr_settype F
+ pthread_once F
+ pthread_rwlock_destroy F
+ pthread_rwlock_init F
+ pthread_rwlock_rdlock F
+ pthread_rwlock_timedrdlock F
+ pthread_rwlock_timedwrlock F
+ pthread_rwlock_tryrdlock F
+ pthread_rwlock_trywrlock F
+ pthread_rwlock_unlock F
+ pthread_rwlock_wrlock F
+ pthread_rwlockattr_destroy F
+ pthread_rwlockattr_getkind_np F
+ pthread_rwlockattr_getpshared F
+ pthread_rwlockattr_init F
+ pthread_rwlockattr_setkind_np F
+ pthread_rwlockattr_setpshared F
+ pthread_self F
+ pthread_setaffinity_np F
+ pthread_setcancelstate F
+ pthread_setcanceltype F
+ pthread_setconcurrency F
+ pthread_setname_np F
+ pthread_setschedparam F
+ pthread_setschedprio F
+ pthread_setspecific F
+ pthread_sigmask F
+ pthread_sigqueue F
+ pthread_spin_destroy F
+ pthread_spin_init F
+ pthread_spin_lock F
+ pthread_spin_trylock F
+ pthread_spin_unlock F
+ pthread_testcancel F
+ pthread_timedjoin_np F
+ pthread_tryjoin_np F
+ pthread_yield F
+ pwrite F
+ pwrite64 F
+ raise F
+ read F
+ recv F
+ recvfrom F
+ recvmsg F
+ sem_close F
+ sem_destroy F
+ sem_getvalue F
+ sem_init F
+ sem_open F
+ sem_post F
+ sem_timedwait F
+ sem_trywait F
+ sem_unlink F
+ sem_wait F
+ send F
+ sendmsg F
+ sendto F
+ sigaction F
+ siglongjmp F
+ sigwait F
+ system F
+ tcdrain F
+ vfork F
+ wait F
+ waitpid F
+ write F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libresolv.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libresolv.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libresolv.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libresolv.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,93 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ __b64_ntop F
+ __b64_pton F
+ __dn_comp F
+ __dn_count_labels F
+ __dn_expand F
+ __dn_skipname F
+ __fp_nquery F
+ __fp_query F
+ __fp_resstat F
+ __hostalias F
+ __loc_aton F
+ __loc_ntoa F
+ __p_cdname F
+ __p_cdnname F
+ __p_class F
+ __p_class_syms D 0xa8
+ __p_fqname F
+ __p_fqnname F
+ __p_option F
+ __p_query F
+ __p_rcode F
+ __p_secstodate F
+ __p_time F
+ __p_type F
+ __p_type_syms D 0x450
+ __putlong F
+ __putshort F
+ __res_close F
+ __res_dnok F
+ __res_hnok F
+ __res_hostalias F
+ __res_isourserver F
+ __res_mailok F
+ __res_mkquery F
+ __res_nameinquery F
+ __res_nmkquery F
+ __res_nquery F
+ __res_nquerydomain F
+ __res_nsearch F
+ __res_nsend F
+ __res_ownok F
+ __res_queriesmatch F
+ __res_query F
+ __res_querydomain F
+ __res_search F
+ __res_send F
+ __sym_ntop F
+ __sym_ntos F
+ __sym_ston F
+ _gethtbyaddr F
+ _gethtbyname F
+ _gethtbyname2 F
+ _gethtent F
+ _getlong F
+ _getshort F
+ _res_opcodes D 0x80
+ _sethtent F
+ inet_net_ntop F
+ inet_net_pton F
+ inet_neta F
+ ns_datetosecs F
+ ns_format_ttl F
+ ns_get16 F
+ ns_get32 F
+ ns_initparse F
+ ns_makecanon F
+ ns_msg_getflag F
+ ns_name_compress F
+ ns_name_ntol F
+ ns_name_ntop F
+ ns_name_pack F
+ ns_name_pton F
+ ns_name_rollback F
+ ns_name_skip F
+ ns_name_uncompress F
+ ns_name_unpack F
+ ns_parse_ttl F
+ ns_parserr F
+ ns_put16 F
+ ns_put32 F
+ ns_samedomain F
+ ns_samename F
+ ns_skiprr F
+ ns_sprintrr F
+ ns_sprintrrf F
+ ns_subdomain F
+ res_gethostbyaddr F
+ res_gethostbyname F
+ res_gethostbyname2 F
+ res_send_setqhook F
+ res_send_setrhook F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/librt.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/librt.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/librt.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/librt.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,42 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ __mq_open_2 F
+ aio_cancel F
+ aio_cancel64 F
+ aio_error F
+ aio_error64 F
+ aio_fsync F
+ aio_fsync64 F
+ aio_init F
+ aio_read F
+ aio_read64 F
+ aio_return F
+ aio_return64 F
+ aio_suspend F
+ aio_suspend64 F
+ aio_write F
+ aio_write64 F
+ clock_getcpuclockid F
+ clock_getres F
+ clock_gettime F
+ clock_nanosleep F
+ clock_settime F
+ lio_listio F
+ lio_listio64 F
+ mq_close F
+ mq_getattr F
+ mq_notify F
+ mq_open F
+ mq_receive F
+ mq_send F
+ mq_setattr F
+ mq_timedreceive F
+ mq_timedsend F
+ mq_unlink F
+ shm_open F
+ shm_unlink F
+ timer_create F
+ timer_delete F
+ timer_getoverrun F
+ timer_gettime F
+ timer_settime F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libthread_db.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libthread_db.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libthread_db.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libthread_db.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,42 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ td_init F
+ td_log F
+ td_symbol_list F
+ td_ta_clear_event F
+ td_ta_delete F
+ td_ta_enable_stats F
+ td_ta_event_addr F
+ td_ta_event_getmsg F
+ td_ta_get_nthreads F
+ td_ta_get_ph F
+ td_ta_get_stats F
+ td_ta_map_id2thr F
+ td_ta_map_lwp2thr F
+ td_ta_new F
+ td_ta_reset_stats F
+ td_ta_set_event F
+ td_ta_setconcurrency F
+ td_ta_thr_iter F
+ td_ta_tsd_iter F
+ td_thr_clear_event F
+ td_thr_dbresume F
+ td_thr_dbsuspend F
+ td_thr_event_enable F
+ td_thr_event_getmsg F
+ td_thr_get_info F
+ td_thr_getfpregs F
+ td_thr_getgregs F
+ td_thr_getxregs F
+ td_thr_getxregsize F
+ td_thr_set_event F
+ td_thr_setfpregs F
+ td_thr_setgregs F
+ td_thr_setprio F
+ td_thr_setsigpending F
+ td_thr_setxregs F
+ td_thr_sigsetmask F
+ td_thr_tls_get_addr F
+ td_thr_tlsbase F
+ td_thr_tsd F
+ td_thr_validate F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libutil.abilist glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libutil.abilist
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libutil.abilist	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/libutil.abilist	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,8 @@
+GLIBC_2.16
+ GLIBC_2.16 A
+ forkpty F
+ login F
+ login_tty F
+ logout F
+ logwtmp F
+ openpty F
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/localplt.data glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/localplt.data
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/localplt.data	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/localplt.data	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,15 @@
+# See scripts/check-localplt.awk for how this file is processed.
+# PLT use is required for the malloc family and for matherr because
+# users can define their own functions and have library internals call them.
+libc.so: calloc
+libc.so: free
+libc.so: malloc
+libc.so: memalign
+libc.so: realloc
+libc.so: __signbit
+libc.so: __signbitl
+libm.so: matherr
+libm.so: __signbit
+libm.so: __signbitf
+libm.so: __signbitl
+libpthread.so: __errno_location
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/lowlevellock.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/lowlevellock.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/lowlevellock.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/lowlevellock.h	2012-09-24 12:48:34.000000000 +0100
@@ -0,0 +1,284 @@
+/* Copyright (C) 2005, 2006, 2007, 2008, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif	      
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    __ret;								      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);					      \
+    __ret;								      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+#define lll_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 1, 0)
+
+#define lll_cond_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 2, 0)
+
+#define __lll_robust_trylock(futex, id) \
+  (atomic_compare_and_exchange_val_acq (futex, id, 0) != 0)
+#define lll_robust_trylock(lock, id) \
+  __lll_robust_trylock (&(lock), id)
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+#define __lll_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_compare_and_exchange_val_acq (__futex,       \
+								1, 0), 0))    \
+      {									      \
+	if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
+	  __lll_lock_wait_private (__futex);				      \
+	else								      \
+	  __lll_lock_wait (__futex, private);				      \
+      }									      \
+  }))
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+
+#define __lll_robust_lock(futex, id, private)				      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_lock_wait (__futex, private);		      \
+    __val;								      \
+  })
+#define lll_robust_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), id, private)
+
+
+#define __lll_cond_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_exchange_acq (__futex, 2), 0))		      \
+      __lll_lock_wait (__futex, private);				      \
+  }))
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+
+#define lll_robust_cond_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+#define __lll_timedlock(futex, abstime, private)			      \
+  ({									      \
+     int *__futex = (futex);						      \
+     int __val = 0;							      \
+									      \
+     if (__builtin_expect (atomic_exchange_acq (__futex, 1), 0))	      \
+       __val = __lll_timedlock_wait (__futex, abstime, private);	      \
+     __val;								      \
+  })
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+#define __lll_robust_timedlock(futex, abstime, id, private)		      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_timedlock_wait (__futex, abstime, private);	      \
+    __val;								      \
+  })
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
+
+
+#define __lll_robust_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_robust_unlock(futex, private) \
+  __lll_robust_unlock(&(futex), private)
+
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/not-cancel.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/not-cancel.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/not-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/not-cancel.h	2012-09-24 12:48:55.000000000 +0100
@@ -0,0 +1,105 @@
+/* Uncancelable versions of cancelable interfaces.  Linux/NPTL version.
+
+   Copyright (C) 2003, 2006, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+#define open_not_cancel(name, flags, mode) \
+  INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), (flags), (mode))
+
+#define open_not_cancel_2(name, flags) \
+  INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), (flags))
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+extern int __openat_nocancel (int fd, const char *fname, int oflag,
+				mode_t mode) attribute_hidden;
+extern int __openat64_nocancel (int fd, const char *fname, int oflag,
+				  mode_t mode) attribute_hidden;
+#else
+# define __openat_nocancel(fd, fname, oflag, mode) \
+  openat (fd, fname, oflag, mode)
+# define __openat64_nocancel(fd, fname, oflag, mode) \
+  openat64 (fd, fname, oflag, mode)
+#endif
+
+/* Uncancelable openat.  */
+#define openat_not_cancel(fd, fname, oflag, mode) \
+  __openat_nocancel (fd, fname, oflag, mode)
+#define openat_not_cancel_3(fd, fname, oflag) \
+  __openat_nocancel (fd, fname, oflag, 0)
+#define openat64_not_cancel(fd, fname, oflag, mode) \
+  __openat64_nocancel (fd, fname, oflag, mode)
+#define openat64_not_cancel_3(fd, fname, oflag) \
+  __openat64_nocancel (fd, fname, oflag, 0)
+
+/* Uncancelable close.  */
+#define close_not_cancel(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+#define close_not_cancel_no_status(fd) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
+	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+
+/* Uncancelable read.  */
+#define read_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+
+/* Uncancelable write.  */
+#define write_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+
+/* Uncancelable writev.  */
+#define writev_not_cancel_no_status(fd, iov, n) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
+	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+
+/* Uncancelable fcntl.  */
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl_nocancel (fd, cmd, val)
+
+/* Uncancelable waitpid.  */
+#ifdef __NR_waitpid
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options)
+#else
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
+#endif
+
+/* Uncancelable pause.  */
+#ifdef __NR_pause
+# define pause_not_cancel() \
+  INLINE_SYSCALL (pause, 0)
+#else
+# define pause_not_cancel() \
+  __pause_nocancel ()
+#endif
+
+/* Uncancelable nanosleep.  */
+#ifdef __NR_nanosleep
+# define nanosleep_not_cancel(requested_time, remaining) \
+  INLINE_SYSCALL (nanosleep, 2, requested_time, remaining)
+#else
+# define nanosleep_not_cancel(requested_time, remaining) \
+  __nanosleep_nocancel (requested_time, remaining)
+#endif
+
+/* Uncancelable sigsuspend.  */
+#define sigsuspend_not_cancel(set) \
+  __sigsuspend_nocancel (set)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pt-vfork.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pt-vfork.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pt-vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pt-vfork.S	2012-09-24 12:49:23.000000000 +0100
@@ -0,0 +1,35 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tcb-offsets.h>
+
+/* Save the PID value.  */
+#define SAVE_PID							\
+	mrs	x2, tpidr_el0;						\
+	sub	x2, x2, #PTHREAD_SIZEOF;				\
+	ldr	w3, [x2, #PTHREAD_PID_OFFSET];				\
+	neg	w0, w3;							\
+	str	w0, [x2, #PTHREAD_PID_OFFSET]
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID                                                     \
+	cbz	x0, 1f;							\
+	str	w3, [x2, #PTHREAD_PID_OFFSET];				\
+1:
+
+#include "../vfork.S"
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pthread_once.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pthread_once.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pthread_once.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/pthread_once.c	2012-09-24 12:49:33.000000000 +0100
@@ -0,0 +1,90 @@
+/* Copyright (C) 2004, 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+unsigned long int __fork_generation attribute_hidden;
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
+
+int
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
+{
+  for (;;)
+    {
+      int oldval;
+      int newval;
+
+      /* Pseudo code:
+	 newval = __fork_generation | 1;
+	 oldval = *once_control;
+	 if ((oldval & 2) == 0)
+	   *once_control = newval;
+	 Do this atomically.
+      */
+      do
+	{
+	  newval = __fork_generation | 1;
+	  oldval = *once_control;
+	  if (oldval & 2)
+	    break;
+	} while (atomic_compare_and_exchange_val_acq (once_control, newval, oldval) != oldval);
+
+      /* Check if the initializer has already been done.  */
+      if ((oldval & 2) != 0)
+	return 0;
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) == 0)
+	break;
+
+      /* Check whether the initializer execution was interrupted by a fork.  */
+      if (oldval != newval)
+	break;
+
+      /* Same generation, some other thread was faster. Wait.  */
+      lll_futex_wait (once_control, oldval, LLL_PRIVATE);
+    }
+
+  /* This thread is the first here.  Do the initialization.
+     Register a cleanup handler so that in case the thread gets
+     interrupted the initialization can be restarted.  */
+  pthread_cleanup_push (clear_once_control, once_control);
+
+  init_routine ();
+
+  pthread_cleanup_pop (0);
+
+  /* Say that the initialisation is done.  */
+  *once_control = __fork_generation | 2;
+
+  /* Wake up all other threads.  */
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+hidden_def (__pthread_once)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/sysdep-cancel.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/sysdep-cancel.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/sysdep-cancel.h	2012-09-24 12:49:44.000000000 +0100
@@ -0,0 +1,205 @@
+/* Copyright (C) 2003, 2004, 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+  .section ".text";							\
+  .type __##syscall_name##_nocancel,%function;				\
+  .globl __##syscall_name##_nocancel;					\
+  __##syscall_name##_nocancel:						\
+    cfi_startproc;							\
+    DO_CALL (syscall_name, args);					\
+    PSEUDO_RET;								\
+    cfi_endproc;							\
+    .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	\
+  ENTRY (name);								\
+    SINGLE_THREAD_P;							\
+    DOARGS_##args;							\
+    bne .Lpseudo_cancel;						\
+    DO_CALL (syscall_name, 0);						\
+    UNDOARGS_##args;							\
+    cmn x0, 4095;							\
+    PSEUDO_RET;								\
+  .Lpseudo_cancel:							\
+    DOCARGS_##args;	/* save syscall args etc. around CENABLE.  */	\
+    CENABLE;								\
+    mov x16, x0;	/* put mask in safe place.  */			\
+    UNDOCARGS_##args;	/* restore syscall args.  */			\
+    mov x8, SYS_ify (syscall_name);	/* do the call.  */		\
+    svc	0;								\
+    str x0, [sp, -16]!;	/* save syscall return value.  */		\
+    cfi_adjust_cfa_offset (16);						\
+    mov x0, x16;	 /* get mask back.  */				\
+    CDISABLE;								\
+    ldr x0, [sp], 16;							\
+    cfi_adjust_cfa_offset (-16);					\
+    ldr x30, [sp], 16;							\
+    cfi_adjust_cfa_offset (-16);					\
+    cfi_restore (x30);							\
+    UNDOARGS_##args;							\
+    cmn x0, 4095;
+
+# define DOCARGS_0							\
+	str x30, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x30, 0)
+
+# define UNDOCARGS_0
+
+# define DOCARGS_1							\
+	DOCARGS_0;							\
+	str x0, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x0, 0)
+
+# define UNDOCARGS_1							\
+	ldr x0, [sp], 16;						\
+	cfi_restore (x0);						\
+	cfi_adjust_cfa_offset (-16);					\
+
+# define DOCARGS_2							\
+	DOCARGS_1;							\
+	str x1, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x1, 0)
+
+# define UNDOCARGS_2							\
+	ldr x1, [sp], 16;						\
+	cfi_restore (x1);						\
+	cfi_adjust_cfa_offset (-16);					\
+	UNDOCARGS_1
+
+# define DOCARGS_3							\
+	DOCARGS_2;							\
+	str x2, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x2, 0)
+
+# define UNDOCARGS_3							\
+	ldr x2, [sp], 16;						\
+	cfi_restore (x2);						\
+	cfi_adjust_cfa_offset (-16);					\
+	UNDOCARGS_2
+
+# define DOCARGS_4							\
+	DOCARGS_3;							\
+	str x3, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x3, 0)
+
+# define UNDOCARGS_4							\
+	ldr x3, [sp], 16;						\
+	cfi_restore (x3);						\
+	cfi_adjust_cfa_offset (-16);					\
+	UNDOCARGS_3
+
+# define DOCARGS_5							\
+	DOCARGS_4;							\
+	str x4, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x4, 0)
+
+# define UNDOCARGS_5							\
+	ldr x4, [sp], 16;						\
+	cfi_restore (x4);						\
+	cfi_adjust_cfa_offset (-16);					\
+	UNDOCARGS_4
+
+# define DOCARGS_6							\
+	DOCARGS_5;							\
+	str x5, [sp, -16]!;						\
+	cfi_adjust_cfa_offset (16);					\
+	cfi_rel_offset (x5, 0)
+
+# define UNDOCARGS_6							\
+	ldr x5, [sp], 16;						\
+	cfi_restore (x5);						\
+	cfi_adjust_cfa_offset (-16);					\
+	UNDOCARGS_5
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	bl PLTJMP(__pthread_enable_asynccancel)
+#  define CDISABLE	bl PLTJMP(__pthread_disable_asynccancel)
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define CENABLE	bl PLTJMP(__libc_enable_asynccancel)
+#  define CDISABLE	bl PLTJMP(__libc_disable_asynccancel)
+#  define __local_multiple_threads __libc_multiple_threads
+# elif defined IS_IN_librt
+#  define CENABLE	bl PLTJMP(__librt_enable_asynccancel)
+#  define CDISABLE	bl PLTJMP(__librt_disable_asynccancel)
+# else
+#  error Unsupported library
+# endif
+
+# if defined IS_IN_libpthread || !defined NOT_IN_libc
+#  ifndef __ASSEMBLER__
+extern int __local_multiple_threads attribute_hidden;
+#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+#  else
+#   define SINGLE_THREAD_P						\
+  adrp	x16, __local_multiple_threads;					\
+  add	x16, x16, #:lo12:__local_multiple_threads;			\
+  ldr	x16, [x16];							\
+  cmp	x16, 0;
+#  endif
+# else
+/*  There is no __local_multiple_threads for librt, so use the TCB.  */
+#  ifndef __ASSEMBLER__
+#   define SINGLE_THREAD_P						\
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				\
+				   header.multiple_threads) == 0, 1)
+#  else
+#   define SINGLE_THREAD_P						\
+  stp	x0, x30, [sp, -16]!;						\
+  cfi_adjust_cfa_offset (16);						\
+  cfi_rel_offset (x0, 0);						\
+  cfi_rel_offset (x30, 8);						\
+  bl	__read_tp;							\
+  sub	x0, x0, PTHREAD_SIZEOF;						\
+  ldr	x16, [x0, PTHREAD_MULTIPLE_THREADS_OFFSET];			\
+  ldp	x0, x30, [sp], 16;						\
+  cfi_restore (x0);							\
+  cfi_restore (x30);							\
+  cfi_adjust_cfa_offset (-16);						\
+  cmp	x16, 0
+#   define SINGLE_THREAD_P_PIC(x) SINGLE_THREAD_P
+#  endif
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* For rtld, et cetera.  */
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/vfork.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/vfork.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/nptl/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/nptl/vfork.S	2012-09-24 12:49:57.000000000 +0100
@@ -0,0 +1,37 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tcb-offsets.h>
+
+/* Save the PID value.  */
+#define SAVE_PID                                                              \
+        mrs     x2, tpidr_el0;                                                \
+        sub     x2, x2, #PTHREAD_SIZEOF;                                      \
+        ldr     w3, [x2, #PTHREAD_PID_OFFSET];                                \
+        cmp     w3, #0;                                                       \
+        mov     w0, #0x80000000;                                              \
+	csneg	w0, w0, w3, eq;                                               \
+        str     w0, [x2, #PTHREAD_PID_OFFSET]
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID                                                           \
+        cbz     x0, 1f;                         /* If we are the parent... */ \
+        str     w3, [x2, #PTHREAD_PID_OFFSET];  /* restore the saved PID.  */ \
+1:
+
+#include "../vfork.S"
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/profil-counter.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/profil-counter.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/profil-counter.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/profil-counter.h	2012-09-24 13:01:32.000000000 +0100
@@ -0,0 +1,20 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/setcontext.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/setcontext.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/setcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/setcontext.S	2012-09-24 12:59:03.000000000 +0100
@@ -0,0 +1,89 @@
+/* Set current context.
+
+   Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include "ucontext_i.h"
+#include "ucontext-internal.h"
+
+/* int setcontext (const ucontext_t *ucp) */
+
+	.text
+
+ENTRY(__setcontext)
+
+	/* Create a signal frame on the stack:
+
+		fp
+		lr
+		...
+	   sp-> rt_sigframe
+	 */
+
+	stp     x29, x30, [sp, -16]!
+	cfi_adjust_cfa_offset (16)
+	cfi_rel_offset (x29, 0)
+	cfi_rel_offset (x30, 8)
+
+        mov     x29, sp
+	cfi_def_cfa_register (x29)
+
+	/* Allocate space for the sigcontext.  */
+	mov	w3, #((RT_SIGFRAME_SIZE + SP_ALIGN_SIZE) & SP_ALIGN_MASK)
+	sub	sp, sp,	x3
+
+	/* Compute the base address of the ucontext structure.  */
+	add	x1, sp, #RT_SIGFRAME_UCONTEXT
+
+	/* Only ucontext is required in the frame, *copy* it in.  */
+
+#if UCONTEXT_SIZE % 16
+#error The implementation of setcontext.S assumes sizeof(ucontext_t) % 16 == 0
+#endif
+
+	mov	x2, #UCONTEXT_SIZE / 16
+0:
+	ldp	x3, x4, [x0], #16
+	stp	x3, x4, [x1], #16
+	sub	x2, x2, 1
+	cbnz	x2, 0b
+
+	/* rt_sigreturn () -- no arguments, sp points to struct rt_sigframe.  */
+	mov	x8, SYS_ify (rt_sigreturn)
+	svc	0
+
+	/* Ooops we failed.  Recover the stack */
+
+	mov	sp, x29
+	cfi_def_cfa_register (sp)
+
+        ldp     x29, x30, [sp], 16
+	cfi_adjust_cfa_offset (16)
+	cfi_restore (x29)
+	cfi_restore (x30)
+	b	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+
+PSEUDO_END (__setcontext)
+weak_alias (__setcontext, setcontext)
+
+ENTRY(__startcontext)
+	mov	x0, x19
+	cbnz	x0, PLTJMP(__setcontext)
+1:	b       PLTJMP(HIDDEN_JUMPTARGET(_exit))
+END(__startcontext)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sigaction.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/sigaction.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sigaction.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sigaction.c	2012-09-24 15:07:00.000000000 +0100
@@ -0,0 +1,81 @@
+/* Copyright (C) 1997-2000, 2002, 2003, 2005, 2006, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <kernel-features.h>
+
+#define SA_RESTORER	0x04000000
+
+/* The difference here is that the sigaction structure used in the
+   kernel is not the same as we use in the libc.  Therefore we must
+   translate it here.  */
+#include <kernel_sigaction.h>
+
+int
+__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+  int result;
+  struct kernel_sigaction kact;
+  struct kernel_sigaction koact;
+
+  if (act)
+    {
+      kact.k_sa_handler = act->sa_handler;
+      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));
+      kact.sa_flags = act->sa_flags;
+#ifdef HAVE_SA_RESTORER
+      if (kact.sa_flags & SA_RESTORER)
+	kact.sa_restorer = act->sa_restorer;
+#endif
+    }
+
+  result = INLINE_SYSCALL (rt_sigaction, 4, sig,
+			   act ? __ptrvalue (&kact) : NULL,
+			   oact ? __ptrvalue (&koact) : NULL, _NSIG / 8);
+  if (result >= 0 || errno != ENOSYS)
+    {
+      if (oact && result >= 0)
+	{
+	  oact->sa_handler = koact.k_sa_handler;
+	  memcpy (&oact->sa_mask, &koact.sa_mask, sizeof (sigset_t));
+	  oact->sa_flags = koact.sa_flags;
+#ifdef HAVE_SA_RESTORER
+	  oact->sa_restorer = koact.sa_restorer;
+#endif
+	}
+    }
+  return result;
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifdef WRAPPER_INCLUDE
+# include WRAPPER_INCLUDE
+#endif
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/swapcontext.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/swapcontext.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/swapcontext.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/swapcontext.S	2012-09-24 12:59:21.000000000 +0100
@@ -0,0 +1,100 @@
+/* Modify saved context.
+
+   Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+#include "ucontext_i.h"
+#include "ucontext-internal.h"
+
+/* int swapcontext (ucontext_t *oucp, const ucontext_t *ucp) */
+
+	.text
+ENTRY(__swapcontext)
+	/* Set the value returned when swapcontext() returns in this context. */
+	str	xzr,      [x0, oX0 +  0 * SZREG]
+
+	stp	x18, x19, [x0, oX0 + 18 * SZREG]
+	stp	x20, x21, [x0, oX0 + 20 * SZREG]
+	stp	x22, x23, [x0, oX0 + 22 * SZREG]
+	stp	x24, x25, [x0, oX0 + 24 * SZREG]
+	stp	x26, x27, [x0, oX0 + 26 * SZREG]
+	stp	x28, x29, [x0, oX0 + 28 * SZREG]
+	str     x30,      [x0, oX0 + 30 * SZREG]
+	str     x30,      [x0, oPC]
+	mov	x2, sp
+	str     x2,       [x0, oSP]
+
+	/* Figure out where to place the first context extension
+	   block.  */
+	add     x2, x0, #oEXTENSION
+
+	/* Write the context extension fpsimd header.  */
+	mov	w3, #(FPSIMD_MAGIC & 0xffff)
+	movk	w3, #(FPSIMD_MAGIC >> 16), lsl #16
+	str	w3, [x2, #oHEAD + oMAGIC]
+	mov	w3, #FPSIMD_CONTEXT_SIZE
+	str	w3, [x2, #oHEAD + oSIZE]
+
+	/* Fill in the FP SIMD context.  */
+	add	x3, x2, #oV0 + 8 * SZVREG
+	stp	 d8,  d9, [x3], #2 * SZVREG
+	stp	d10, d11, [x3], #2 * SZVREG
+	stp	d12, d13, [x3], #2 * SZVREG
+	stp	d14, d15, [x3], #2 * SZVREG
+
+	add	x3, x2, #oFPSR
+
+	mrs	x4, fpsr
+	str	w4, [x3, #oFPSR - oFPSR]
+
+	mrs	x4, fpcr
+	str	w4, [x3, #oFPCR - oFPSR]
+
+	/* Write the termination context extension header.  */
+	add	x2, x2, #FPSIMD_CONTEXT_SIZE
+
+	str	xzr, [x2, #oHEAD + oMAGIC]
+	str	xzr, [x2, #oHEAD + oSIZE]
+
+	/* Preserve ucp.  */
+	mov	x21, x1
+
+	/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, &oucp->uc_sigmask,
+			   _NSIG8) */
+	/* Grab the signal mask */
+	/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	add	x2, x0, #UCONTEXT_SIGMASK
+	mov	x0, SIG_BLOCK
+	mov	x1, 0
+	mov	x3, _NSIG8
+	mov	x8, SYS_ify (rt_sigprocmask)
+	svc	0
+	cbnz	x0, 1f
+
+	mov     x22, x30
+	mov	x0, x21
+	bl	JUMPTARGET (__setcontext)
+	mov     x30, x22
+	RET
+
+1:
+	b	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+PSEUDO_END (__swapcontext)
+weak_alias (__swapcontext, swapcontext)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/elf.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/elf.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/elf.h	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_ELF_H
+#define _SYS_ELF_H	1
+
+#warning "This header is obsolete; use <sys/procfs.h> instead."
+
+#include <sys/procfs.h>
+
+#endif	/* sys/elf.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/procfs.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/procfs.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/procfs.h	2012-09-26 20:49:16.000000000 +0100
@@ -0,0 +1,133 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+/* We need to see the definition of struct pt_regs but do not want the
+   linux PTRACE_* defines since they conflict with the generic eglibc
+   definitions in sys/ptrace.h Hence the undef's below.  */
+#include <asm/ptrace.h>
+
+#undef PTRACE_GET_THREAD_AREA
+#undef PTRACE_GETHBPREGS
+#undef PTRACE_SETHBPREGS
+
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   pt_regs' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+#define ELF_NGREG (sizeof (struct user_pt_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+typedef struct user_fpsimd_state elf_fpregset_t;
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h	2012-09-26 20:49:16.000000000 +0100
@@ -0,0 +1,174 @@
+/* `ptrace' debugger support interface.  Linux version.
+   Copyright (C) 1996-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Type of the REQUEST argument to `ptrace.'  */
+enum __ptrace_request
+{
+  /* Indicate that the process making this request should be traced.
+     All signals received by this process can be intercepted by its
+     parent, and its parent can use the other `ptrace' requests.  */
+  PTRACE_TRACEME = 0,
+#define PT_TRACE_ME PTRACE_TRACEME
+
+  /* Return the word in the process's text space at address ADDR.  */
+  PTRACE_PEEKTEXT = 1,
+#define PT_READ_I PTRACE_PEEKTEXT
+
+  /* Return the word in the process's data space at address ADDR.  */
+  PTRACE_PEEKDATA = 2,
+#define PT_READ_D PTRACE_PEEKDATA
+
+  /* Return the word in the process's user area at offset ADDR.  */
+  PTRACE_PEEKUSER = 3,
+#define PT_READ_U PTRACE_PEEKUSER
+
+  /* Write the word DATA into the process's text space at address ADDR.  */
+  PTRACE_POKETEXT = 4,
+#define PT_WRITE_I PTRACE_POKETEXT
+
+  /* Write the word DATA into the process's data space at address ADDR.  */
+  PTRACE_POKEDATA = 5,
+#define PT_WRITE_D PTRACE_POKEDATA
+
+  /* Write the word DATA into the process's user area at offset ADDR.  */
+  PTRACE_POKEUSER = 6,
+#define PT_WRITE_U PTRACE_POKEUSER
+
+  /* Continue the process.  */
+  PTRACE_CONT = 7,
+#define PT_CONTINUE PTRACE_CONT
+
+  /* Kill the process.  */
+  PTRACE_KILL = 8,
+#define PT_KILL PTRACE_KILL
+
+  /* Single step the process. */
+  PTRACE_SINGLESTEP = 9,
+#define PT_STEP PTRACE_SINGLESTEP
+
+  /* Attach to a process that is already running. */
+  PTRACE_ATTACH = 16,
+#define PT_ATTACH PTRACE_ATTACH
+
+  /* Detach from a process attached to with PTRACE_ATTACH.  */
+  PTRACE_DETACH = 17,
+#define PT_DETACH PTRACE_DETACH
+
+  PTRACE_GET_THREAD_AREA = 22,
+
+  /* Continue and stop at the next (return from) syscall.  */
+  PTRACE_SYSCALL = 24,
+#define PT_SYSCALL PTRACE_SYSCALL
+
+  /* Get all hardware breakpoint registers.  */
+  PTRACE_GETHBPREGS = 29,
+
+  /* Set all hardware breakpoint registers.  */
+  PTRACE_SETHBPREGS = 30,
+
+  /* Set ptrace filter options.  */
+  PTRACE_SETOPTIONS = 0x4200,
+#define PT_SETOPTIONS PTRACE_SETOPTIONS
+
+  /* Get last ptrace message.  */
+  PTRACE_GETEVENTMSG = 0x4201,
+#define PT_GETEVENTMSG PTRACE_GETEVENTMSG
+
+  /* Get siginfo for process.  */
+  PTRACE_GETSIGINFO = 0x4202,
+#define PT_GETSIGINFO PTRACE_GETSIGINFO
+
+  /* Set new siginfo for process.  */
+  PTRACE_SETSIGINFO = 0x4203,
+#define PT_SETSIGINFO PTRACE_SETSIGINFO
+
+  /* Get register content.  */
+  PTRACE_GETREGSET = 0x4204,
+#define PTRACE_GETREGSET PTRACE_GETREGSET
+
+  /* Set register content.  */
+  PTRACE_SETREGSET = 0x4205,
+#define PTRACE_SETREGSET PTRACE_SETREGSET
+
+  /* Like PTRACE_ATTACH, but do not force tracee to trap and do not affect
+     signal or group stop state.  */
+  PTRACE_SEIZE = 0x4206,
+#define PTRACE_SEIZE PTRACE_SEIZE
+
+  /* Trap seized trace.  */
+  PTRACE_INTERRUPT = 0x4207,
+#define PTRACE_INTERRUPT PTRACE_INTERRUPT
+
+  /* Wait for next group event.  */
+  PTRACE_LISTEN = 0x4208
+};
+
+
+/* Flag for PTRACE_LISTEN.  */
+enum __ptrace_flags
+{
+  PTRACE_SEIZE_DEVEL = 0x80000000
+};
+
+/* Options set using PTRACE_SETOPTIONS.  */
+enum __ptrace_setoptions
+{
+  PTRACE_O_TRACESYSGOOD	= 0x00000001,
+  PTRACE_O_TRACEFORK	= 0x00000002,
+  PTRACE_O_TRACEVFORK   = 0x00000004,
+  PTRACE_O_TRACECLONE	= 0x00000008,
+  PTRACE_O_TRACEEXEC	= 0x00000010,
+  PTRACE_O_TRACEVFORKDONE = 0x00000020,
+  PTRACE_O_TRACEEXIT	= 0x00000040,
+  PTRACE_O_TRACESECCOMP = 0x00000080,
+  PTRACE_O_MASK		= 0x000000ff
+};
+
+/* Wait extended result codes for the above trace options.  */
+enum __ptrace_eventcodes
+{
+  PTRACE_EVENT_FORK	= 1,
+  PTRACE_EVENT_VFORK	= 2,
+  PTRACE_EVENT_CLONE	= 3,
+  PTRACE_EVENT_EXEC	= 4,
+  PTRACE_EVENT_VFORK_DONE = 5,
+  PTRACE_EVENT_EXIT	= 6,
+  PTRACE_EVENT_SECCOMP  = 7
+};
+
+/* Perform process tracing functions.  REQUEST is one of the values
+   above, and determines the action to be taken.
+   For all requests except PTRACE_TRACEME, PID specifies the process to be
+   traced.
+
+   PID and the other arguments described above for the various requests should
+   appear (those that are used for the particular request) as:
+     pid_t PID, void *ADDR, int DATA, void *ADDR2
+   after REQUEST.  */
+extern long int ptrace (enum __ptrace_request __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/ucontext.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/ucontext.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/ucontext.h	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,55 @@
+/* Copyright (C) 1998, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* System V/AArch64 ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    __sigset_t uc_sigmask;
+    mcontext_t uc_mcontext;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h	2012-09-26 20:49:16.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+/* We need to see the definition of struct pt_regs but do not want the
+   linux PTRACE_* defines since they conflict with the generic glibc
+   definitions in sys/ptrace.h Hence the undef's below.  */
+#include <asm/ptrace.h>
+
+#undef PTRACE_GET_THREAD_AREA
+#undef PTRACE_GETHBPREGS
+#undef PTRACE_SETHBPREGS
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h.orig glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h.orig
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sys/user.h.orig	2012-09-24 12:59:55.000000000 +0100
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+/* We need to see the definition of struct pt_regs but do not want the
+   linux PTRACE_* defines since they conflict with the generic eglibc
+   definitions in sys/ptrace.h Hence the undef's below.  */
+#include <asm/ptrace.h>
+
+#undef PTRACE_GETREGS
+#undef PTRACE_SETREGS
+#undef PTRACE_GETFPREGS
+#undef PTRACE_SETFPREGS
+#undef PTRACE_GET_THREAD_AREA
+#undef PTRACE_SET_SYSCALL
+#undef PTRACE_GETHBPREGS
+#undef PTRACE_SETHBPREGS
+
+#endif
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/syscall.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/syscall.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/syscall.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/syscall.S	2012-09-24 13:00:07.000000000 +0100
@@ -0,0 +1,44 @@
+/* Copyright (C) 2005, 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* syscall (int nr, ...)
+
+   AArch64 system calls take between 0 and 7 arguments. On entry here nr
+   is in w0 and any other system call arguments are in register x1..x7.
+
+   For kernel entry we need to move the system call nr to x8 then
+   load the remaining arguments to register. */
+
+ENTRY (syscall)
+	uxtw	x8, w0
+	mov	x0, x1
+	mov	x1, x2
+	mov	x2, x3
+	mov	x3, x4
+	mov	x4, x5
+	mov	x5, x6
+	mov	x6, x7
+	svc	0x0
+	cmn	x0, #4095
+	b.cs	1f
+	RET
+1:
+	b	PLTJMP(SYSCALL_ERROR)
+PSEUDO_END (syscall)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/syscalls.list glibc/ports/sysdeps/unix/sysv/linux/aarch64/syscalls.list
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/syscalls.list	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,34 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+# Semaphore and shm system calls.
+msgget		-	msgget		i:ii	__msgget	msgget
+msgctl		-	msgctl		i:iip	__msgctl	msgctl
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
+shmctl		-	shmctl		i:iip	__shmctl	shmctl
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
+semget		-	semget		i:iii	__semget	semget
+semctl		-	semctl		i:iiii	__semctl	semctl
+
+# proper socket implementations:
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
+bind		-	bind		i:ipi	__bind		bind
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
+listen		-	listen		i:ii	__listen	listen
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
+setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.c glibc/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.c
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.c	2012-09-25 16:37:48.000000000 +0100
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+int __syscall_error (int err);
+hidden_proto (__syscall_error)
+
+/* This routine is jumped to by all the syscall handlers, to stash
+   an error number into errno.  */
+int
+__syscall_error (int err)
+{
+  __set_errno (- err);
+  return -1;
+}
+hidden_def (__syscall_error)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/sysdep.h	2012-09-24 15:08:39.000000000 +0100
@@ -0,0 +1,401 @@
+/* Copyright (C) 2005-2007, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LINUX_AARCH64_SYSDEP_H
+#define _LINUX_AARCH64_SYSDEP_H 1
+
+#include <sysdeps/unix/sysdep.h>
+#include <sysdeps/aarch64/sysdep.h>
+
+/* Don't use stime, even if the kernel headers define it.  We have
+   settimeofday.  Similarly use setitimer to implement alarm.  */
+#undef __NR_time
+#undef __NR_umount
+#undef __NR_stime
+#undef __NR_alarm
+#undef __NR_utime
+#undef __NR_select
+#undef __NR_readdir
+#undef __NR_socketcall
+#undef __NR_ipc
+
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
+
+#include <tls.h>
+
+/* In order to get __set_errno() definition in INLINE_SYSCALL.  */
+#ifndef __ASSEMBLER__
+#include <errno.h>
+#endif
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#define SYS_ify(syscall_name)	(__NR_##syscall_name)
+
+#ifdef __ASSEMBLER__
+
+/* Linux uses a negative return value to indicate syscall errors,
+   unlike most Unices, which use the condition codes' carry flag.
+
+   Since version 2.1 the return value of a system call might be
+   negative even if the call succeeded.  E.g., the `lseek' system call
+   might return a large offset.  Therefore we must not anymore test
+   for < 0, but test for a real error by making sure the value in R0
+   is a real error number.  Linus said he will make sure the no syscall
+   returns a value in -1 .. -4095 as a valid result so we can safely
+   test with -4095.  */
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name);								      \
+    DO_CALL (syscall_name, args);					      \
+    cmn x0, #4095;
+
+/* Notice the use of 'RET' instead of 'ret' the assembler is case
+   insensitive and eglibc already uses the preprocessor symbol 'ret'
+   so we use the upper case 'RET' to force through a ret instruction
+   to the assembler */
+#define PSEUDO_RET							      \
+    b.cs 1f;								      \
+    RET;								      \
+    1:                                                                        \
+    b PLTJMP(SYSCALL_ERROR)
+#undef ret
+#define ret PSEUDO_RET
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name);								      \
+    DO_CALL (syscall_name, args);
+
+/* Notice the use of 'RET' instead of 'ret' the assembler is case
+   insensitive and eglibc already uses the preprocessor symbol 'ret'
+   so we use the upper case 'RET' to force through a ret instruction
+   to the assembler */
+#define PSEUDO_RET_NOERRNO						      \
+    RET;
+
+#undef ret_NOERRNO
+#define ret_NOERRNO PSEUDO_RET_NOERRNO
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    neg x0, x0
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL PSEUDO_RET_NOERRNO
+
+#if NOT_IN_libc
+# define SYSCALL_ERROR __local_syscall_error
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER					\
+__local_syscall_error:						\
+	adrp	x1, C_SYMBOL_NAME(rtld_errno);			\
+	add	x1, x1, #:lo12:C_SYMBOL_NAME(rtld_errno);	\
+	neg     w0, w0;						\
+	str     w0, [x1];					\
+	mov	x0, -1;						\
+	RET;
+# else
+
+#  define SYSCALL_ERROR_HANDLER					\
+__local_syscall_error:						\
+	stp     x29, x30, [sp, -32]!;				\
+	cfi_adjust_cfa_offset (32);				\
+	cfi_rel_offset (x29, 0);				\
+	cfi_rel_offset (x30, 8);				\
+        add     x29, sp, 0;					\
+        str     x19, [sp,16];					\
+	neg	x19, x0;					\
+	bl	PLTJMP(C_SYMBOL_NAME(__errno_location));	\
+	str	x19, [x0];					\
+	mov	x0, -1;						\
+        ldr     x19, [sp,16];					\
+        ldp     x29, x30, [sp], 32;				\
+	cfi_adjust_cfa_offset (-32);				\
+	cfi_restore (x29);					\
+	cfi_restore (x30);					\
+	RET;
+# endif
+#else
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+# define SYSCALL_ERROR __syscall_error
+#endif
+
+/* Linux takes system call args in registers:
+	syscall number	in the SVC instruction
+	arg 1		x0
+	arg 2		x1
+	arg 3		x2
+	arg 4		x3
+	arg 5		x4
+	arg 6		x5
+	arg 7		x6
+
+   The compiler is going to form a call by coming here, through PSEUDO, with
+   arguments
+	syscall number	in the DO_CALL macro
+	arg 1		x0
+	arg 2		x1
+	arg 3		x2
+	arg 4		x3
+	arg 5		x4
+	arg 6		x5
+	arg 7		x6
+
+   We need to shuffle values between R4..R6 and the stack so that the
+   caller's v1..v3 and stack frame are not corrupted, and the kernel
+   sees the right arguments.
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)		\
+    DOARGS_##args				\
+    mov x8, SYS_ify (syscall_name);		\
+    svc 0;					\
+    UNDOARGS_##args
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 /* nothing */
+#define DOARGS_5 /* nothing */
+#define DOARGS_6 /* nothing */
+#define DOARGS_7 /* nothing */
+
+#define UNDOARGS_0 /* nothing */
+#define UNDOARGS_1 /* nothing */
+#define UNDOARGS_2 /* nothing */
+#define UNDOARGS_3 /* nothing */
+#define UNDOARGS_4 /* nothing */
+#define UNDOARGS_5 /* nothing */
+#define UNDOARGS_6 /* nothing */
+#define UNDOARGS_7 /* nothing */
+
+#else /* not __ASSEMBLER__ */
+
+#ifdef SHARED
+# define INLINE_VSYSCALL(name, nr, args...)				      \
+  ({									      \
+    __label__ out;							      \
+    __label__ iserr;							      \
+    long sc_ret;							      \
+    long sc_err;							      \
+    INTERNAL_SYSCALL_DECL (sc_err);					      \
+									      \
+    if (__vdso_##name != NULL)						      \
+      {									      \
+	register long _x0 asm ("x0");					      \
+	sc_ret = INTERNAL_VSYSCALL_NCS (__vdso_##name, sc_err, nr, ##args);   \
+	if (!INTERNAL_SYSCALL_ERROR_P (sc_ret, sc_err))			      \
+	  goto out;							      \
+	if (INTERNAL_SYSCALL_ERRNO (sc_ret, sc_err) != ENOSYS)		      \
+	  goto iserr;							      \
+      }									      \
+									      \
+    sc_ret = INTERNAL_SYSCALL (name, sc_err, nr, ##args);		      \
+    if (INTERNAL_SYSCALL_ERROR_P (sc_ret, sc_err))			      \
+      {									      \
+      iserr:								      \
+        __set_errno (INTERNAL_SYSCALL_ERRNO (sc_ret, sc_err));		      \
+        sc_ret = -1L;							      \
+      }									      \
+  out:									      \
+    sc_ret;								      \
+  })
+#else
+# define INLINE_VSYSCALL(name, nr, args...) \
+  INLINE_SYSCALL (name, nr, ##args)
+#endif
+
+#ifdef SHARED
+# define INTERNAL_VSYSCALL(name, err, nr, args...)			      \
+  ({									      \
+    __label__ out;							      \
+    long v_ret;								      \
+									      \
+    if (__vdso_##name != NULL)						      \
+      {									      \
+	register long _x0 asm ("x0");					      \
+	v_ret = INTERNAL_VSYSCALL_NCS (__vdso_##name, err, nr, ##args);	      \
+	if (!INTERNAL_SYSCALL_ERROR_P (v_ret, err)			      \
+	    || INTERNAL_SYSCALL_ERRNO (v_ret, err) != ENOSYS)		      \
+	  goto out;							      \
+      }									      \
+    v_ret = INTERNAL_SYSCALL (name, err, nr, ##args);			      \
+  out:									      \
+    v_ret;								      \
+  })
+#else
+# define INTERNAL_VSYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL (name, err, nr, ##args)
+#endif
+
+/* List of system calls which are supported as vsyscalls.  */
+#define HAVE_CLOCK_GETRES_VSYSCALL	1
+#define HAVE_CLOCK_GETTIME_VSYSCALL	1
+
+#define INTERNAL_VSYSCALL_NCS(funcptr, err, nr, args...)	\
+  ({								\
+    LOAD_ARGS_##nr (args)					\
+    asm volatile ("blr %1"					\
+		  : "=r" (_x0)					\
+		  : "r" (funcptr), ASM_ARGS_##nr		\
+		  : "x30", "memory");				\
+    (long) _x0;							\
+  })
+
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ unsigned long _sys_result = INTERNAL_SYSCALL (name, , nr, args);	\
+     if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_sys_result, ), 0))\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (_sys_result, ));		\
+	 _sys_result = (unsigned long) -1;				\
+       }								\
+     (long) _sys_result; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_RAW
+#define INTERNAL_SYSCALL_RAW(name, err, nr, args...)		\
+  ({ unsigned long _sys_result;					\
+     {								\
+       LOAD_ARGS_##nr (args)					\
+       register long _x8 asm ("x8") = (name);			\
+       asm volatile ("svc	0	// syscall " # name     \
+		     : "+r" (_x0), "+r" (_x8)			\
+		     : ASM_ARGS_##nr				\
+		     : "memory", CLOBBER_ARGS_##nr);		\
+       _sys_result = _x0;					\
+     }								\
+     (long) _sys_result; })
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)		\
+	INTERNAL_SYSCALL_RAW(SYS_ify(name), err, nr, args)
+
+#undef INTERNAL_SYSCALL_AARCH64
+#define INTERNAL_SYSCALL_AARCH64(name, err, nr, args...)		\
+	INTERNAL_SYSCALL_RAW(__ARM_NR_##name, err, nr, args)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned long) (val) >= (unsigned long) -4095)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
+
+#define CLOBBER_ARGS_0       CLOBBER_ARGS_1
+#define CLOBBER_ARGS_1 "x1", CLOBBER_ARGS_2
+#define CLOBBER_ARGS_2 "x2", CLOBBER_ARGS_3
+#define CLOBBER_ARGS_3 "x3", CLOBBER_ARGS_4
+#define CLOBBER_ARGS_4 "x4", CLOBBER_ARGS_5
+#define CLOBBER_ARGS_5 "x5", CLOBBER_ARGS_6
+#define CLOBBER_ARGS_6 "x6", CLOBBER_ARGS_7
+#define CLOBBER_ARGS_7 \
+  "x7", "x9", "x10", "x11", "x12", "x13", "x14", "x15", "x16", "x17", "x18"
+
+#define LOAD_ARGS_0()				\
+  register long _x0 asm ("x0");
+
+#define ASM_ARGS_0
+#define LOAD_ARGS_1(x0)				\
+  long _x0tmp = (long) (x0);			\
+  LOAD_ARGS_0 ()				\
+  _x0 = _x0tmp;
+#define ASM_ARGS_1	"r" (_x0)
+#define LOAD_ARGS_2(x0, x1)			\
+  long _x1tmp = (long) (x1);			\
+  LOAD_ARGS_1 (x0)				\
+  register long _x1 asm ("x1") = _x1tmp;
+#define ASM_ARGS_2	ASM_ARGS_1, "r" (_x1)
+#define LOAD_ARGS_3(x0, x1, x2)			\
+  long _x2tmp = (long) (x2);			\
+  LOAD_ARGS_2 (x0, x1)				\
+  register long _x2 asm ("x2") = _x2tmp;
+#define ASM_ARGS_3	ASM_ARGS_2, "r" (_x2)
+#define LOAD_ARGS_4(x0, x1, x2, x3)		\
+  long _x3tmp = (long) (x3);			\
+  LOAD_ARGS_3 (x0, x1, x2)			\
+  register long _x3 asm ("x3") = _x3tmp;
+#define ASM_ARGS_4	ASM_ARGS_3, "r" (_x3)
+#define LOAD_ARGS_5(x0, x1, x2, x3, x4)		\
+  long _x4tmp = (long) (x4);			\
+  LOAD_ARGS_4 (x0, x1, x2, x3)			\
+  register long _x4 asm ("x4") = _x4tmp;
+#define ASM_ARGS_5	ASM_ARGS_4, "r" (_x4)
+#define LOAD_ARGS_6(x0, x1, x2, x3, x4, x5)	\
+  long _x5tmp = (long) (x5);			\
+  LOAD_ARGS_5 (x0, x1, x2, x3, x4)		\
+  register long _x5 asm ("x5") = _x5tmp;
+#define ASM_ARGS_6	ASM_ARGS_5, "r" (_x5)
+#define LOAD_ARGS_7(x0, x1, x2, x3, x4, x5, x6)	\
+  long _x6tmp = (long) (x6);			\
+  LOAD_ARGS_6 (x0, x1, x2, x3, x4, x5)		\
+  register long _x6 asm ("x6") = _x6tmp;
+#define ASM_ARGS_7	ASM_ARGS_6, "r" (_x6)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...)		\
+	INTERNAL_SYSCALL_RAW (number, err, nr, args)
+
+#endif	/* __ASSEMBLER__ */
+
+/* Pointer mangling is not yet supported for AArch64.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#if !defined __NR_pread && defined __NR_pread64
+# define __NR_pread __NR_pread64
+#endif
+
+#if !defined __NR_pwrite && defined __NR_pwrite64
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#endif /* linux/aarch64/sysdep.h */
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ucontext-internal.h glibc/ports/sysdeps/unix/sysv/linux/aarch64/ucontext-internal.h
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ucontext-internal.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/ucontext-internal.h	2012-09-24 13:01:08.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define SP_ALIGN_SIZE       15
+
+#define SP_ALIGN_MASK	   ~15
+
+/* Size of an X regiser in bytes. */
+#define SZREG                8
+
+/* Size of a V register in bytes. */
+#define SZVREG              16
+
+/* Number of integer parameter passing registers. */
+#define NUMXREGARGS          8
+
+/* Number of FP parameter passing registers. */
+#define NUMDREGARGS          8
+
+/* Size of named integer argument in bytes when passed on the
+   stack.  */
+#define SIZEOF_NAMED_INT     4
+
+/* Size of an anonymous integer argument in bytes when passed on the
+   stack.  */
+#define SIZEOF_ANONYMOUS_INT 8
+
+#define oX21 (oX0 + 21*8)
+#define oFP  (oX0 + 29*8)
+#define oLR  (oX0 + 30*8)
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ucontext_i.sym glibc/ports/sysdeps/unix/sysv/linux/aarch64/ucontext_i.sym
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/ucontext_i.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/ucontext_i.sym	2012-09-24 12:41:10.000000000 +0100
@@ -0,0 +1,54 @@
+#include <inttypes.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sys/ucontext.h>
+#include <asm/sigcontext.h>
+
+#include "kernel_rt_sigframe.h"
+
+SIG_BLOCK
+SIG_SETMASK
+
+_NSIG8				(_NSIG / 8)
+
+-- Offsets of the fields in the kernel rt_sigframe_t structure.
+#define rt_sigframe(member)	offsetof (struct kernel_rt_sigframe, member)
+
+RT_SIGFRAME_UCONTEXT		rt_sigframe (uc)
+
+RT_SIGFRAME_SIZE		sizeof (struct kernel_rt_sigframe)
+FPSIMD_CONTEXT_SIZE             sizeof (struct fpsimd_context)
+
+#define ucontext(member)	offsetof (ucontext_t, member)
+#define stack(member)		ucontext (uc_stack.member)
+#define mcontext(member)	ucontext (uc_mcontext.member)
+
+UCONTEXT_FLAGS			ucontext (uc_flags)
+UCONTEXT_LINK			ucontext (uc_link)
+UCONTEXT_STACK			ucontext (uc_stack)
+UCONTEXT_MCONTEXT		ucontext (uc_mcontext)
+UCONTEXT_SIGMASK		ucontext (uc_sigmask)
+UCONTEXT_SIZE			sizeof (ucontext_t)
+
+STACK_SP			stack (ss_sp)
+STACK_SIZE			stack (ss_size)
+STACK_FLAGS			stack (ss_flags)
+
+oX0				mcontext (regs)
+oSP				mcontext (sp)
+oPC				mcontext (pc)
+oEXTENSION                      mcontext (__reserved)
+
+#define fpsimd_context(member)  offsetof (struct fpsimd_context, member)
+
+oHEAD                           fpsimd_context (head)
+oV0                             fpsimd_context (vregs)
+oFPSR                           fpsimd_context (fpsr)
+oFPCR                           fpsimd_context (fpcr)
+
+#define aarch64_ctx(member)  offsetof (struct _aarch64_ctx, member)
+
+oMAGIC                          aarch64_ctx (magic)
+oSIZE                           aarch64_ctx (size)
+
+FPSIMD_MAGIC
diff -x .git -uNr glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/vfork.S glibc/ports/sysdeps/unix/sysv/linux/aarch64/vfork.S
--- glibc.orig/ports/sysdeps/unix/sysv/linux/aarch64/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc/ports/sysdeps/unix/sysv/linux/aarch64/vfork.S	2012-09-24 13:01:26.000000000 +0100
@@ -0,0 +1,50 @@
+/* Copyright (C) 1999, 2002, 2003, 2005, 2009-2012
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <kernel-features.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef SAVE_PID
+	SAVE_PID
+#endif
+	mov	x0, #0x4111	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
+	mov	x1, sp
+	DO_CALL (clone, 2)
+#ifdef RESTORE_PID
+	RESTORE_PID
+#endif
+	cmn	x0, #4095
+	b.cs    1f
+	RET
+1:
+	b	PLTJMP(SYSCALL_ERROR)
+
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
